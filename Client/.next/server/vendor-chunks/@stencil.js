"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stencil";
exports.ids = ["vendor-chunks/@stencil"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stencil/core/internal/app-data/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/app-data/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUILD: () => (/* binding */ BUILD),\n/* harmony export */   Env: () => (/* binding */ Env),\n/* harmony export */   NAMESPACE: () => (/* binding */ NAMESPACE)\n/* harmony export */ });\n// src/app-data/index.ts\nvar BUILD = {\n  allRenderFn: false,\n  cmpDidLoad: true,\n  cmpDidUnload: false,\n  cmpDidUpdate: true,\n  cmpDidRender: true,\n  cmpWillLoad: true,\n  cmpWillUpdate: true,\n  cmpWillRender: true,\n  connectedCallback: true,\n  disconnectedCallback: true,\n  element: true,\n  event: true,\n  hasRenderFn: true,\n  lifecycle: true,\n  hostListener: true,\n  hostListenerTargetWindow: true,\n  hostListenerTargetDocument: true,\n  hostListenerTargetBody: true,\n  hostListenerTargetParent: false,\n  hostListenerTarget: true,\n  member: true,\n  method: true,\n  mode: true,\n  observeAttribute: true,\n  prop: true,\n  propMutable: true,\n  reflect: true,\n  scoped: true,\n  shadowDom: true,\n  slot: true,\n  cssAnnotations: true,\n  state: true,\n  style: true,\n  formAssociated: false,\n  svg: true,\n  updatable: true,\n  vdomAttribute: true,\n  vdomXlink: true,\n  vdomClass: true,\n  vdomFunctional: true,\n  vdomKey: true,\n  vdomListener: true,\n  vdomRef: true,\n  vdomPropOrAttr: true,\n  vdomRender: true,\n  vdomStyle: true,\n  vdomText: true,\n  watchCallback: true,\n  taskQueue: true,\n  hotModuleReplacement: false,\n  isDebug: false,\n  isDev: false,\n  isTesting: false,\n  hydrateServerSide: false,\n  hydrateClientSide: false,\n  lifecycleDOMEvents: false,\n  lazyLoad: false,\n  profile: false,\n  slotRelocation: true,\n  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior\n  appendChildSlotFix: false,\n  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior\n  cloneNodeFix: false,\n  hydratedAttribute: false,\n  hydratedClass: true,\n  // TODO(STENCIL-1305): remove this option\n  scriptDataOpts: false,\n  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior\n  scopedSlotTextContentFix: false,\n  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field\n  shadowDomShim: false,\n  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior\n  slotChildNodesFix: false,\n  invisiblePrehydration: true,\n  propBoolean: true,\n  propNumber: true,\n  propString: true,\n  constructableCSS: true,\n  cmpShouldUpdate: true,\n  devTools: false,\n  shadowDelegatesFocus: true,\n  initializeNextTick: false,\n  asyncLoading: false,\n  asyncQueue: false,\n  transformTagName: false,\n  attachStyles: true,\n  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior\n  experimentalSlotFixes: false\n};\nvar Env = {};\nvar NAMESPACE = (\n  /* default */\n  \"app\"\n);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLRSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhL2luZGV4LmpzP2RlNjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2FwcC1kYXRhL2luZGV4LnRzXG52YXIgQlVJTEQgPSB7XG4gIGFsbFJlbmRlckZuOiBmYWxzZSxcbiAgY21wRGlkTG9hZDogdHJ1ZSxcbiAgY21wRGlkVW5sb2FkOiBmYWxzZSxcbiAgY21wRGlkVXBkYXRlOiB0cnVlLFxuICBjbXBEaWRSZW5kZXI6IHRydWUsXG4gIGNtcFdpbGxMb2FkOiB0cnVlLFxuICBjbXBXaWxsVXBkYXRlOiB0cnVlLFxuICBjbXBXaWxsUmVuZGVyOiB0cnVlLFxuICBjb25uZWN0ZWRDYWxsYmFjazogdHJ1ZSxcbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2s6IHRydWUsXG4gIGVsZW1lbnQ6IHRydWUsXG4gIGV2ZW50OiB0cnVlLFxuICBoYXNSZW5kZXJGbjogdHJ1ZSxcbiAgbGlmZWN5Y2xlOiB0cnVlLFxuICBob3N0TGlzdGVuZXI6IHRydWUsXG4gIGhvc3RMaXN0ZW5lclRhcmdldFdpbmRvdzogdHJ1ZSxcbiAgaG9zdExpc3RlbmVyVGFyZ2V0RG9jdW1lbnQ6IHRydWUsXG4gIGhvc3RMaXN0ZW5lclRhcmdldEJvZHk6IHRydWUsXG4gIGhvc3RMaXN0ZW5lclRhcmdldFBhcmVudDogZmFsc2UsXG4gIGhvc3RMaXN0ZW5lclRhcmdldDogdHJ1ZSxcbiAgbWVtYmVyOiB0cnVlLFxuICBtZXRob2Q6IHRydWUsXG4gIG1vZGU6IHRydWUsXG4gIG9ic2VydmVBdHRyaWJ1dGU6IHRydWUsXG4gIHByb3A6IHRydWUsXG4gIHByb3BNdXRhYmxlOiB0cnVlLFxuICByZWZsZWN0OiB0cnVlLFxuICBzY29wZWQ6IHRydWUsXG4gIHNoYWRvd0RvbTogdHJ1ZSxcbiAgc2xvdDogdHJ1ZSxcbiAgY3NzQW5ub3RhdGlvbnM6IHRydWUsXG4gIHN0YXRlOiB0cnVlLFxuICBzdHlsZTogdHJ1ZSxcbiAgZm9ybUFzc29jaWF0ZWQ6IGZhbHNlLFxuICBzdmc6IHRydWUsXG4gIHVwZGF0YWJsZTogdHJ1ZSxcbiAgdmRvbUF0dHJpYnV0ZTogdHJ1ZSxcbiAgdmRvbVhsaW5rOiB0cnVlLFxuICB2ZG9tQ2xhc3M6IHRydWUsXG4gIHZkb21GdW5jdGlvbmFsOiB0cnVlLFxuICB2ZG9tS2V5OiB0cnVlLFxuICB2ZG9tTGlzdGVuZXI6IHRydWUsXG4gIHZkb21SZWY6IHRydWUsXG4gIHZkb21Qcm9wT3JBdHRyOiB0cnVlLFxuICB2ZG9tUmVuZGVyOiB0cnVlLFxuICB2ZG9tU3R5bGU6IHRydWUsXG4gIHZkb21UZXh0OiB0cnVlLFxuICB3YXRjaENhbGxiYWNrOiB0cnVlLFxuICB0YXNrUXVldWU6IHRydWUsXG4gIGhvdE1vZHVsZVJlcGxhY2VtZW50OiBmYWxzZSxcbiAgaXNEZWJ1ZzogZmFsc2UsXG4gIGlzRGV2OiBmYWxzZSxcbiAgaXNUZXN0aW5nOiBmYWxzZSxcbiAgaHlkcmF0ZVNlcnZlclNpZGU6IGZhbHNlLFxuICBoeWRyYXRlQ2xpZW50U2lkZTogZmFsc2UsXG4gIGxpZmVjeWNsZURPTUV2ZW50czogZmFsc2UsXG4gIGxhenlMb2FkOiBmYWxzZSxcbiAgcHJvZmlsZTogZmFsc2UsXG4gIHNsb3RSZWxvY2F0aW9uOiB0cnVlLFxuICAvLyBUT0RPKFNURU5DSUwtOTE0KTogcmVtb3ZlIHRoaXMgb3B0aW9uIHdoZW4gYGV4cGVyaW1lbnRhbFNsb3RGaXhlc2AgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgYXBwZW5kQ2hpbGRTbG90Rml4OiBmYWxzZSxcbiAgLy8gVE9ETyhTVEVOQ0lMLTkxNCk6IHJlbW92ZSB0aGlzIG9wdGlvbiB3aGVuIGBleHBlcmltZW50YWxTbG90Rml4ZXNgIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gIGNsb25lTm9kZUZpeDogZmFsc2UsXG4gIGh5ZHJhdGVkQXR0cmlidXRlOiBmYWxzZSxcbiAgaHlkcmF0ZWRDbGFzczogdHJ1ZSxcbiAgLy8gVE9ETyhTVEVOQ0lMLTEzMDUpOiByZW1vdmUgdGhpcyBvcHRpb25cbiAgc2NyaXB0RGF0YU9wdHM6IGZhbHNlLFxuICAvLyBUT0RPKFNURU5DSUwtOTE0KTogcmVtb3ZlIHRoaXMgb3B0aW9uIHdoZW4gYGV4cGVyaW1lbnRhbFNsb3RGaXhlc2AgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgc2NvcGVkU2xvdFRleHRDb250ZW50Rml4OiBmYWxzZSxcbiAgLy8gVE9ETyhTVEVOQ0lMLTg1NCk6IFJlbW92ZSBjb2RlIHJlbGF0ZWQgdG8gbGVnYWN5IHNoYWRvd0RvbVNoaW0gZmllbGRcbiAgc2hhZG93RG9tU2hpbTogZmFsc2UsXG4gIC8vIFRPRE8oU1RFTkNJTC05MTQpOiByZW1vdmUgdGhpcyBvcHRpb24gd2hlbiBgZXhwZXJpbWVudGFsU2xvdEZpeGVzYCBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICBzbG90Q2hpbGROb2Rlc0ZpeDogZmFsc2UsXG4gIGludmlzaWJsZVByZWh5ZHJhdGlvbjogdHJ1ZSxcbiAgcHJvcEJvb2xlYW46IHRydWUsXG4gIHByb3BOdW1iZXI6IHRydWUsXG4gIHByb3BTdHJpbmc6IHRydWUsXG4gIGNvbnN0cnVjdGFibGVDU1M6IHRydWUsXG4gIGNtcFNob3VsZFVwZGF0ZTogdHJ1ZSxcbiAgZGV2VG9vbHM6IGZhbHNlLFxuICBzaGFkb3dEZWxlZ2F0ZXNGb2N1czogdHJ1ZSxcbiAgaW5pdGlhbGl6ZU5leHRUaWNrOiBmYWxzZSxcbiAgYXN5bmNMb2FkaW5nOiBmYWxzZSxcbiAgYXN5bmNRdWV1ZTogZmFsc2UsXG4gIHRyYW5zZm9ybVRhZ05hbWU6IGZhbHNlLFxuICBhdHRhY2hTdHlsZXM6IHRydWUsXG4gIC8vIFRPRE8oU1RFTkNJTC05MTQpOiByZW1vdmUgdGhpcyBvcHRpb24gd2hlbiBgZXhwZXJpbWVudGFsU2xvdEZpeGVzYCBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICBleHBlcmltZW50YWxTbG90Rml4ZXM6IGZhbHNlXG59O1xudmFyIEVudiA9IHt9O1xudmFyIE5BTUVTUEFDRSA9IChcbiAgLyogZGVmYXVsdCAqL1xuICBcImFwcFwiXG4pO1xuZXhwb3J0IHtcbiAgQlVJTEQsXG4gIEVudixcbiAgTkFNRVNQQUNFXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stencil/core/internal/app-data/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stencil/core/internal/client/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/client/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUILD: () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD),\n/* harmony export */   Build: () => (/* binding */ Build),\n/* harmony export */   Env: () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.Env),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   H: () => (/* binding */ H),\n/* harmony export */   HTMLElement: () => (/* binding */ H),\n/* harmony export */   Host: () => (/* binding */ Host),\n/* harmony export */   NAMESPACE: () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE),\n/* harmony export */   STENCIL_DEV_MODE: () => (/* binding */ STENCIL_DEV_MODE),\n/* harmony export */   addHostEventListeners: () => (/* binding */ addHostEventListeners),\n/* harmony export */   bootstrapLazy: () => (/* binding */ bootstrapLazy),\n/* harmony export */   cmpModules: () => (/* binding */ cmpModules),\n/* harmony export */   connectedCallback: () => (/* binding */ connectedCallback),\n/* harmony export */   consoleDevError: () => (/* binding */ consoleDevError),\n/* harmony export */   consoleDevInfo: () => (/* binding */ consoleDevInfo),\n/* harmony export */   consoleDevWarn: () => (/* binding */ consoleDevWarn),\n/* harmony export */   consoleError: () => (/* binding */ consoleError),\n/* harmony export */   createEvent: () => (/* binding */ createEvent),\n/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement),\n/* harmony export */   disconnectedCallback: () => (/* binding */ disconnectedCallback),\n/* harmony export */   doc: () => (/* binding */ doc),\n/* harmony export */   forceModeUpdate: () => (/* binding */ forceModeUpdate),\n/* harmony export */   forceUpdate: () => (/* binding */ forceUpdate),\n/* harmony export */   getAssetPath: () => (/* binding */ getAssetPath),\n/* harmony export */   getElement: () => (/* binding */ getElement),\n/* harmony export */   getHostRef: () => (/* binding */ getHostRef),\n/* harmony export */   getMode: () => (/* binding */ getMode),\n/* harmony export */   getRenderingRef: () => (/* binding */ getRenderingRef),\n/* harmony export */   getValue: () => (/* binding */ getValue),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   insertVdomAnnotations: () => (/* binding */ insertVdomAnnotations),\n/* harmony export */   isMemberInElement: () => (/* binding */ isMemberInElement),\n/* harmony export */   loadModule: () => (/* binding */ loadModule),\n/* harmony export */   modeResolutionChain: () => (/* binding */ modeResolutionChain),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   parsePropertyValue: () => (/* binding */ parsePropertyValue),\n/* harmony export */   plt: () => (/* binding */ plt),\n/* harmony export */   postUpdateComponent: () => (/* binding */ postUpdateComponent),\n/* harmony export */   promiseResolve: () => (/* binding */ promiseResolve),\n/* harmony export */   proxyComponent: () => (/* binding */ proxyComponent),\n/* harmony export */   proxyCustomElement: () => (/* binding */ proxyCustomElement),\n/* harmony export */   readTask: () => (/* binding */ readTask),\n/* harmony export */   registerHost: () => (/* binding */ registerHost),\n/* harmony export */   registerInstance: () => (/* binding */ registerInstance),\n/* harmony export */   renderVdom: () => (/* binding */ renderVdom),\n/* harmony export */   setAssetPath: () => (/* binding */ setAssetPath),\n/* harmony export */   setErrorHandler: () => (/* binding */ setErrorHandler),\n/* harmony export */   setMode: () => (/* binding */ setMode),\n/* harmony export */   setNonce: () => (/* binding */ setNonce),\n/* harmony export */   setPlatformHelpers: () => (/* binding */ setPlatformHelpers),\n/* harmony export */   setPlatformOptions: () => (/* binding */ setPlatformOptions),\n/* harmony export */   setValue: () => (/* binding */ setValue),\n/* harmony export */   styles: () => (/* binding */ styles),\n/* harmony export */   supportsConstructableStylesheets: () => (/* binding */ supportsConstructableStylesheets),\n/* harmony export */   supportsListenerOptions: () => (/* binding */ supportsListenerOptions),\n/* harmony export */   supportsShadow: () => (/* binding */ supportsShadow),\n/* harmony export */   win: () => (/* binding */ win),\n/* harmony export */   writeTask: () => (/* binding */ writeTask)\n/* harmony export */ });\n/* harmony import */ var _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/app-data */ \"(ssr)/./node_modules/@stencil/core/internal/app-data/index.js\");\n/*\n Stencil Client Platform v4.19.2 | MIT Licensed | https://stenciljs.com\n */\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/client/client-build.ts\n\nvar Build = {\n  isDev: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev ? true : false,\n  isBrowser: true,\n  isServer: false,\n  isTesting: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isTesting ? true : false\n};\n\n// src/client/client-host-ref.ts\n\nvar hostRefs = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement ? window.__STENCIL_HOSTREFS__ || (window.__STENCIL_HOSTREFS__ = /* @__PURE__ */ new WeakMap()) : /* @__PURE__ */ new WeakMap();\nvar getHostRef = (ref) => hostRefs.get(ref);\nvar registerInstance = (lazyInstance, hostRef) => hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);\nvar registerHost = (hostElement, cmpMeta) => {\n  const hostRef = {\n    $flags$: 0,\n    $hostElement$: hostElement,\n    $cmpMeta$: cmpMeta,\n    $instanceValues$: /* @__PURE__ */ new Map()\n  };\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n    hostRef.$renderCount$ = 0;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {\n    hostRef.$onInstancePromise$ = new Promise((r) => hostRef.$onInstanceResolve$ = r);\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {\n    hostRef.$onReadyPromise$ = new Promise((r) => hostRef.$onReadyResolve$ = r);\n    hostElement[\"s-p\"] = [];\n    hostElement[\"s-rc\"] = [];\n  }\n  return hostRefs.set(hostElement, hostRef);\n};\nvar isMemberInElement = (elm, memberName) => memberName in elm;\n\n// src/client/client-load-module.ts\n\n\n// src/client/client-log.ts\n\nvar customError;\nvar consoleError = (e, el) => (customError || console.error)(e, el);\nvar STENCIL_DEV_MODE = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isTesting ? [\"STENCIL:\"] : [\n  \"%cstencil\",\n  \"color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px\"\n];\nvar consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);\nvar consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);\nvar consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);\nvar setErrorHandler = (handler) => customError = handler;\n\n// src/client/client-load-module.ts\nvar cmpModules = /* @__PURE__ */ new Map();\nvar MODULE_IMPORT_PREFIX = \"./\";\nvar loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n  const exportName = cmpMeta.$tagName$.replace(/-/g, \"_\");\n  const bundleId = cmpMeta.$lazyBundleId$;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && typeof bundleId !== \"string\") {\n    consoleDevError(\n      `Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \"${hostRef.$modeName$}\", but it does not exist.`\n    );\n    return void 0;\n  } else if (!bundleId) {\n    return void 0;\n  }\n  const module = !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;\n  if (module) {\n    return module[exportName];\n  }\n  /*!__STENCIL_STATIC_IMPORT_SWITCH__*/\n  return __webpack_require__(\"(ssr)/./node_modules/@stencil/core/internal/client lazy recursive ^\\\\.\\\\/.*\\\\.entry\\\\.js.*$ include: \\\\.entry\\\\.js$ exclude: \\\\.system\\\\.entry\\\\.js$\")(`./${bundleId}.entry.js${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement && hmrVersionId ? \"?s-hmr=\" + hmrVersionId : \"\"}`).then((importedModule) => {\n    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {\n      cmpModules.set(bundleId, importedModule);\n    }\n    return importedModule[exportName];\n  }, consoleError);\n};\n\n// src/client/client-style.ts\nvar styles = /* @__PURE__ */ new Map();\nvar modeResolutionChain = [];\n\n// src/client/client-task-queue.ts\n\n\n// src/runtime/runtime-constants.ts\nvar CONTENT_REF_ID = \"r\";\nvar ORG_LOCATION_ID = \"o\";\nvar SLOT_NODE_ID = \"s\";\nvar TEXT_NODE_ID = \"t\";\nvar HYDRATE_ID = \"s-id\";\nvar HYDRATED_STYLE_ID = \"sty-id\";\nvar HYDRATE_CHILD_ID = \"c-id\";\nvar HYDRATED_CSS = \"{visibility:hidden}.hydrated{visibility:inherit}\";\nvar SLOT_FB_CSS = \"slot-fb{display:contents}slot-fb[hidden]{display:none}\";\nvar XLINK_NS = \"http://www.w3.org/1999/xlink\";\nvar FORM_ASSOCIATED_CUSTOM_ELEMENT_CALLBACKS = [\n  \"formAssociatedCallback\",\n  \"formResetCallback\",\n  \"formDisabledCallback\",\n  \"formStateRestoreCallback\"\n];\n\n// src/client/client-window.ts\n\nvar win = typeof window !== \"undefined\" ? window : {};\nvar doc = win.document || { head: {} };\nvar H = win.HTMLElement || class {\n};\nvar plt = {\n  $flags$: 0,\n  $resourcesUrl$: \"\",\n  jmp: (h2) => h2(),\n  raf: (h2) => requestAnimationFrame(h2),\n  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n  ce: (eventName, opts) => new CustomEvent(eventName, opts)\n};\nvar setPlatformHelpers = (helpers) => {\n  Object.assign(plt, helpers);\n};\nvar supportsShadow = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom;\nvar supportsListenerOptions = /* @__PURE__ */ (() => {\n  let supportsListenerOptions2 = false;\n  try {\n    doc.addEventListener(\n      \"e\",\n      null,\n      Object.defineProperty({}, \"passive\", {\n        get() {\n          supportsListenerOptions2 = true;\n        }\n      })\n    );\n  } catch (e) {\n  }\n  return supportsListenerOptions2;\n})();\nvar promiseResolve = (v) => Promise.resolve(v);\nvar supportsConstructableStylesheets = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.constructableCSS ? /* @__PURE__ */ (() => {\n  try {\n    new CSSStyleSheet();\n    return typeof new CSSStyleSheet().replaceSync === \"function\";\n  } catch (e) {\n  }\n  return false;\n})() : false;\n\n// src/client/client-task-queue.ts\nvar queueCongestion = 0;\nvar queuePending = false;\nvar queueDomReads = [];\nvar queueDomWrites = [];\nvar queueDomWritesLow = [];\nvar queueTask = (queue, write) => (cb) => {\n  queue.push(cb);\n  if (!queuePending) {\n    queuePending = true;\n    if (write && plt.$flags$ & 4 /* queueSync */) {\n      nextTick(flush);\n    } else {\n      plt.raf(flush);\n    }\n  }\n};\nvar consume = (queue) => {\n  for (let i2 = 0; i2 < queue.length; i2++) {\n    try {\n      queue[i2](performance.now());\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  queue.length = 0;\n};\nvar consumeTimeout = (queue, timeout) => {\n  let i2 = 0;\n  let ts = 0;\n  while (i2 < queue.length && (ts = performance.now()) < timeout) {\n    try {\n      queue[i2++](ts);\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  if (i2 === queue.length) {\n    queue.length = 0;\n  } else if (i2 !== 0) {\n    queue.splice(0, i2);\n  }\n};\nvar flush = () => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {\n    queueCongestion++;\n  }\n  consume(queueDomReads);\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {\n    const timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */ ? performance.now() + 14 * Math.ceil(queueCongestion * (1 / 10)) : Infinity;\n    consumeTimeout(queueDomWrites, timeout);\n    consumeTimeout(queueDomWritesLow, timeout);\n    if (queueDomWrites.length > 0) {\n      queueDomWritesLow.push(...queueDomWrites);\n      queueDomWrites.length = 0;\n    }\n    if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {\n      plt.raf(flush);\n    } else {\n      queueCongestion = 0;\n    }\n  } else {\n    consume(queueDomWrites);\n    if (queuePending = queueDomReads.length > 0) {\n      plt.raf(flush);\n    }\n  }\n};\nvar nextTick = (cb) => promiseResolve().then(cb);\nvar readTask = /* @__PURE__ */ queueTask(queueDomReads, false);\nvar writeTask = /* @__PURE__ */ queueTask(queueDomWrites, true);\n\n// src/client/index.ts\n\n\n// src/runtime/asset-path.ts\nvar getAssetPath = (path) => {\n  const assetUrl = new URL(path, plt.$resourcesUrl$);\n  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nvar setAssetPath = (path) => plt.$resourcesUrl$ = path;\n\n// src/runtime/bootstrap-custom-element.ts\n\n\n// src/utils/constants.ts\nvar EMPTY_OBJ = {};\nvar SVG_NS = \"http://www.w3.org/2000/svg\";\nvar HTML_NS = \"http://www.w3.org/1999/xhtml\";\n\n// src/utils/helpers.ts\nvar isDef = (v) => v != null;\nvar isComplexType = (o) => {\n  o = typeof o;\n  return o === \"object\" || o === \"function\";\n};\n\n// src/utils/query-nonce-meta-tag-content.ts\nfunction queryNonceMetaTagContent(doc2) {\n  var _a, _b, _c;\n  return (_c = (_b = (_a = doc2.head) == null ? void 0 : _a.querySelector('meta[name=\"csp-nonce\"]')) == null ? void 0 : _b.getAttribute(\"content\")) != null ? _c : void 0;\n}\n\n// src/utils/result.ts\nvar result_exports = {};\n__export(result_exports, {\n  err: () => err,\n  map: () => map,\n  ok: () => ok,\n  unwrap: () => unwrap,\n  unwrapErr: () => unwrapErr\n});\nvar ok = (value) => ({\n  isOk: true,\n  isErr: false,\n  value\n});\nvar err = (value) => ({\n  isOk: false,\n  isErr: true,\n  value\n});\nfunction map(result, fn) {\n  if (result.isOk) {\n    const val = fn(result.value);\n    if (val instanceof Promise) {\n      return val.then((newVal) => ok(newVal));\n    } else {\n      return ok(val);\n    }\n  }\n  if (result.isErr) {\n    const value = result.value;\n    return err(value);\n  }\n  throw \"should never get here\";\n}\nvar unwrap = (result) => {\n  if (result.isOk) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\nvar unwrapErr = (result) => {\n  if (result.isErr) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\n\n// src/runtime/connected-callback.ts\n\n\n// src/runtime/client-hydrate.ts\n\n\n// src/runtime/profile.ts\n\nvar i = 0;\nvar createTime = (fnName, tagName = \"\") => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {\n    const key = `st:${fnName}:${tagName}:${i++}`;\n    performance.mark(key);\n    return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);\n  } else {\n    return () => {\n      return;\n    };\n  }\n};\nvar uniqueTime = (key, measureText) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {\n    if (performance.getEntriesByName(key, \"mark\").length === 0) {\n      performance.mark(key);\n    }\n    return () => {\n      if (performance.getEntriesByName(measureText, \"measure\").length === 0) {\n        performance.measure(measureText, key);\n      }\n    };\n  } else {\n    return () => {\n      return;\n    };\n  }\n};\nvar inspect = (ref) => {\n  const hostRef = getHostRef(ref);\n  if (!hostRef) {\n    return void 0;\n  }\n  const flags = hostRef.$flags$;\n  const hostElement = hostRef.$hostElement$;\n  return {\n    renderCount: hostRef.$renderCount$,\n    flags: {\n      hasRendered: !!(flags & 2 /* hasRendered */),\n      hasConnected: !!(flags & 1 /* hasConnected */),\n      isWaitingForChildren: !!(flags & 4 /* isWaitingForChildren */),\n      isConstructingInstance: !!(flags & 8 /* isConstructingInstance */),\n      isQueuedForUpdate: !!(flags & 16 /* isQueuedForUpdate */),\n      hasInitializedComponent: !!(flags & 32 /* hasInitializedComponent */),\n      hasLoadedComponent: !!(flags & 64 /* hasLoadedComponent */),\n      isWatchReady: !!(flags & 128 /* isWatchReady */),\n      isListenReady: !!(flags & 256 /* isListenReady */),\n      needsRerender: !!(flags & 512 /* needsRerender */)\n    },\n    instanceValues: hostRef.$instanceValues$,\n    ancestorComponent: hostRef.$ancestorComponent$,\n    hostElement,\n    lazyInstance: hostRef.$lazyInstance$,\n    vnode: hostRef.$vnode$,\n    modeName: hostRef.$modeName$,\n    onReadyPromise: hostRef.$onReadyPromise$,\n    onReadyResolve: hostRef.$onReadyResolve$,\n    onInstancePromise: hostRef.$onInstancePromise$,\n    onInstanceResolve: hostRef.$onInstanceResolve$,\n    onRenderResolve: hostRef.$onRenderResolve$,\n    queuedListeners: hostRef.$queuedListeners$,\n    rmListeners: hostRef.$rmListeners$,\n    [\"s-id\"]: hostElement[\"s-id\"],\n    [\"s-cr\"]: hostElement[\"s-cr\"],\n    [\"s-lr\"]: hostElement[\"s-lr\"],\n    [\"s-p\"]: hostElement[\"s-p\"],\n    [\"s-rc\"]: hostElement[\"s-rc\"],\n    [\"s-sc\"]: hostElement[\"s-sc\"]\n  };\n};\nvar installDevTools = () => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.devTools) {\n    const stencil = win.stencil = win.stencil || {};\n    const originalInspect = stencil.inspect;\n    stencil.inspect = (ref) => {\n      let result = inspect(ref);\n      if (!result && typeof originalInspect === \"function\") {\n        result = originalInspect(ref);\n      }\n      return result;\n    };\n  }\n};\n\n// src/runtime/vdom/h.ts\n\nvar h = (nodeName, vnodeData, ...children) => {\n  let child = null;\n  let key = null;\n  let slotName = null;\n  let simple = false;\n  let lastSimple = false;\n  const vNodeChildren = [];\n  const walk = (c) => {\n    for (let i2 = 0; i2 < c.length; i2++) {\n      child = c[i2];\n      if (Array.isArray(child)) {\n        walk(child);\n      } else if (child != null && typeof child !== \"boolean\") {\n        if (simple = typeof nodeName !== \"function\" && !isComplexType(child)) {\n          child = String(child);\n        } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && typeof nodeName !== \"function\" && child.$flags$ === void 0) {\n          consoleDevError(`vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects.`);\n        }\n        if (simple && lastSimple) {\n          vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n        } else {\n          vNodeChildren.push(simple ? newVNode(null, child) : child);\n        }\n        lastSimple = simple;\n      }\n    }\n  };\n  walk(children);\n  if (vnodeData) {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && nodeName === \"input\") {\n      validateInputProperties(vnodeData);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && vnodeData.key) {\n      key = vnodeData.key;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && vnodeData.name) {\n      slotName = vnodeData.name;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomClass) {\n      const classData = vnodeData.className || vnodeData.class;\n      if (classData) {\n        vnodeData.class = typeof classData !== \"object\" ? classData : Object.keys(classData).filter((k) => classData[k]).join(\" \");\n      }\n    }\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && vNodeChildren.some(isHost)) {\n    consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`);\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomFunctional && typeof nodeName === \"function\") {\n    return nodeName(\n      vnodeData === null ? {} : vnodeData,\n      vNodeChildren,\n      vdomFnUtils\n    );\n  }\n  const vnode = newVNode(nodeName, null);\n  vnode.$attrs$ = vnodeData;\n  if (vNodeChildren.length > 0) {\n    vnode.$children$ = vNodeChildren;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {\n    vnode.$key$ = key;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n    vnode.$name$ = slotName;\n  }\n  return vnode;\n};\nvar newVNode = (tag, text) => {\n  const vnode = {\n    $flags$: 0,\n    $tag$: tag,\n    $text$: text,\n    $elm$: null,\n    $children$: null\n  };\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute) {\n    vnode.$attrs$ = null;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {\n    vnode.$key$ = null;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n    vnode.$name$ = null;\n  }\n  return vnode;\n};\nvar Host = {};\nvar isHost = (node) => node && node.$tag$ === Host;\nvar vdomFnUtils = {\n  forEach: (children, cb) => children.map(convertToPublic).forEach(cb),\n  map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate)\n};\nvar convertToPublic = (node) => ({\n  vattrs: node.$attrs$,\n  vchildren: node.$children$,\n  vkey: node.$key$,\n  vname: node.$name$,\n  vtag: node.$tag$,\n  vtext: node.$text$\n});\nvar convertToPrivate = (node) => {\n  if (typeof node.vtag === \"function\") {\n    const vnodeData = { ...node.vattrs };\n    if (node.vkey) {\n      vnodeData.key = node.vkey;\n    }\n    if (node.vname) {\n      vnodeData.name = node.vname;\n    }\n    return h(node.vtag, vnodeData, ...node.vchildren || []);\n  }\n  const vnode = newVNode(node.vtag, node.vtext);\n  vnode.$attrs$ = node.vattrs;\n  vnode.$children$ = node.vchildren;\n  vnode.$key$ = node.vkey;\n  vnode.$name$ = node.vname;\n  return vnode;\n};\nvar validateInputProperties = (inputElm) => {\n  const props = Object.keys(inputElm);\n  const value = props.indexOf(\"value\");\n  if (value === -1) {\n    return;\n  }\n  const typeIndex = props.indexOf(\"type\");\n  const minIndex = props.indexOf(\"min\");\n  const maxIndex = props.indexOf(\"max\");\n  const stepIndex = props.indexOf(\"step\");\n  if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\n    consoleDevWarn(`The \"value\" prop of <input> should be set after \"min\", \"max\", \"type\" and \"step\"`);\n  }\n};\n\n// src/runtime/client-hydrate.ts\nvar initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {\n  const endHydrate = createTime(\"hydrateClient\", tagName);\n  const shadowRoot = hostElm.shadowRoot;\n  const childRenderNodes = [];\n  const slotNodes = [];\n  const shadowRootNodes = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRoot ? [] : null;\n  const vnode = hostRef.$vnode$ = newVNode(tagName, null);\n  if (!plt.$orgLocNodes$) {\n    initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = /* @__PURE__ */ new Map());\n  }\n  hostElm[HYDRATE_ID] = hostId;\n  hostElm.removeAttribute(HYDRATE_ID);\n  clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n  childRenderNodes.map((c) => {\n    const orgLocationId = c.$hostId$ + \".\" + c.$nodeId$;\n    const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n    const node = c.$elm$;\n    if (orgLocationNode && supportsShadow && orgLocationNode[\"s-en\"] === \"\") {\n      orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n    }\n    if (!shadowRoot) {\n      node[\"s-hn\"] = tagName;\n      if (orgLocationNode) {\n        node[\"s-ol\"] = orgLocationNode;\n        node[\"s-ol\"][\"s-nr\"] = node;\n      }\n    }\n    plt.$orgLocNodes$.delete(orgLocationId);\n  });\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRoot) {\n    shadowRootNodes.map((shadowRootNode) => {\n      if (shadowRootNode) {\n        shadowRoot.appendChild(shadowRootNode);\n      }\n    });\n  }\n  endHydrate();\n};\nvar clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {\n  let childNodeType;\n  let childIdSplt;\n  let childVNode;\n  let i2;\n  if (node.nodeType === 1 /* ElementNode */) {\n    childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n    if (childNodeType) {\n      childIdSplt = childNodeType.split(\".\");\n      if (childIdSplt[0] === hostId || childIdSplt[0] === \"0\") {\n        childVNode = {\n          $flags$: 0,\n          $hostId$: childIdSplt[0],\n          $nodeId$: childIdSplt[1],\n          $depth$: childIdSplt[2],\n          $index$: childIdSplt[3],\n          $tag$: node.tagName.toLowerCase(),\n          $elm$: node,\n          $attrs$: null,\n          $children$: null,\n          $key$: null,\n          $name$: null,\n          $text$: null\n        };\n        childRenderNodes.push(childVNode);\n        node.removeAttribute(HYDRATE_CHILD_ID);\n        if (!parentVNode.$children$) {\n          parentVNode.$children$ = [];\n        }\n        parentVNode.$children$[childVNode.$index$] = childVNode;\n        parentVNode = childVNode;\n        if (shadowRootNodes && childVNode.$depth$ === \"0\") {\n          shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n        }\n      }\n    }\n    for (i2 = node.childNodes.length - 1; i2 >= 0; i2--) {\n      clientHydrate(\n        parentVNode,\n        childRenderNodes,\n        slotNodes,\n        shadowRootNodes,\n        hostElm,\n        node.childNodes[i2],\n        hostId\n      );\n    }\n    if (node.shadowRoot) {\n      for (i2 = node.shadowRoot.childNodes.length - 1; i2 >= 0; i2--) {\n        clientHydrate(\n          parentVNode,\n          childRenderNodes,\n          slotNodes,\n          shadowRootNodes,\n          hostElm,\n          node.shadowRoot.childNodes[i2],\n          hostId\n        );\n      }\n    }\n  } else if (node.nodeType === 8 /* CommentNode */) {\n    childIdSplt = node.nodeValue.split(\".\");\n    if (childIdSplt[1] === hostId || childIdSplt[1] === \"0\") {\n      childNodeType = childIdSplt[0];\n      childVNode = {\n        $flags$: 0,\n        $hostId$: childIdSplt[1],\n        $nodeId$: childIdSplt[2],\n        $depth$: childIdSplt[3],\n        $index$: childIdSplt[4],\n        $elm$: node,\n        $attrs$: null,\n        $children$: null,\n        $key$: null,\n        $name$: null,\n        $tag$: null,\n        $text$: null\n      };\n      if (childNodeType === TEXT_NODE_ID) {\n        childVNode.$elm$ = node.nextSibling;\n        if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {\n          childVNode.$text$ = childVNode.$elm$.textContent;\n          childRenderNodes.push(childVNode);\n          node.remove();\n          if (!parentVNode.$children$) {\n            parentVNode.$children$ = [];\n          }\n          parentVNode.$children$[childVNode.$index$] = childVNode;\n          if (shadowRootNodes && childVNode.$depth$ === \"0\") {\n            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n          }\n        }\n      } else if (childVNode.$hostId$ === hostId) {\n        if (childNodeType === SLOT_NODE_ID) {\n          childVNode.$tag$ = \"slot\";\n          if (childIdSplt[5]) {\n            node[\"s-sn\"] = childVNode.$name$ = childIdSplt[5];\n          } else {\n            node[\"s-sn\"] = \"\";\n          }\n          node[\"s-sr\"] = true;\n          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRootNodes) {\n            childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n            if (childVNode.$name$) {\n              childVNode.$elm$.setAttribute(\"name\", childVNode.$name$);\n            }\n            node.parentNode.insertBefore(childVNode.$elm$, node);\n            node.remove();\n            if (childVNode.$depth$ === \"0\") {\n              shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n            }\n          }\n          slotNodes.push(childVNode);\n          if (!parentVNode.$children$) {\n            parentVNode.$children$ = [];\n          }\n          parentVNode.$children$[childVNode.$index$] = childVNode;\n        } else if (childNodeType === CONTENT_REF_ID) {\n          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRootNodes) {\n            node.remove();\n          } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n            hostElm[\"s-cr\"] = node;\n            node[\"s-cn\"] = true;\n          }\n        }\n      }\n    }\n  } else if (parentVNode && parentVNode.$tag$ === \"style\") {\n    const vnode = newVNode(null, node.textContent);\n    vnode.$elm$ = node;\n    vnode.$index$ = \"0\";\n    parentVNode.$children$ = [vnode];\n  }\n};\nvar initializeDocumentHydrate = (node, orgLocNodes) => {\n  if (node.nodeType === 1 /* ElementNode */) {\n    let i2 = 0;\n    for (; i2 < node.childNodes.length; i2++) {\n      initializeDocumentHydrate(node.childNodes[i2], orgLocNodes);\n    }\n    if (node.shadowRoot) {\n      for (i2 = 0; i2 < node.shadowRoot.childNodes.length; i2++) {\n        initializeDocumentHydrate(node.shadowRoot.childNodes[i2], orgLocNodes);\n      }\n    }\n  } else if (node.nodeType === 8 /* CommentNode */) {\n    const childIdSplt = node.nodeValue.split(\".\");\n    if (childIdSplt[0] === ORG_LOCATION_ID) {\n      orgLocNodes.set(childIdSplt[1] + \".\" + childIdSplt[2], node);\n      node.nodeValue = \"\";\n      node[\"s-en\"] = childIdSplt[3];\n    }\n  }\n};\n\n// src/runtime/initialize-component.ts\n\n\n// src/runtime/mode.ts\nvar computeMode = (elm) => modeResolutionChain.map((h2) => h2(elm)).find((m) => !!m);\nvar setMode = (handler) => modeResolutionChain.push(handler);\nvar getMode = (ref) => getHostRef(ref).$modeName$;\n\n// src/runtime/proxy-component.ts\n\n\n// src/runtime/set-value.ts\n\n\n// src/runtime/parse-property-value.ts\n\nvar parsePropertyValue = (propValue, propType) => {\n  if (propValue != null && !isComplexType(propValue)) {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propBoolean && propType & 4 /* Boolean */) {\n      return propValue === \"false\" ? false : propValue === \"\" || !!propValue;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propNumber && propType & 2 /* Number */) {\n      return parseFloat(propValue);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propString && propType & 1 /* String */) {\n      return String(propValue);\n    }\n    return propValue;\n  }\n  return propValue;\n};\n\n// src/runtime/update-component.ts\n\n\n// src/runtime/event-emitter.ts\n\n\n// src/runtime/element.ts\n\nvar getElement = (ref) => _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref;\n\n// src/runtime/event-emitter.ts\nvar createEvent = (ref, name, flags) => {\n  const elm = getElement(ref);\n  return {\n    emit: (detail) => {\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && !elm.isConnected) {\n        consoleDevWarn(`The \"${name}\" event was emitted, but the dispatcher node is no longer connected to the dom.`);\n      }\n      return emitEvent(elm, name, {\n        bubbles: !!(flags & 4 /* Bubbles */),\n        composed: !!(flags & 2 /* Composed */),\n        cancelable: !!(flags & 1 /* Cancellable */),\n        detail\n      });\n    }\n  };\n};\nvar emitEvent = (elm, name, opts) => {\n  const ev = plt.ce(name, opts);\n  elm.dispatchEvent(ev);\n  return ev;\n};\n\n// src/runtime/styles.ts\n\nvar rootAppliedStyles = /* @__PURE__ */ new WeakMap();\nvar registerStyle = (scopeId2, cssText, allowCS) => {\n  let style = styles.get(scopeId2);\n  if (supportsConstructableStylesheets && allowCS) {\n    style = style || new CSSStyleSheet();\n    if (typeof style === \"string\") {\n      style = cssText;\n    } else {\n      style.replaceSync(cssText);\n    }\n  } else {\n    style = cssText;\n  }\n  styles.set(scopeId2, style);\n};\nvar addStyle = (styleContainerNode, cmpMeta, mode) => {\n  var _a;\n  const scopeId2 = getScopeId(cmpMeta, mode);\n  const style = styles.get(scopeId2);\n  if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.attachStyles) {\n    return scopeId2;\n  }\n  styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;\n  if (style) {\n    if (typeof style === \"string\") {\n      styleContainerNode = styleContainerNode.head || styleContainerNode;\n      let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n      let styleElm;\n      if (!appliedStyles) {\n        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());\n      }\n      if (!appliedStyles.has(scopeId2)) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide && styleContainerNode.host && (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\"${scopeId2}\"]`))) {\n          styleElm.innerHTML = style;\n        } else {\n          styleElm = doc.createElement(\"style\");\n          styleElm.innerHTML = style;\n          const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(doc);\n          if (nonce != null) {\n            styleElm.setAttribute(\"nonce\", nonce);\n          }\n          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {\n            styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId2);\n          }\n          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector(\"link\"));\n        }\n        if (cmpMeta.$flags$ & 4 /* hasSlotRelocation */) {\n          styleElm.innerHTML += SLOT_FB_CSS;\n        }\n        if (appliedStyles) {\n          appliedStyles.add(scopeId2);\n        }\n      }\n    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\n      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n    }\n  }\n  return scopeId2;\n};\nvar attachStyles = (hostRef) => {\n  const cmpMeta = hostRef.$cmpMeta$;\n  const elm = hostRef.$hostElement$;\n  const flags = cmpMeta.$flags$;\n  const endAttachStyles = createTime(\"attachStyles\", cmpMeta.$tagName$);\n  const scopeId2 = addStyle(\n    _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(),\n    cmpMeta,\n    hostRef.$modeName$\n  );\n  if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped) && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations && flags & 10 /* needsScopedEncapsulation */) {\n    elm[\"s-sc\"] = scopeId2;\n    elm.classList.add(scopeId2 + \"-h\");\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped && flags & 2 /* scopedCssEncapsulation */) {\n      elm.classList.add(scopeId2 + \"-s\");\n    }\n  }\n  endAttachStyles();\n};\nvar getScopeId = (cmp, mode) => \"sc-\" + (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && mode && cmp.$flags$ & 32 /* hasMode */ ? cmp.$tagName$ + \"-\" + mode : cmp.$tagName$);\nvar convertScopedToShadow = (css) => css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, \"$1{\");\n\n// src/runtime/vdom/vdom-render.ts\n\n\n// src/runtime/vdom/update-element.ts\n\n\n// src/runtime/vdom/set-accessor.ts\n\nvar setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n  if (oldValue !== newValue) {\n    let isProp = isMemberInElement(elm, memberName);\n    let ln = memberName.toLowerCase();\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomClass && memberName === \"class\") {\n      const classList = elm.classList;\n      const oldClasses = parseClassList(oldValue);\n      const newClasses = parseClassList(newValue);\n      classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\n      classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\n    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomStyle && memberName === \"style\") {\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {\n        for (const prop in oldValue) {\n          if (!newValue || newValue[prop] == null) {\n            if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && prop.includes(\"-\")) {\n              elm.style.removeProperty(prop);\n            } else {\n              elm.style[prop] = \"\";\n            }\n          }\n        }\n      }\n      for (const prop in newValue) {\n        if (!oldValue || newValue[prop] !== oldValue[prop]) {\n          if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && prop.includes(\"-\")) {\n            elm.style.setProperty(prop, newValue[prop]);\n          } else {\n            elm.style[prop] = newValue[prop];\n          }\n        }\n      }\n    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && memberName === \"key\") {\n    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRef && memberName === \"ref\") {\n      if (newValue) {\n        newValue(elm);\n      }\n    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomListener && (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) && memberName[0] === \"o\" && memberName[1] === \"n\") {\n      if (memberName[2] === \"-\") {\n        memberName = memberName.slice(3);\n      } else if (isMemberInElement(win, ln)) {\n        memberName = ln.slice(2);\n      } else {\n        memberName = ln[2] + memberName.slice(3);\n      }\n      if (oldValue || newValue) {\n        const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);\n        memberName = memberName.replace(CAPTURE_EVENT_REGEX, \"\");\n        if (oldValue) {\n          plt.rel(elm, memberName, oldValue, capture);\n        }\n        if (newValue) {\n          plt.ael(elm, memberName, newValue, capture);\n        }\n      }\n    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomPropOrAttr) {\n      const isComplex = isComplexType(newValue);\n      if ((isProp || isComplex && newValue !== null) && !isSvg) {\n        try {\n          if (!elm.tagName.includes(\"-\")) {\n            const n = newValue == null ? \"\" : newValue;\n            if (memberName === \"list\") {\n              isProp = false;\n            } else if (oldValue == null || elm[memberName] != n) {\n              elm[memberName] = n;\n            }\n          } else {\n            elm[memberName] = newValue;\n          }\n        } catch (e) {\n        }\n      }\n      let xlink = false;\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink) {\n        if (ln !== (ln = ln.replace(/^xlink\\:?/, \"\"))) {\n          memberName = ln;\n          xlink = true;\n        }\n      }\n      if (newValue == null || newValue === false) {\n        if (newValue !== false || elm.getAttribute(memberName) === \"\") {\n          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink && xlink) {\n            elm.removeAttributeNS(XLINK_NS, memberName);\n          } else {\n            elm.removeAttribute(memberName);\n          }\n        }\n      } else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {\n        newValue = newValue === true ? \"\" : newValue;\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink && xlink) {\n          elm.setAttributeNS(XLINK_NS, memberName, newValue);\n        } else {\n          elm.setAttribute(memberName, newValue);\n        }\n      }\n    }\n  }\n};\nvar parseClassListRegex = /\\s/;\nvar parseClassList = (value) => !value ? [] : value.split(parseClassListRegex);\nvar CAPTURE_EVENT_SUFFIX = \"Capture\";\nvar CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + \"$\");\n\n// src/runtime/vdom/update-element.ts\nvar updateElement = (oldVnode, newVnode, isSvgMode2) => {\n  const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;\n  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {\n    for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {\n      if (!(memberName in newVnodeAttrs)) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);\n      }\n    }\n  }\n  for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {\n    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);\n  }\n};\nfunction sortedAttrNames(attrNames) {\n  return attrNames.includes(\"ref\") ? (\n    // we need to sort these to ensure that `'ref'` is the last attr\n    [...attrNames.filter((attr) => attr !== \"ref\"), \"ref\"]\n  ) : (\n    // no need to sort, return the original array\n    attrNames\n  );\n}\n\n// src/runtime/vdom/vdom-render.ts\nvar scopeId;\nvar contentRef;\nvar hostTagName;\nvar useNativeShadowDom = false;\nvar checkSlotFallbackVisibility = false;\nvar checkSlotRelocate = false;\nvar isSvgMode = false;\nvar createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n  var _a;\n  const newVNode2 = newParentVNode.$children$[childIndex];\n  let i2 = 0;\n  let elm;\n  let childNode;\n  let oldVNode;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && !useNativeShadowDom) {\n    checkSlotRelocate = true;\n    if (newVNode2.$tag$ === \"slot\") {\n      if (scopeId) {\n        parentElm.classList.add(scopeId + \"-s\");\n      }\n      newVNode2.$flags$ |= newVNode2.$children$ ? (\n        // slot element has fallback content\n        // still create an element that \"mocks\" the slot element\n        2 /* isSlotFallback */\n      ) : (\n        // slot element does not have fallback content\n        // create an html comment we'll use to always reference\n        // where actual slot content should sit next to\n        1 /* isSlotReference */\n      );\n    }\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && newVNode2.$elm$) {\n    consoleDevError(\n      `The JSX ${newVNode2.$text$ !== null ? `\"${newVNode2.$text$}\" text` : `\"${newVNode2.$tag$}\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`\n    );\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && newVNode2.$text$ !== null) {\n    elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);\n  } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode2.$flags$ & 1 /* isSlotReference */) {\n    elm = newVNode2.$elm$ = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode2) : doc.createTextNode(\"\");\n  } else {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && !isSvgMode) {\n      isSvgMode = newVNode2.$tag$ === \"svg\";\n    }\n    elm = newVNode2.$elm$ = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg ? doc.createElementNS(\n      isSvgMode ? SVG_NS : HTML_NS,\n      !useNativeShadowDom && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode2.$flags$ & 2 /* isSlotFallback */ ? \"slot-fb\" : newVNode2.$tag$\n    ) : doc.createElement(\n      !useNativeShadowDom && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode2.$flags$ & 2 /* isSlotFallback */ ? \"slot-fb\" : newVNode2.$tag$\n    );\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && isSvgMode && newVNode2.$tag$ === \"foreignObject\") {\n      isSvgMode = false;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute) {\n      updateElement(null, newVNode2, isSvgMode);\n    }\n    if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped) && isDef(scopeId) && elm[\"s-si\"] !== scopeId) {\n      elm.classList.add(elm[\"s-si\"] = scopeId);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped) {\n      updateElementScopeIds(elm, parentElm);\n    }\n    if (newVNode2.$children$) {\n      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {\n        childNode = createElm(oldParentVNode, newVNode2, i2, elm);\n        if (childNode) {\n          elm.appendChild(childNode);\n        }\n      }\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg) {\n      if (newVNode2.$tag$ === \"svg\") {\n        isSvgMode = false;\n      } else if (elm.tagName === \"foreignObject\") {\n        isSvgMode = true;\n      }\n    }\n  }\n  elm[\"s-hn\"] = hostTagName;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n    if (newVNode2.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {\n      elm[\"s-sr\"] = true;\n      elm[\"s-cr\"] = contentRef;\n      elm[\"s-sn\"] = newVNode2.$name$ || \"\";\n      elm[\"s-rf\"] = (_a = newVNode2.$attrs$) == null ? void 0 : _a.ref;\n      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.experimentalSlotFixes) {\n          relocateToHostRoot(oldParentVNode.$elm$);\n        } else {\n          putBackInOriginalLocation(oldParentVNode.$elm$, false);\n        }\n      }\n    }\n  }\n  return elm;\n};\nvar relocateToHostRoot = (parentElm) => {\n  plt.$flags$ |= 1 /* isTmpDisconnected */;\n  const host = parentElm.closest(hostTagName.toLowerCase());\n  if (host != null) {\n    const contentRefNode = Array.from(host.childNodes).find((ref) => ref[\"s-cr\"]);\n    const childNodeArray = Array.from(parentElm.childNodes);\n    for (const childNode of contentRefNode ? childNodeArray.reverse() : childNodeArray) {\n      if (childNode[\"s-sh\"] != null) {\n        insertBefore(host, childNode, contentRefNode != null ? contentRefNode : null);\n        childNode[\"s-sh\"] = void 0;\n        checkSlotRelocate = true;\n      }\n    }\n  }\n  plt.$flags$ &= ~1 /* isTmpDisconnected */;\n};\nvar putBackInOriginalLocation = (parentElm, recursive) => {\n  plt.$flags$ |= 1 /* isTmpDisconnected */;\n  const oldSlotChildNodes = Array.from(parentElm.childNodes);\n  if (parentElm[\"s-sr\"] && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.experimentalSlotFixes) {\n    let node = parentElm;\n    while (node = node.nextSibling) {\n      if (node && node[\"s-sn\"] === parentElm[\"s-sn\"] && node[\"s-sh\"] === hostTagName) {\n        oldSlotChildNodes.push(node);\n      }\n    }\n  }\n  for (let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {\n    const childNode = oldSlotChildNodes[i2];\n    if (childNode[\"s-hn\"] !== hostTagName && childNode[\"s-ol\"]) {\n      insertBefore(parentReferenceNode(childNode), childNode, referenceNode(childNode));\n      childNode[\"s-ol\"].remove();\n      childNode[\"s-ol\"] = void 0;\n      childNode[\"s-sh\"] = void 0;\n      checkSlotRelocate = true;\n    }\n    if (recursive) {\n      putBackInOriginalLocation(childNode, recursive);\n    }\n  }\n  plt.$flags$ &= ~1 /* isTmpDisconnected */;\n};\nvar addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n  let containerElm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && parentElm[\"s-cr\"] && parentElm[\"s-cr\"].parentNode || parentElm;\n  let childNode;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n    containerElm = containerElm.shadowRoot;\n  }\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnodes[startIdx]) {\n      childNode = createElm(null, parentVNode, startIdx, parentElm);\n      if (childNode) {\n        vnodes[startIdx].$elm$ = childNode;\n        insertBefore(containerElm, childNode, _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation ? referenceNode(before) : before);\n      }\n    }\n  }\n};\nvar removeVnodes = (vnodes, startIdx, endIdx) => {\n  for (let index = startIdx; index <= endIdx; ++index) {\n    const vnode = vnodes[index];\n    if (vnode) {\n      const elm = vnode.$elm$;\n      nullifyVNodeRefs(vnode);\n      if (elm) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n          checkSlotFallbackVisibility = true;\n          if (elm[\"s-ol\"]) {\n            elm[\"s-ol\"].remove();\n          } else {\n            putBackInOriginalLocation(elm, true);\n          }\n        }\n        elm.remove();\n      }\n    }\n  }\n};\nvar updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {\n  let oldStartIdx = 0;\n  let newStartIdx = 0;\n  let idxInOld = 0;\n  let i2 = 0;\n  let oldEndIdx = oldCh.length - 1;\n  let oldStartVnode = oldCh[0];\n  let oldEndVnode = oldCh[oldEndIdx];\n  let newEndIdx = newCh.length - 1;\n  let newStartVnode = newCh[0];\n  let newEndVnode = newCh[newEndIdx];\n  let node;\n  let elmToMove;\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {\n      patch(oldStartVnode, newStartVnode, isInitialRender);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {\n      patch(oldEndVnode, newEndVnode, isInitialRender);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (oldStartVnode.$tag$ === \"slot\" || newEndVnode.$tag$ === \"slot\")) {\n        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n      }\n      patch(oldStartVnode, newEndVnode, isInitialRender);\n      insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (oldStartVnode.$tag$ === \"slot\" || newEndVnode.$tag$ === \"slot\")) {\n        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n      }\n      patch(oldEndVnode, newStartVnode, isInitialRender);\n      insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      idxInOld = -1;\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {\n        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {\n          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {\n            idxInOld = i2;\n            break;\n          }\n        }\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && idxInOld >= 0) {\n        elmToMove = oldCh[idxInOld];\n        if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);\n        } else {\n          patch(elmToMove, newStartVnode, isInitialRender);\n          oldCh[idxInOld] = void 0;\n          node = elmToMove.$elm$;\n        }\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);\n        newStartVnode = newCh[++newStartIdx];\n      }\n      if (node) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n          insertBefore(parentReferenceNode(oldStartVnode.$elm$), node, referenceNode(oldStartVnode.$elm$));\n        } else {\n          insertBefore(oldStartVnode.$elm$.parentNode, node, oldStartVnode.$elm$);\n        }\n      }\n    }\n  }\n  if (oldStartIdx > oldEndIdx) {\n    addVnodes(\n      parentElm,\n      newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$,\n      newVNode2,\n      newCh,\n      newStartIdx,\n      newEndIdx\n    );\n  } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && newStartIdx > newEndIdx) {\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n  }\n};\nvar isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {\n  if (leftVNode.$tag$ === rightVNode.$tag$) {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && leftVNode.$tag$ === \"slot\") {\n      return leftVNode.$name$ === rightVNode.$name$;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && !isInitialRender) {\n      return leftVNode.$key$ === rightVNode.$key$;\n    }\n    return true;\n  }\n  return false;\n};\nvar referenceNode = (node) => {\n  return node && node[\"s-ol\"] || node;\n};\nvar parentReferenceNode = (node) => (node[\"s-ol\"] ? node[\"s-ol\"] : node).parentNode;\nvar patch = (oldVNode, newVNode2, isInitialRender = false) => {\n  const elm = newVNode2.$elm$ = oldVNode.$elm$;\n  const oldChildren = oldVNode.$children$;\n  const newChildren = newVNode2.$children$;\n  const tag = newVNode2.$tag$;\n  const text = newVNode2.$text$;\n  let defaultHolder;\n  if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText || text === null) {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg) {\n      isSvgMode = tag === \"svg\" ? true : tag === \"foreignObject\" ? false : isSvgMode;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot && tag === \"slot\" && !useNativeShadowDom) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.experimentalSlotFixes && oldVNode.$name$ !== newVNode2.$name$) {\n          newVNode2.$elm$[\"s-sn\"] = newVNode2.$name$ || \"\";\n          relocateToHostRoot(newVNode2.$elm$.parentElement);\n        }\n      } else {\n        updateElement(oldVNode, newVNode2, isSvgMode);\n      }\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && oldChildren !== null && newChildren !== null) {\n      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);\n    } else if (newChildren !== null) {\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && oldVNode.$text$ !== null) {\n        elm.textContent = \"\";\n      }\n      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);\n    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && oldChildren !== null) {\n      removeVnodes(oldChildren, 0, oldChildren.length - 1);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && isSvgMode && tag === \"svg\") {\n      isSvgMode = false;\n    }\n  } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (defaultHolder = elm[\"s-cr\"])) {\n    defaultHolder.parentNode.textContent = text;\n  } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && oldVNode.$text$ !== text) {\n    elm.data = text;\n  }\n};\nvar updateFallbackSlotVisibility = (elm) => {\n  const childNodes = elm.childNodes;\n  for (const childNode of childNodes) {\n    if (childNode.nodeType === 1 /* ElementNode */) {\n      if (childNode[\"s-sr\"]) {\n        const slotName = childNode[\"s-sn\"];\n        childNode.hidden = false;\n        for (const siblingNode of childNodes) {\n          if (siblingNode !== childNode) {\n            if (siblingNode[\"s-hn\"] !== childNode[\"s-hn\"] || slotName !== \"\") {\n              if (siblingNode.nodeType === 1 /* ElementNode */ && (slotName === siblingNode.getAttribute(\"slot\") || slotName === siblingNode[\"s-sn\"]) || siblingNode.nodeType === 3 /* TextNode */ && slotName === siblingNode[\"s-sn\"]) {\n                childNode.hidden = true;\n                break;\n              }\n            } else {\n              if (siblingNode.nodeType === 1 /* ElementNode */ || siblingNode.nodeType === 3 /* TextNode */ && siblingNode.textContent.trim() !== \"\") {\n                childNode.hidden = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n      updateFallbackSlotVisibility(childNode);\n    }\n  }\n};\nvar relocateNodes = [];\nvar markSlotContentForRelocation = (elm) => {\n  let node;\n  let hostContentNodes;\n  let j;\n  for (const childNode of elm.childNodes) {\n    if (childNode[\"s-sr\"] && (node = childNode[\"s-cr\"]) && node.parentNode) {\n      hostContentNodes = node.parentNode.childNodes;\n      const slotName = childNode[\"s-sn\"];\n      for (j = hostContentNodes.length - 1; j >= 0; j--) {\n        node = hostContentNodes[j];\n        if (!node[\"s-cn\"] && !node[\"s-nr\"] && node[\"s-hn\"] !== childNode[\"s-hn\"] && (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.experimentalSlotFixes || !node[\"s-sh\"] || node[\"s-sh\"] !== childNode[\"s-hn\"])) {\n          if (isNodeLocatedInSlot(node, slotName)) {\n            let relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n            checkSlotFallbackVisibility = true;\n            node[\"s-sn\"] = node[\"s-sn\"] || slotName;\n            if (relocateNodeData) {\n              relocateNodeData.$nodeToRelocate$[\"s-sh\"] = childNode[\"s-hn\"];\n              relocateNodeData.$slotRefNode$ = childNode;\n            } else {\n              node[\"s-sh\"] = childNode[\"s-hn\"];\n              relocateNodes.push({\n                $slotRefNode$: childNode,\n                $nodeToRelocate$: node\n              });\n            }\n            if (node[\"s-sr\"]) {\n              relocateNodes.map((relocateNode) => {\n                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node[\"s-sn\"])) {\n                  relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                  if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                  }\n                }\n              });\n            }\n          } else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {\n            relocateNodes.push({\n              $nodeToRelocate$: node\n            });\n          }\n        }\n      }\n    }\n    if (childNode.nodeType === 1 /* ElementNode */) {\n      markSlotContentForRelocation(childNode);\n    }\n  }\n};\nvar isNodeLocatedInSlot = (nodeToRelocate, slotName) => {\n  if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n    if (nodeToRelocate.getAttribute(\"slot\") === null && slotName === \"\") {\n      return true;\n    }\n    if (nodeToRelocate.getAttribute(\"slot\") === slotName) {\n      return true;\n    }\n    return false;\n  }\n  if (nodeToRelocate[\"s-sn\"] === slotName) {\n    return true;\n  }\n  return slotName === \"\";\n};\nvar nullifyVNodeRefs = (vNode) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRef) {\n    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);\n  }\n};\nvar insertBefore = (parent, newNode, reference) => {\n  const inserted = parent == null ? void 0 : parent.insertBefore(newNode, reference);\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped) {\n    updateElementScopeIds(newNode, parent);\n  }\n  return inserted;\n};\nvar findScopeIds = (element) => {\n  const scopeIds = [];\n  if (element) {\n    scopeIds.push(\n      ...element[\"s-scs\"] || [],\n      element[\"s-si\"],\n      element[\"s-sc\"],\n      ...findScopeIds(element.parentElement)\n    );\n  }\n  return scopeIds;\n};\nvar updateElementScopeIds = (element, parent, iterateChildNodes = false) => {\n  var _a;\n  if (element && parent && element.nodeType === 1 /* ElementNode */) {\n    const scopeIds = new Set(findScopeIds(parent).filter(Boolean));\n    if (scopeIds.size) {\n      (_a = element.classList) == null ? void 0 : _a.add(...element[\"s-scs\"] = [...scopeIds]);\n      if (element[\"s-ol\"] || iterateChildNodes) {\n        for (const childNode of Array.from(element.childNodes)) {\n          updateElementScopeIds(childNode, element, true);\n        }\n      }\n    }\n  }\n};\nvar renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {\n  var _a, _b, _c, _d, _e;\n  const hostElm = hostRef.$hostElement$;\n  const cmpMeta = hostRef.$cmpMeta$;\n  const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n  const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n  hostTagName = hostElm.tagName;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\n    throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of \"${hostTagName.toLowerCase()}\" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect && cmpMeta.$attrsToReflect$) {\n    rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n    cmpMeta.$attrsToReflect$.map(\n      ([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]\n    );\n  }\n  if (isInitialLoad && rootVnode.$attrs$) {\n    for (const key of Object.keys(rootVnode.$attrs$)) {\n      if (hostElm.hasAttribute(key) && ![\"key\", \"ref\", \"style\", \"class\"].includes(key)) {\n        rootVnode.$attrs$[key] = hostElm[key];\n      }\n    }\n  }\n  rootVnode.$tag$ = null;\n  rootVnode.$flags$ |= 4 /* isHost */;\n  hostRef.$vnode$ = rootVnode;\n  rootVnode.$elm$ = oldVNode.$elm$ = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) {\n    scopeId = hostElm[\"s-sc\"];\n  }\n  useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n    contentRef = hostElm[\"s-cr\"];\n    checkSlotFallbackVisibility = false;\n  }\n  patch(oldVNode, rootVnode, isInitialLoad);\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n    plt.$flags$ |= 1 /* isTmpDisconnected */;\n    if (checkSlotRelocate) {\n      markSlotContentForRelocation(rootVnode.$elm$);\n      for (const relocateData of relocateNodes) {\n        const nodeToRelocate = relocateData.$nodeToRelocate$;\n        if (!nodeToRelocate[\"s-ol\"]) {\n          const orgLocationNode = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? originalLocationDebugNode(nodeToRelocate) : doc.createTextNode(\"\");\n          orgLocationNode[\"s-nr\"] = nodeToRelocate;\n          insertBefore(nodeToRelocate.parentNode, nodeToRelocate[\"s-ol\"] = orgLocationNode, nodeToRelocate);\n        }\n      }\n      for (const relocateData of relocateNodes) {\n        const nodeToRelocate = relocateData.$nodeToRelocate$;\n        const slotRefNode = relocateData.$slotRefNode$;\n        if (slotRefNode) {\n          const parentNodeRef = slotRefNode.parentNode;\n          let insertBeforeNode = slotRefNode.nextSibling;\n          if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.experimentalSlotFixes || insertBeforeNode && insertBeforeNode.nodeType === 1 /* ElementNode */) {\n            let orgLocationNode = (_a = nodeToRelocate[\"s-ol\"]) == null ? void 0 : _a.previousSibling;\n            while (orgLocationNode) {\n              let refNode = (_b = orgLocationNode[\"s-nr\"]) != null ? _b : null;\n              if (refNode && refNode[\"s-sn\"] === nodeToRelocate[\"s-sn\"] && parentNodeRef === refNode.parentNode) {\n                refNode = refNode.nextSibling;\n                while (refNode === nodeToRelocate || (refNode == null ? void 0 : refNode[\"s-sr\"])) {\n                  refNode = refNode == null ? void 0 : refNode.nextSibling;\n                }\n                if (!refNode || !refNode[\"s-nr\"]) {\n                  insertBeforeNode = refNode;\n                  break;\n                }\n              }\n              orgLocationNode = orgLocationNode.previousSibling;\n            }\n          }\n          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {\n            if (nodeToRelocate !== insertBeforeNode) {\n              if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.experimentalSlotFixes && !nodeToRelocate[\"s-hn\"] && nodeToRelocate[\"s-ol\"]) {\n                nodeToRelocate[\"s-hn\"] = nodeToRelocate[\"s-ol\"].parentNode.nodeName;\n              }\n              insertBefore(parentNodeRef, nodeToRelocate, insertBeforeNode);\n              if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n                nodeToRelocate.hidden = (_c = nodeToRelocate[\"s-ih\"]) != null ? _c : false;\n              }\n            }\n          }\n          nodeToRelocate && typeof slotRefNode[\"s-rf\"] === \"function\" && slotRefNode[\"s-rf\"](nodeToRelocate);\n        } else {\n          if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n            if (isInitialLoad) {\n              nodeToRelocate[\"s-ih\"] = (_d = nodeToRelocate.hidden) != null ? _d : false;\n            }\n            nodeToRelocate.hidden = true;\n          }\n        }\n      }\n    }\n    if (checkSlotFallbackVisibility) {\n      updateFallbackSlotVisibility(rootVnode.$elm$);\n    }\n    plt.$flags$ &= ~1 /* isTmpDisconnected */;\n    relocateNodes.length = 0;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.experimentalScopedSlotChanges && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n    for (const childNode of rootVnode.$elm$.childNodes) {\n      if (childNode[\"s-hn\"] !== hostTagName && !childNode[\"s-sh\"]) {\n        if (isInitialLoad && childNode[\"s-ih\"] == null) {\n          childNode[\"s-ih\"] = (_e = childNode.hidden) != null ? _e : false;\n        }\n        childNode.hidden = true;\n      }\n    }\n  }\n  contentRef = void 0;\n};\nvar slotReferenceDebugNode = (slotVNode) => doc.createComment(\n  `<slot${slotVNode.$name$ ? ' name=\"' + slotVNode.$name$ + '\"' : \"\"}> (host=${hostTagName.toLowerCase()})`\n);\nvar originalLocationDebugNode = (nodeToRelocate) => doc.createComment(\n  `org-location for ` + (nodeToRelocate.localName ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate[\"s-hn\"]})` : `[${nodeToRelocate.textContent}]`)\n);\n\n// src/runtime/update-component.ts\nvar attachToAncestor = (hostRef, ancestorComponent) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent[\"s-p\"]) {\n    ancestorComponent[\"s-p\"].push(new Promise((r) => hostRef.$onRenderResolve$ = r));\n  }\n};\nvar scheduleUpdate = (hostRef, isInitialLoad) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {\n    hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n    hostRef.$flags$ |= 512 /* needsRerender */;\n    return;\n  }\n  attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n  return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue ? writeTask(dispatch) : dispatch();\n};\nvar dispatchHooks = (hostRef, isInitialLoad) => {\n  const elm = hostRef.$hostElement$;\n  const endSchedule = createTime(\"scheduleUpdate\", hostRef.$cmpMeta$.$tagName$);\n  const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n  if (!instance) {\n    throw new Error(\n      `Can't render component <${elm.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \\`externalRuntime: true\\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`\n    );\n  }\n  let maybePromise;\n  if (isInitialLoad) {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {\n      hostRef.$flags$ |= 256 /* isListenReady */;\n      if (hostRef.$queuedListeners$) {\n        hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));\n        hostRef.$queuedListeners$ = void 0;\n      }\n    }\n    emitLifecycleEvent(elm, \"componentWillLoad\");\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillLoad) {\n      maybePromise = safeCall(instance, \"componentWillLoad\");\n    }\n  } else {\n    emitLifecycleEvent(elm, \"componentWillUpdate\");\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillUpdate) {\n      maybePromise = safeCall(instance, \"componentWillUpdate\");\n    }\n  }\n  emitLifecycleEvent(elm, \"componentWillRender\");\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillRender) {\n    maybePromise = enqueue(maybePromise, () => safeCall(instance, \"componentWillRender\"));\n  }\n  endSchedule();\n  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nvar enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn).catch((err2) => {\n  console.error(err2);\n  fn();\n}) : fn();\nvar isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === \"function\";\nvar updateComponent = async (hostRef, instance, isInitialLoad) => {\n  var _a;\n  const elm = hostRef.$hostElement$;\n  const endUpdate = createTime(\"update\", hostRef.$cmpMeta$.$tagName$);\n  const rc = elm[\"s-rc\"];\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && isInitialLoad) {\n    attachStyles(hostRef);\n  }\n  const endRender = createTime(\"render\", hostRef.$cmpMeta$.$tagName$);\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n    hostRef.$flags$ |= 1024 /* devOnRender */;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {\n    await callRender(hostRef, instance, elm, isInitialLoad);\n  } else {\n    callRender(hostRef, instance, elm, isInitialLoad);\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n    hostRef.$renderCount$ = hostRef.$renderCount$ === void 0 ? 1 : hostRef.$renderCount$ + 1;\n    hostRef.$flags$ &= ~1024 /* devOnRender */;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {\n    try {\n      serverSideConnected(elm);\n      if (isInitialLoad) {\n        if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {\n          elm[\"s-en\"] = \"\";\n        } else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */) {\n          elm[\"s-en\"] = \"c\";\n        }\n      }\n    } catch (e) {\n      consoleError(e, elm);\n    }\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && rc) {\n    rc.map((cb) => cb());\n    elm[\"s-rc\"] = void 0;\n  }\n  endRender();\n  endUpdate();\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {\n    const childrenPromises = (_a = elm[\"s-p\"]) != null ? _a : [];\n    const postUpdate = () => postUpdateComponent(hostRef);\n    if (childrenPromises.length === 0) {\n      postUpdate();\n    } else {\n      Promise.all(childrenPromises).then(postUpdate);\n      hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n      childrenPromises.length = 0;\n    }\n  } else {\n    postUpdateComponent(hostRef);\n  }\n};\nvar renderingRef = null;\nvar callRender = (hostRef, instance, elm, isInitialLoad) => {\n  const allRenderFn = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.allRenderFn ? true : false;\n  const lazyLoad = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? true : false;\n  const taskQueue = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue ? true : false;\n  const updatable = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable ? true : false;\n  try {\n    renderingRef = instance;\n    instance = allRenderFn ? instance.render() : instance.render && instance.render();\n    if (updatable && taskQueue) {\n      hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n    }\n    if (updatable || lazyLoad) {\n      hostRef.$flags$ |= 2 /* hasRendered */;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hasRenderFn || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRender || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {\n          return Promise.resolve(instance).then((value) => renderVdom(hostRef, value, isInitialLoad));\n        } else {\n          renderVdom(hostRef, instance, isInitialLoad);\n        }\n      } else {\n        const shadowRoot = elm.shadowRoot;\n        if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {\n          shadowRoot.textContent = instance;\n        } else {\n          elm.textContent = instance;\n        }\n      }\n    }\n  } catch (e) {\n    consoleError(e, hostRef.$hostElement$);\n  }\n  renderingRef = null;\n  return null;\n};\nvar getRenderingRef = () => renderingRef;\nvar postUpdateComponent = (hostRef) => {\n  const tagName = hostRef.$cmpMeta$.$tagName$;\n  const elm = hostRef.$hostElement$;\n  const endPostUpdate = createTime(\"postUpdate\", tagName);\n  const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidRender) {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n      hostRef.$flags$ |= 1024 /* devOnRender */;\n    }\n    safeCall(instance, \"componentDidRender\");\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n      hostRef.$flags$ &= ~1024 /* devOnRender */;\n    }\n  }\n  emitLifecycleEvent(elm, \"componentDidRender\");\n  if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n    hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations) {\n      addHydratedFlag(elm);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidLoad) {\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n        hostRef.$flags$ |= 2048 /* devOnDidLoad */;\n      }\n      safeCall(instance, \"componentDidLoad\");\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n        hostRef.$flags$ &= ~2048 /* devOnDidLoad */;\n      }\n    }\n    emitLifecycleEvent(elm, \"componentDidLoad\");\n    endPostUpdate();\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {\n      hostRef.$onReadyResolve$(elm);\n      if (!ancestorComponent) {\n        appDidLoad(tagName);\n      }\n    }\n  } else {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidUpdate) {\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n        hostRef.$flags$ |= 1024 /* devOnRender */;\n      }\n      safeCall(instance, \"componentDidUpdate\");\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n        hostRef.$flags$ &= ~1024 /* devOnRender */;\n      }\n    }\n    emitLifecycleEvent(elm, \"componentDidUpdate\");\n    endPostUpdate();\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {\n    hostRef.$onInstanceResolve$(elm);\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {\n    if (hostRef.$onRenderResolve$) {\n      hostRef.$onRenderResolve$();\n      hostRef.$onRenderResolve$ = void 0;\n    }\n    if (hostRef.$flags$ & 512 /* needsRerender */) {\n      nextTick(() => scheduleUpdate(hostRef, false));\n    }\n    hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n  }\n};\nvar forceUpdate = (ref) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && (Build.isBrowser || Build.isTesting)) {\n    const hostRef = getHostRef(ref);\n    const isConnected = hostRef.$hostElement$.isConnected;\n    if (isConnected && (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n      scheduleUpdate(hostRef, false);\n    }\n    return isConnected;\n  }\n  return false;\n};\nvar appDidLoad = (who) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations) {\n    addHydratedFlag(doc.documentElement);\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {\n    plt.$flags$ |= 2 /* appLoaded */;\n  }\n  nextTick(() => emitEvent(win, \"appload\", { detail: { namespace: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE } }));\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.measure) {\n    performance.measure(`[Stencil] ${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE} initial load (by ${who})`, \"st:app:start\");\n  }\n};\nvar safeCall = (instance, method, arg) => {\n  if (instance && instance[method]) {\n    try {\n      return instance[method](arg);\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  return void 0;\n};\nvar emitLifecycleEvent = (elm, lifecycleName) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lifecycleDOMEvents) {\n    emitEvent(elm, \"stencil_\" + lifecycleName, {\n      bubbles: true,\n      composed: true,\n      detail: {\n        namespace: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE\n      }\n    });\n  }\n};\nvar addHydratedFlag = (elm) => {\n  var _a, _b;\n  return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedClass ? elm.classList.add((_a = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedSelectorName) != null ? _a : \"hydrated\") : _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedAttribute ? elm.setAttribute((_b = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedSelectorName) != null ? _b : \"hydrated\", \"\") : void 0;\n};\nvar serverSideConnected = (elm) => {\n  const children = elm.children;\n  if (children != null) {\n    for (let i2 = 0, ii = children.length; i2 < ii; i2++) {\n      const childElm = children[i2];\n      if (typeof childElm.connectedCallback === \"function\") {\n        childElm.connectedCallback();\n      }\n      serverSideConnected(childElm);\n    }\n  }\n};\n\n// src/runtime/set-value.ts\nvar getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nvar setValue = (ref, propName, newVal, cmpMeta) => {\n  const hostRef = getHostRef(ref);\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && !hostRef) {\n    throw new Error(\n      `Couldn't find host element for \"${cmpMeta.$tagName$}\" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`\n    );\n  }\n  const elm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$hostElement$ : ref;\n  const oldVal = hostRef.$instanceValues$.get(propName);\n  const flags = hostRef.$flags$;\n  const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n  const didValueChange = newVal !== oldVal && !areBothNaN;\n  if ((!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || !(flags & 8 /* isConstructingInstance */) || oldVal === void 0) && didValueChange) {\n    hostRef.$instanceValues$.set(propName, newVal);\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n      if (hostRef.$flags$ & 1024 /* devOnRender */) {\n        consoleDevWarn(\n          `The state/prop \"${propName}\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,\n          \"\\nElement\",\n          elm,\n          \"\\nNew value\",\n          newVal,\n          \"\\nOld value\",\n          oldVal\n        );\n      } else if (hostRef.$flags$ & 2048 /* devOnDidLoad */) {\n        consoleDevWarn(\n          `The state/prop \"${propName}\" changed during \"componentDidLoad()\", this triggers extra re-renders, try to setup on \"componentWillLoad()\"`,\n          \"\\nElement\",\n          elm,\n          \"\\nNew value\",\n          newVal,\n          \"\\nOld value\",\n          oldVal\n        );\n      }\n    }\n    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || instance) {\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n        const watchMethods = cmpMeta.$watchers$[propName];\n        if (watchMethods) {\n          watchMethods.map((watchMethodName) => {\n            try {\n              instance[watchMethodName](newVal, oldVal, propName);\n            } catch (e) {\n              consoleError(e, elm);\n            }\n          });\n        }\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && (flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {\n          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n            return;\n          }\n        }\n        scheduleUpdate(hostRef, false);\n      }\n    }\n  }\n};\n\n// src/runtime/proxy-component.ts\nvar proxyComponent = (Cstr, cmpMeta, flags) => {\n  var _a, _b;\n  const prototype = Cstr.prototype;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.formAssociated && cmpMeta.$flags$ & 64 /* formAssociated */ && flags & 1 /* isElementConstructor */) {\n    FORM_ASSOCIATED_CUSTOM_ELEMENT_CALLBACKS.forEach(\n      (cbName) => Object.defineProperty(prototype, cbName, {\n        value(...args) {\n          const hostRef = getHostRef(this);\n          const elm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$hostElement$ : this;\n          const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n          if (!instance) {\n            hostRef.$onReadyPromise$.then((instance2) => {\n              const cb = instance2[cbName];\n              typeof cb === \"function\" && cb.call(instance2, ...args);\n            });\n          } else {\n            const cb = instance[cbName];\n            typeof cb === \"function\" && cb.call(instance, ...args);\n          }\n        }\n      })\n    );\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member && cmpMeta.$members$ || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback && (cmpMeta.$watchers$ || Cstr.watchers)) {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback && Cstr.watchers && !cmpMeta.$watchers$) {\n      cmpMeta.$watchers$ = Cstr.watchers;\n    }\n    const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});\n    members.map(([memberName, [memberFlags]]) => {\n      if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.prop || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.state) && (memberFlags & 31 /* Prop */ || (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || flags & 2 /* proxyState */) && memberFlags & 32 /* State */)) {\n        Object.defineProperty(prototype, memberName, {\n          get() {\n            return getValue(this, memberName);\n          },\n          set(newValue) {\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n              const ref = getHostRef(this);\n              if (\n                // we are proxying the instance (not element)\n                (flags & 1 /* isElementConstructor */) === 0 && // the element is not constructing\n                (ref && ref.$flags$ & 8 /* isConstructingInstance */) === 0 && // the member is a prop\n                (memberFlags & 31 /* Prop */) !== 0 && // the member is not mutable\n                (memberFlags & 1024 /* Mutable */) === 0\n              ) {\n                consoleDevWarn(\n                  `@Prop() \"${memberName}\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\nMore information: https://stenciljs.com/docs/properties#prop-mutability`\n                );\n              }\n            }\n            setValue(this, memberName, newValue, cmpMeta);\n          },\n          configurable: true,\n          enumerable: true\n        });\n      } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method && flags & 1 /* isElementConstructor */ && memberFlags & 64 /* Method */) {\n        Object.defineProperty(prototype, memberName, {\n          value(...args) {\n            var _a2;\n            const ref = getHostRef(this);\n            return (_a2 = ref == null ? void 0 : ref.$onInstancePromise$) == null ? void 0 : _a2.then(() => {\n              var _a3;\n              return (_a3 = ref.$lazyInstance$) == null ? void 0 : _a3[memberName](...args);\n            });\n          }\n        });\n      }\n    });\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.observeAttribute && (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || flags & 1 /* isElementConstructor */)) {\n      const attrNameToPropName = /* @__PURE__ */ new Map();\n      prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {\n        plt.jmp(() => {\n          var _a2;\n          const propName = attrNameToPropName.get(attrName);\n          if (this.hasOwnProperty(propName)) {\n            newValue = this[propName];\n            delete this[propName];\n          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === \"number\" && this[propName] == newValue) {\n            return;\n          } else if (propName == null) {\n            const hostRef = getHostRef(this);\n            const flags2 = hostRef == null ? void 0 : hostRef.$flags$;\n            if (flags2 && !(flags2 & 8 /* isConstructingInstance */) && flags2 & 128 /* isWatchReady */ && newValue !== oldValue) {\n              const elm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$hostElement$ : this;\n              const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n              const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];\n              entry == null ? void 0 : entry.forEach((callbackName) => {\n                if (instance[callbackName] != null) {\n                  instance[callbackName].call(instance, newValue, oldValue, attrName);\n                }\n              });\n            }\n            return;\n          }\n          this[propName] = newValue === null && typeof this[propName] === \"boolean\" ? false : newValue;\n        });\n      };\n      Cstr.observedAttributes = Array.from(\n        /* @__PURE__ */ new Set([\n          ...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}),\n          ...members.filter(([_, m]) => m[0] & 15 /* HasAttribute */).map(([propName, m]) => {\n            var _a2;\n            const attrName = m[1] || propName;\n            attrNameToPropName.set(attrName, propName);\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect && m[0] & 512 /* ReflectAttr */) {\n              (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);\n            }\n            return attrName;\n          })\n        ])\n      );\n    }\n  }\n  return Cstr;\n};\n\n// src/runtime/initialize-component.ts\nvar initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {\n  let Cstr;\n  if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n    hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n    const bundleId = cmpMeta.$lazyBundleId$;\n    if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) && bundleId) {\n      const CstrImport = loadModule(cmpMeta, hostRef, hmrVersionId);\n      if (CstrImport && \"then\" in CstrImport) {\n        const endLoad = uniqueTime(\n          `st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`,\n          `[Stencil] Load module for <${cmpMeta.$tagName$}>`\n        );\n        Cstr = await CstrImport;\n        endLoad();\n      } else {\n        Cstr = CstrImport;\n      }\n      if (!Cstr) {\n        throw new Error(`Constructor for \"${cmpMeta.$tagName$}#${hostRef.$modeName$}\" was not found`);\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member && !Cstr.isProxied) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {\n          cmpMeta.$watchers$ = Cstr.watchers;\n        }\n        proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n        Cstr.isProxied = true;\n      }\n      const endNewInstance = createTime(\"createInstance\", cmpMeta.$tagName$);\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {\n        hostRef.$flags$ |= 8 /* isConstructingInstance */;\n      }\n      try {\n        new Cstr(hostRef);\n      } catch (e) {\n        consoleError(e);\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {\n        hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {\n        hostRef.$flags$ |= 128 /* isWatchReady */;\n      }\n      endNewInstance();\n      fireConnectedCallback(hostRef.$lazyInstance$);\n    } else {\n      Cstr = elm.constructor;\n      const cmpTag = elm.localName;\n      customElements.whenDefined(cmpTag).then(() => hostRef.$flags$ |= 128 /* isWatchReady */);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && Cstr && Cstr.style) {\n      let style;\n      if (typeof Cstr.style === \"string\") {\n        style = Cstr.style;\n      } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && typeof Cstr.style !== \"string\") {\n        hostRef.$modeName$ = computeMode(elm);\n        if (hostRef.$modeName$) {\n          style = Cstr.style[hostRef.$modeName$];\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && hostRef.$modeName$) {\n          elm.setAttribute(\"s-mode\", hostRef.$modeName$);\n        }\n      }\n      const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);\n      if (!styles.has(scopeId2)) {\n        const endRegisterStyles = createTime(\"registerStyles\", cmpMeta.$tagName$);\n        if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field\n        _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDomShim && cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n          style = await __webpack_require__.e(/*! import() */ \"vendor-chunks/@stencil\").then(__webpack_require__.bind(__webpack_require__, /*! ./shadow-css.js */ \"(ssr)/./node_modules/@stencil/core/internal/client/shadow-css.js\")).then((m) => m.scopeCss(style, scopeId2, false));\n        }\n        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n        endRegisterStyles();\n      }\n    }\n  }\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  const schedule = () => scheduleUpdate(hostRef, true);\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && ancestorComponent && ancestorComponent[\"s-rc\"]) {\n    ancestorComponent[\"s-rc\"].push(schedule);\n  } else {\n    schedule();\n  }\n};\nvar fireConnectedCallback = (instance) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.connectedCallback) {\n    safeCall(instance, \"connectedCallback\");\n  }\n};\n\n// src/runtime/connected-callback.ts\nvar connectedCallback = (elm) => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    const hostRef = getHostRef(elm);\n    const cmpMeta = hostRef.$cmpMeta$;\n    const endConnected = createTime(\"connectedCallback\", cmpMeta.$tagName$);\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent) {\n      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\n    }\n    if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n      hostRef.$flags$ |= 1 /* hasConnected */;\n      let hostId;\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) {\n        hostId = elm.getAttribute(HYDRATE_ID);\n        if (hostId) {\n          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n            const scopeId2 = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute(\"s-mode\")) : addStyle(elm.shadowRoot, cmpMeta);\n            elm.classList.remove(scopeId2 + \"-h\", scopeId2 + \"-s\");\n          }\n          initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n        }\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && !hostId) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide || (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) && // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field\n        cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */)) {\n          setContentReference(elm);\n        }\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {\n        let ancestorComponent = elm;\n        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {\n          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide && ancestorComponent.nodeType === 1 /* ElementNode */ && ancestorComponent.hasAttribute(\"s-id\") && ancestorComponent[\"s-p\"] || ancestorComponent[\"s-p\"]) {\n            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);\n            break;\n          }\n        }\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.prop && !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && cmpMeta.$members$) {\n        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n          if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n            const value = elm[memberName];\n            delete elm[memberName];\n            elm[memberName] = value;\n          }\n        });\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.initializeNextTick) {\n        nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n      } else {\n        initializeComponent(elm, hostRef, cmpMeta);\n      }\n    } else {\n      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {\n        fireConnectedCallback(hostRef.$lazyInstance$);\n      } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {\n        hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$));\n      }\n    }\n    endConnected();\n  }\n};\nvar setContentReference = (elm) => {\n  const contentRefElm = elm[\"s-cr\"] = doc.createComment(\n    _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug ? `content-ref (host=${elm.localName})` : \"\"\n  );\n  contentRefElm[\"s-cn\"] = true;\n  insertBefore(elm, contentRefElm, elm.firstChild);\n};\n\n// src/runtime/disconnected-callback.ts\n\nvar disconnectInstance = (instance) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.disconnectedCallback) {\n    safeCall(instance, \"disconnectedCallback\");\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidUnload) {\n    safeCall(instance, \"componentDidUnload\");\n  }\n};\nvar disconnectedCallback = async (elm) => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    const hostRef = getHostRef(elm);\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {\n      if (hostRef.$rmListeners$) {\n        hostRef.$rmListeners$.map((rmListener) => rmListener());\n        hostRef.$rmListeners$ = void 0;\n      }\n    }\n    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {\n      disconnectInstance(elm);\n    } else if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {\n      disconnectInstance(hostRef.$lazyInstance$);\n    } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {\n      hostRef.$onReadyPromise$.then(() => disconnectInstance(hostRef.$lazyInstance$));\n    }\n  }\n};\n\n// src/runtime/dom-extras.ts\n\nvar patchPseudoShadowDom = (hostElementPrototype, descriptorPrototype) => {\n  patchCloneNode(hostElementPrototype);\n  patchSlotAppendChild(hostElementPrototype);\n  patchSlotAppend(hostElementPrototype);\n  patchSlotPrepend(hostElementPrototype);\n  patchSlotInsertAdjacentElement(hostElementPrototype);\n  patchSlotInsertAdjacentHTML(hostElementPrototype);\n  patchSlotInsertAdjacentText(hostElementPrototype);\n  patchTextContent(hostElementPrototype);\n  patchChildSlotNodes(hostElementPrototype, descriptorPrototype);\n  patchSlotRemoveChild(hostElementPrototype);\n};\nvar patchCloneNode = (HostElementPrototype) => {\n  const orgCloneNode = HostElementPrototype.cloneNode;\n  HostElementPrototype.cloneNode = function(deep) {\n    const srcNode = this;\n    const isShadowDom = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\n    const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot && !isShadowDom && deep) {\n      let i2 = 0;\n      let slotted, nonStencilNode;\n      const stencilPrivates = [\n        \"s-id\",\n        \"s-cr\",\n        \"s-lr\",\n        \"s-rc\",\n        \"s-sc\",\n        \"s-p\",\n        \"s-cn\",\n        \"s-sr\",\n        \"s-sn\",\n        \"s-hn\",\n        \"s-ol\",\n        \"s-nr\",\n        \"s-si\",\n        \"s-rf\",\n        \"s-scs\"\n      ];\n      for (; i2 < srcNode.childNodes.length; i2++) {\n        slotted = srcNode.childNodes[i2][\"s-nr\"];\n        nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i2][privateField]);\n        if (slotted) {\n          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.appendChildSlotFix && clonedNode.__appendChild) {\n            clonedNode.__appendChild(slotted.cloneNode(true));\n          } else {\n            clonedNode.appendChild(slotted.cloneNode(true));\n          }\n        }\n        if (nonStencilNode) {\n          clonedNode.appendChild(srcNode.childNodes[i2].cloneNode(true));\n        }\n      }\n    }\n    return clonedNode;\n  };\n};\nvar patchSlotAppendChild = (HostElementPrototype) => {\n  HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n  HostElementPrototype.appendChild = function(newChild) {\n    const slotName = newChild[\"s-sn\"] = getSlotName(newChild);\n    const slotNode = getHostSlotNode(this.childNodes, slotName, this.tagName);\n    if (slotNode) {\n      const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n      const appendAfter = slotChildNodes[slotChildNodes.length - 1];\n      const insertedNode = insertBefore(appendAfter.parentNode, newChild, appendAfter.nextSibling);\n      updateFallbackSlotVisibility(this);\n      return insertedNode;\n    }\n    return this.__appendChild(newChild);\n  };\n};\nvar patchSlotRemoveChild = (ElementPrototype) => {\n  ElementPrototype.__removeChild = ElementPrototype.removeChild;\n  ElementPrototype.removeChild = function(toRemove) {\n    if (toRemove && typeof toRemove[\"s-sn\"] !== \"undefined\") {\n      const slotNode = getHostSlotNode(this.childNodes, toRemove[\"s-sn\"], this.tagName);\n      if (slotNode) {\n        const slotChildNodes = getHostSlotChildNodes(slotNode, toRemove[\"s-sn\"]);\n        const existingNode = slotChildNodes.find((n) => n === toRemove);\n        if (existingNode) {\n          existingNode.remove();\n          updateFallbackSlotVisibility(this);\n          return;\n        }\n      }\n    }\n    return this.__removeChild(toRemove);\n  };\n};\nvar patchSlotPrepend = (HostElementPrototype) => {\n  const originalPrepend = HostElementPrototype.prepend;\n  HostElementPrototype.prepend = function(...newChildren) {\n    newChildren.forEach((newChild) => {\n      if (typeof newChild === \"string\") {\n        newChild = this.ownerDocument.createTextNode(newChild);\n      }\n      const slotName = newChild[\"s-sn\"] = getSlotName(newChild);\n      const slotNode = getHostSlotNode(this.childNodes, slotName, this.tagName);\n      if (slotNode) {\n        const slotPlaceholder = document.createTextNode(\"\");\n        slotPlaceholder[\"s-nr\"] = newChild;\n        slotNode[\"s-cr\"].parentNode.__appendChild(slotPlaceholder);\n        newChild[\"s-ol\"] = slotPlaceholder;\n        const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n        const appendAfter = slotChildNodes[0];\n        return insertBefore(appendAfter.parentNode, newChild, appendAfter.nextSibling);\n      }\n      if (newChild.nodeType === 1 && !!newChild.getAttribute(\"slot\")) {\n        newChild.hidden = true;\n      }\n      return originalPrepend.call(this, newChild);\n    });\n  };\n};\nvar patchSlotAppend = (HostElementPrototype) => {\n  HostElementPrototype.append = function(...newChildren) {\n    newChildren.forEach((newChild) => {\n      if (typeof newChild === \"string\") {\n        newChild = this.ownerDocument.createTextNode(newChild);\n      }\n      this.appendChild(newChild);\n    });\n  };\n};\nvar patchSlotInsertAdjacentHTML = (HostElementPrototype) => {\n  const originalInsertAdjacentHtml = HostElementPrototype.insertAdjacentHTML;\n  HostElementPrototype.insertAdjacentHTML = function(position, text) {\n    if (position !== \"afterbegin\" && position !== \"beforeend\") {\n      return originalInsertAdjacentHtml.call(this, position, text);\n    }\n    const container = this.ownerDocument.createElement(\"_\");\n    let node;\n    container.innerHTML = text;\n    if (position === \"afterbegin\") {\n      while (node = container.firstChild) {\n        this.prepend(node);\n      }\n    } else if (position === \"beforeend\") {\n      while (node = container.firstChild) {\n        this.append(node);\n      }\n    }\n  };\n};\nvar patchSlotInsertAdjacentText = (HostElementPrototype) => {\n  HostElementPrototype.insertAdjacentText = function(position, text) {\n    this.insertAdjacentHTML(position, text);\n  };\n};\nvar patchSlotInsertAdjacentElement = (HostElementPrototype) => {\n  const originalInsertAdjacentElement = HostElementPrototype.insertAdjacentElement;\n  HostElementPrototype.insertAdjacentElement = function(position, element) {\n    if (position !== \"afterbegin\" && position !== \"beforeend\") {\n      return originalInsertAdjacentElement.call(this, position, element);\n    }\n    if (position === \"afterbegin\") {\n      this.prepend(element);\n      return element;\n    } else if (position === \"beforeend\") {\n      this.append(element);\n      return element;\n    }\n    return element;\n  };\n};\nvar patchTextContent = (hostElementPrototype) => {\n  const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, \"textContent\");\n  Object.defineProperty(hostElementPrototype, \"__textContent\", descriptor);\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.experimentalScopedSlotChanges) {\n    Object.defineProperty(hostElementPrototype, \"textContent\", {\n      // To mimic shadow root behavior, we need to return the text content of all\n      // nodes in a slot reference node\n      get() {\n        const slotRefNodes = getAllChildSlotNodes(this.childNodes);\n        const textContent = slotRefNodes.map((node) => {\n          var _a, _b;\n          const text = [];\n          let slotContent = node.nextSibling;\n          while (slotContent && slotContent[\"s-sn\"] === node[\"s-sn\"]) {\n            if (slotContent.nodeType === 3 /* TEXT_NODE */ || slotContent.nodeType === 1 /* ELEMENT_NODE */) {\n              text.push((_b = (_a = slotContent.textContent) == null ? void 0 : _a.trim()) != null ? _b : \"\");\n            }\n            slotContent = slotContent.nextSibling;\n          }\n          return text.filter((ref) => ref !== \"\").join(\" \");\n        }).filter((text) => text !== \"\").join(\" \");\n        return \" \" + textContent + \" \";\n      },\n      // To mimic shadow root behavior, we need to overwrite all nodes in a slot\n      // reference node. If a default slot reference node exists, the text content will be\n      // placed there. Otherwise, the new text node will be hidden\n      set(value) {\n        const slotRefNodes = getAllChildSlotNodes(this.childNodes);\n        slotRefNodes.forEach((node) => {\n          let slotContent = node.nextSibling;\n          while (slotContent && slotContent[\"s-sn\"] === node[\"s-sn\"]) {\n            const tmp = slotContent;\n            slotContent = slotContent.nextSibling;\n            tmp.remove();\n          }\n          if (node[\"s-sn\"] === \"\") {\n            const textNode = this.ownerDocument.createTextNode(value);\n            textNode[\"s-sn\"] = \"\";\n            insertBefore(node.parentElement, textNode, node.nextSibling);\n          } else {\n            node.remove();\n          }\n        });\n      }\n    });\n  } else {\n    Object.defineProperty(hostElementPrototype, \"textContent\", {\n      get() {\n        var _a;\n        const slotNode = getHostSlotNode(this.childNodes, \"\", this.tagName);\n        if (((_a = slotNode == null ? void 0 : slotNode.nextSibling) == null ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n          return slotNode.nextSibling.textContent;\n        } else if (slotNode) {\n          return slotNode.textContent;\n        } else {\n          return this.__textContent;\n        }\n      },\n      set(value) {\n        var _a;\n        const slotNode = getHostSlotNode(this.childNodes, \"\", this.tagName);\n        if (((_a = slotNode == null ? void 0 : slotNode.nextSibling) == null ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n          slotNode.nextSibling.textContent = value;\n        } else if (slotNode) {\n          slotNode.textContent = value;\n        } else {\n          this.__textContent = value;\n          const contentRefElm = this[\"s-cr\"];\n          if (contentRefElm) {\n            insertBefore(this, contentRefElm, this.firstChild);\n          }\n        }\n      }\n    });\n  }\n};\nvar patchChildSlotNodes = (elm, cmpMeta) => {\n  class FakeNodeList extends Array {\n    item(n) {\n      return this[n];\n    }\n  }\n  if (cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n    const childNodesFn = elm.__lookupGetter__(\"childNodes\");\n    Object.defineProperty(elm, \"children\", {\n      get() {\n        return this.childNodes.map((n) => n.nodeType === 1);\n      }\n    });\n    Object.defineProperty(elm, \"childElementCount\", {\n      get() {\n        return elm.children.length;\n      }\n    });\n    Object.defineProperty(elm, \"childNodes\", {\n      get() {\n        const childNodes = childNodesFn.call(this);\n        if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0 && getHostRef(this).$flags$ & 2 /* hasRendered */) {\n          const result = new FakeNodeList();\n          for (let i2 = 0; i2 < childNodes.length; i2++) {\n            const slot = childNodes[i2][\"s-nr\"];\n            if (slot) {\n              result.push(slot);\n            }\n          }\n          return result;\n        }\n        return FakeNodeList.from(childNodes);\n      }\n    });\n  }\n};\nvar getAllChildSlotNodes = (childNodes) => {\n  const slotRefNodes = [];\n  for (const childNode of Array.from(childNodes)) {\n    if (childNode[\"s-sr\"]) {\n      slotRefNodes.push(childNode);\n    }\n    slotRefNodes.push(...getAllChildSlotNodes(childNode.childNodes));\n  }\n  return slotRefNodes;\n};\nvar getSlotName = (node) => node[\"s-sn\"] || node.nodeType === 1 && node.getAttribute(\"slot\") || \"\";\nvar getHostSlotNode = (childNodes, slotName, hostName) => {\n  let i2 = 0;\n  let childNode;\n  for (; i2 < childNodes.length; i2++) {\n    childNode = childNodes[i2];\n    if (childNode[\"s-sr\"] && childNode[\"s-sn\"] === slotName && childNode[\"s-hn\"] === hostName) {\n      return childNode;\n    }\n    childNode = getHostSlotNode(childNode.childNodes, slotName, hostName);\n    if (childNode) {\n      return childNode;\n    }\n  }\n  return null;\n};\nvar getHostSlotChildNodes = (n, slotName) => {\n  const childNodes = [n];\n  while ((n = n.nextSibling) && n[\"s-sn\"] === slotName) {\n    childNodes.push(n);\n  }\n  return childNodes;\n};\n\n// src/runtime/bootstrap-custom-element.ts\nvar defineCustomElement = (Cstr, compactMeta) => {\n  customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\n};\nvar proxyCustomElement = (Cstr, compactMeta) => {\n  const cmpMeta = {\n    $flags$: compactMeta[0],\n    $tagName$: compactMeta[1]\n  };\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {\n    cmpMeta.$members$ = compactMeta[2];\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {\n    cmpMeta.$listeners$ = compactMeta[3];\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {\n    cmpMeta.$watchers$ = Cstr.$watchers$;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {\n    cmpMeta.$attrsToReflect$ = [];\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n    cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.experimentalSlotFixes) {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n      patchPseudoShadowDom(Cstr.prototype, cmpMeta);\n    }\n  } else {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotChildNodesFix) {\n      patchChildSlotNodes(Cstr.prototype, cmpMeta);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cloneNodeFix) {\n      patchCloneNode(Cstr.prototype);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.appendChildSlotFix) {\n      patchSlotAppendChild(Cstr.prototype);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scopedSlotTextContentFix && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n      patchTextContent(Cstr.prototype);\n    }\n  }\n  const originalConnectedCallback = Cstr.prototype.connectedCallback;\n  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n  Object.assign(Cstr.prototype, {\n    __registerHost() {\n      registerHost(this, cmpMeta);\n    },\n    connectedCallback() {\n      const hostRef = getHostRef(this);\n      addHostEventListeners(this, hostRef, cmpMeta.$listeners$, false);\n      connectedCallback(this);\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.connectedCallback && originalConnectedCallback) {\n        originalConnectedCallback.call(this);\n      }\n    },\n    disconnectedCallback() {\n      disconnectedCallback(this);\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.disconnectedCallback && originalDisconnectedCallback) {\n        originalDisconnectedCallback.call(this);\n      }\n    },\n    __attachShadow() {\n      if (supportsShadow) {\n        if (!this.shadowRoot) {\n          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDelegatesFocus) {\n            this.attachShadow({\n              mode: \"open\",\n              delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */)\n            });\n          } else {\n            this.attachShadow({ mode: \"open\" });\n          }\n        } else {\n          if (this.shadowRoot.mode !== \"open\") {\n            throw new Error(\n              `Unable to re-use existing shadow root for ${cmpMeta.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`\n            );\n          }\n        }\n      } else {\n        this.shadowRoot = this;\n      }\n    }\n  });\n  Cstr.is = cmpMeta.$tagName$;\n  return proxyComponent(Cstr, cmpMeta, 1 /* isElementConstructor */ | 2 /* proxyState */);\n};\nvar forceModeUpdate = (elm) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {\n    const mode = computeMode(elm);\n    const hostRef = getHostRef(elm);\n    if (hostRef.$modeName$ !== mode) {\n      const cmpMeta = hostRef.$cmpMeta$;\n      const oldScopeId = elm[\"s-sc\"];\n      const scopeId2 = getScopeId(cmpMeta, mode);\n      const style = elm.constructor.style[mode];\n      const flags = cmpMeta.$flags$;\n      if (style) {\n        if (!styles.has(scopeId2)) {\n          registerStyle(scopeId2, style, !!(flags & 1 /* shadowDomEncapsulation */));\n        }\n        hostRef.$modeName$ = mode;\n        elm.classList.remove(oldScopeId + \"-h\", oldScopeId + \"-s\");\n        attachStyles(hostRef);\n        forceUpdate(elm);\n      }\n    }\n  }\n};\n\n// src/runtime/bootstrap-lazy.ts\n\n\n// src/runtime/hmr-component.ts\nvar hmrStart = (hostElement, cmpMeta, hmrVersionId) => {\n  const hostRef = getHostRef(hostElement);\n  hostRef.$flags$ = 1 /* hasConnected */;\n  initializeComponent(hostElement, hostRef, cmpMeta, hmrVersionId);\n};\n\n// src/runtime/bootstrap-lazy.ts\nvar bootstrapLazy = (lazyBundles, options = {}) => {\n  var _a;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {\n    performance.mark(\"st:app:start\");\n  }\n  installDevTools();\n  const endBootstrap = createTime(\"bootstrapLazy\");\n  const cmpTags = [];\n  const exclude = options.exclude || [];\n  const customElements2 = win.customElements;\n  const head = doc.head;\n  const metaCharset = /* @__PURE__ */ head.querySelector(\"meta[charset]\");\n  const dataStyles = /* @__PURE__ */ doc.createElement(\"style\");\n  const deferredConnectedCallbacks = [];\n  const styles2 = /* @__PURE__ */ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);\n  let appLoadFallback;\n  let isBootstrapping = true;\n  let i2 = 0;\n  Object.assign(plt, options);\n  plt.$resourcesUrl$ = new URL(options.resourcesUrl || \"./\", doc.baseURI).href;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {\n    if (options.syncQueue) {\n      plt.$flags$ |= 4 /* queueSync */;\n    }\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) {\n    plt.$flags$ |= 2 /* appLoaded */;\n  }\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) {\n    for (; i2 < styles2.length; i2++) {\n      registerStyle(styles2[i2].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles2[i2].innerHTML), true);\n    }\n  }\n  let hasSlotRelocation = false;\n  lazyBundles.map((lazyBundle) => {\n    lazyBundle[1].map((compactMeta) => {\n      var _a2;\n      const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n        $members$: compactMeta[2],\n        $listeners$: compactMeta[3]\n      };\n      if (cmpMeta.$flags$ & 4 /* hasSlotRelocation */) {\n        hasSlotRelocation = true;\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {\n        cmpMeta.$members$ = compactMeta[2];\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {\n        cmpMeta.$listeners$ = compactMeta[3];\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {\n        cmpMeta.$attrsToReflect$ = [];\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {\n        cmpMeta.$watchers$ = (_a2 = compactMeta[4]) != null ? _a2 : {};\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n        cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n      }\n      const tagName = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.transformTagName && options.transformTagName ? options.transformTagName(cmpMeta.$tagName$) : cmpMeta.$tagName$;\n      const HostElement = class extends HTMLElement {\n        // StencilLazyHost\n        constructor(self) {\n          super(self);\n          this.hasRegisteredEventListeners = false;\n          self = this;\n          registerHost(self, cmpMeta);\n          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n            if (supportsShadow) {\n              if (!self.shadowRoot) {\n                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDelegatesFocus) {\n                  self.attachShadow({\n                    mode: \"open\",\n                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */)\n                  });\n                } else {\n                  self.attachShadow({ mode: \"open\" });\n                }\n              } else {\n                if (self.shadowRoot.mode !== \"open\") {\n                  throw new Error(\n                    `Unable to re-use existing shadow root for ${cmpMeta.$tagName$}! Mode is set to ${self.shadowRoot.mode} but Stencil only supports open shadow roots.`\n                  );\n                }\n              }\n            } else if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && !(\"shadowRoot\" in self)) {\n              self.shadowRoot = self;\n            }\n          }\n        }\n        connectedCallback() {\n          const hostRef = getHostRef(this);\n          if (!this.hasRegisteredEventListeners) {\n            this.hasRegisteredEventListeners = true;\n            addHostEventListeners(this, hostRef, cmpMeta.$listeners$, false);\n          }\n          if (appLoadFallback) {\n            clearTimeout(appLoadFallback);\n            appLoadFallback = null;\n          }\n          if (isBootstrapping) {\n            deferredConnectedCallbacks.push(this);\n          } else {\n            plt.jmp(() => connectedCallback(this));\n          }\n        }\n        disconnectedCallback() {\n          plt.jmp(() => disconnectedCallback(this));\n        }\n        componentOnReady() {\n          return getHostRef(this).$onReadyPromise$;\n        }\n      };\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.experimentalSlotFixes) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n          patchPseudoShadowDom(HostElement.prototype, cmpMeta);\n        }\n      } else {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotChildNodesFix) {\n          patchChildSlotNodes(HostElement.prototype, cmpMeta);\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cloneNodeFix) {\n          patchCloneNode(HostElement.prototype);\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.appendChildSlotFix) {\n          patchSlotAppendChild(HostElement.prototype);\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scopedSlotTextContentFix && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n          patchTextContent(HostElement.prototype);\n        }\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.formAssociated && cmpMeta.$flags$ & 64 /* formAssociated */) {\n        HostElement.formAssociated = true;\n      }\n      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {\n        HostElement.prototype[\"s-hmr\"] = function(hmrVersionId) {\n          hmrStart(this, cmpMeta, hmrVersionId);\n        };\n      }\n      cmpMeta.$lazyBundleId$ = lazyBundle[0];\n      if (!exclude.includes(tagName) && !customElements2.get(tagName)) {\n        cmpTags.push(tagName);\n        customElements2.define(\n          tagName,\n          proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */)\n        );\n      }\n    });\n  });\n  if (cmpTags.length > 0) {\n    if (hasSlotRelocation) {\n      dataStyles.textContent += SLOT_FB_CSS;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.invisiblePrehydration && (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedClass || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedAttribute)) {\n      dataStyles.textContent += cmpTags.sort() + HYDRATED_CSS;\n    }\n    if (dataStyles.innerHTML.length) {\n      dataStyles.setAttribute(\"data-styles\", \"\");\n      const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(doc);\n      if (nonce != null) {\n        dataStyles.setAttribute(\"nonce\", nonce);\n      }\n      head.insertBefore(dataStyles, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n  }\n  isBootstrapping = false;\n  if (deferredConnectedCallbacks.length) {\n    deferredConnectedCallbacks.map((host) => host.connectedCallback());\n  } else {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile) {\n      plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30, \"timeout\"));\n    } else {\n      plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));\n    }\n  }\n  endBootstrap();\n};\n\n// src/runtime/fragment.ts\nvar Fragment = (_, children) => children;\n\n// src/runtime/host-listener.ts\n\nvar addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener && listeners) {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent) {\n      if (attachParentListeners) {\n        listeners = listeners.filter(([flags]) => flags & 32 /* TargetParent */);\n      } else {\n        listeners = listeners.filter(([flags]) => !(flags & 32 /* TargetParent */));\n      }\n    }\n    listeners.map(([flags, name, method]) => {\n      const target = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\n      const handler = hostListenerProxy(hostRef, method);\n      const opts = hostListenerOpts(flags);\n      plt.ael(target, name, handler, opts);\n      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n    });\n  }\n};\nvar hostListenerProxy = (hostRef, methodName) => (ev) => {\n  var _a;\n  try {\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {\n      if (hostRef.$flags$ & 256 /* isListenReady */) {\n        (_a = hostRef.$lazyInstance$) == null ? void 0 : _a[methodName](ev);\n      } else {\n        (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n      }\n    } else {\n      hostRef.$hostElement$[methodName](ev);\n    }\n  } catch (e) {\n    consoleError(e);\n  }\n};\nvar getHostListenerTarget = (elm, flags) => {\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetDocument && flags & 4 /* TargetDocument */) return doc;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetWindow && flags & 8 /* TargetWindow */) return win;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetBody && flags & 16 /* TargetBody */) return doc.body;\n  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent && flags & 32 /* TargetParent */ && elm.parentElement)\n    return elm.parentElement;\n  return elm;\n};\nvar hostListenerOpts = (flags) => supportsListenerOptions ? {\n  passive: (flags & 1 /* Passive */) !== 0,\n  capture: (flags & 2 /* Capture */) !== 0\n} : (flags & 2 /* Capture */) !== 0;\n\n// src/runtime/nonce.ts\nvar setNonce = (nonce) => plt.$nonce$ = nonce;\n\n// src/runtime/platform-options.ts\nvar setPlatformOptions = (opts) => Object.assign(plt, opts);\n\n// src/runtime/vdom/vdom-annotations.ts\nvar insertVdomAnnotations = (doc2, staticComponents) => {\n  if (doc2 != null) {\n    const docData = {\n      hostIds: 0,\n      rootLevelIds: 0,\n      staticComponents: new Set(staticComponents)\n    };\n    const orgLocationNodes = [];\n    parseVNodeAnnotations(doc2, doc2.body, docData, orgLocationNodes);\n    orgLocationNodes.forEach((orgLocationNode) => {\n      var _a;\n      if (orgLocationNode != null && orgLocationNode[\"s-nr\"]) {\n        const nodeRef = orgLocationNode[\"s-nr\"];\n        let hostId = nodeRef[\"s-host-id\"];\n        let nodeId = nodeRef[\"s-node-id\"];\n        let childId = `${hostId}.${nodeId}`;\n        if (hostId == null) {\n          hostId = 0;\n          docData.rootLevelIds++;\n          nodeId = docData.rootLevelIds;\n          childId = `${hostId}.${nodeId}`;\n          if (nodeRef.nodeType === 1 /* ElementNode */) {\n            nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\n          } else if (nodeRef.nodeType === 3 /* TextNode */) {\n            if (hostId === 0) {\n              const textContent = (_a = nodeRef.nodeValue) == null ? void 0 : _a.trim();\n              if (textContent === \"\") {\n                orgLocationNode.remove();\n                return;\n              }\n            }\n            const commentBeforeTextNode = doc2.createComment(childId);\n            commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;\n            insertBefore(nodeRef.parentNode, commentBeforeTextNode, nodeRef);\n          }\n        }\n        let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;\n        const orgLocationParentNode = orgLocationNode.parentElement;\n        if (orgLocationParentNode) {\n          if (orgLocationParentNode[\"s-en\"] === \"\") {\n            orgLocationNodeId += `.`;\n          } else if (orgLocationParentNode[\"s-en\"] === \"c\") {\n            orgLocationNodeId += `.c`;\n          }\n        }\n        orgLocationNode.nodeValue = orgLocationNodeId;\n      }\n    });\n  }\n};\nvar parseVNodeAnnotations = (doc2, node, docData, orgLocationNodes) => {\n  var _a;\n  if (node == null) {\n    return;\n  }\n  if (node[\"s-nr\"] != null) {\n    orgLocationNodes.push(node);\n  }\n  if (node.nodeType === 1 /* ElementNode */) {\n    const childNodes = [...Array.from(node.childNodes), ...Array.from(((_a = node.shadowRoot) == null ? void 0 : _a.childNodes) || [])];\n    childNodes.forEach((childNode) => {\n      const hostRef = getHostRef(childNode);\n      if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\n        const cmpData = {\n          nodeIds: 0\n        };\n        insertVNodeAnnotations(doc2, childNode, hostRef.$vnode$, docData, cmpData);\n      }\n      parseVNodeAnnotations(doc2, childNode, docData, orgLocationNodes);\n    });\n  }\n};\nvar insertVNodeAnnotations = (doc2, hostElm, vnode, docData, cmpData) => {\n  if (vnode != null) {\n    const hostId = ++docData.hostIds;\n    hostElm.setAttribute(HYDRATE_ID, hostId);\n    if (hostElm[\"s-cr\"] != null) {\n      hostElm[\"s-cr\"].nodeValue = `${CONTENT_REF_ID}.${hostId}`;\n    }\n    if (vnode.$children$ != null) {\n      const depth = 0;\n      vnode.$children$.forEach((vnodeChild, index) => {\n        insertChildVNodeAnnotations(doc2, vnodeChild, cmpData, hostId, depth, index);\n      });\n    }\n    if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute(HYDRATE_CHILD_ID)) {\n      const parent = hostElm.parentElement;\n      if (parent && parent.childNodes) {\n        const parentChildNodes = Array.from(parent.childNodes);\n        const comment = parentChildNodes.find(\n          (node) => node.nodeType === 8 /* CommentNode */ && node[\"s-sr\"]\n        );\n        if (comment) {\n          const index = parentChildNodes.indexOf(hostElm) - 1;\n          vnode.$elm$.setAttribute(\n            HYDRATE_CHILD_ID,\n            `${comment[\"s-host-id\"]}.${comment[\"s-node-id\"]}.0.${index}`\n          );\n        }\n      }\n    }\n  }\n};\nvar insertChildVNodeAnnotations = (doc2, vnodeChild, cmpData, hostId, depth, index) => {\n  const childElm = vnodeChild.$elm$;\n  if (childElm == null) {\n    return;\n  }\n  const nodeId = cmpData.nodeIds++;\n  const childId = `${hostId}.${nodeId}.${depth}.${index}`;\n  childElm[\"s-host-id\"] = hostId;\n  childElm[\"s-node-id\"] = nodeId;\n  if (childElm.nodeType === 1 /* ElementNode */) {\n    childElm.setAttribute(HYDRATE_CHILD_ID, childId);\n  } else if (childElm.nodeType === 3 /* TextNode */) {\n    const parentNode = childElm.parentNode;\n    const nodeName = parentNode == null ? void 0 : parentNode.nodeName;\n    if (nodeName !== \"STYLE\" && nodeName !== \"SCRIPT\") {\n      const textNodeId = `${TEXT_NODE_ID}.${childId}`;\n      const commentBeforeTextNode = doc2.createComment(textNodeId);\n      insertBefore(parentNode, commentBeforeTextNode, childElm);\n    }\n  } else if (childElm.nodeType === 8 /* CommentNode */) {\n    if (childElm[\"s-sr\"]) {\n      const slotName = childElm[\"s-sn\"] || \"\";\n      const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;\n      childElm.nodeValue = slotNodeId;\n    }\n  }\n  if (vnodeChild.$children$ != null) {\n    const childDepth = depth + 1;\n    vnodeChild.$children$.forEach((vnode, index2) => {\n      insertChildVNodeAnnotations(doc2, vnode, cmpData, hostId, childDepth, index2);\n    });\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ3dEO0FBQ3hEO0FBQ0EsU0FBUyxrRUFBSztBQUNkO0FBQ0E7QUFDQSxhQUFhLGtFQUFLO0FBQ2xCOztBQUVBO0FBQ2tFO0FBQ2xFLGVBQWUsa0VBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBTTtBQUNaO0FBQ0E7QUFDQSxNQUFNLGtFQUFNLFdBQVcsa0VBQU07QUFDN0I7QUFDQTtBQUNBLE1BQU0sa0VBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNrRTs7QUFFbEU7QUFDa0U7QUFDbEU7QUFDQTtBQUNBLHVCQUF1QixrRUFBTTtBQUM3QjtBQUNBLGdCQUFnQixtQkFBbUIsbUJBQW1CLGdCQUFnQixpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFNO0FBQ1o7QUFDQSwwQ0FBMEMsa0JBQWtCLHFCQUFxQixtQkFBbUI7QUFDcEc7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0S0FLTCxHQUFHLEVBQUUsU0FBUyxXQUFXLGtFQUFNLHNFQUFzRSxDQUFDLENBQ3ZHO0FBQ0gsU0FBUyxrRUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDa0U7O0FBRWxFO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtFQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILE1BQU0sa0VBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtFQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixjQUFjLGtFQUFNO0FBQ3BCO0FBQ0EsWUFBWSxTQUFTLGtFQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0NBQXdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ21FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRTs7QUFFbkU7QUFDbUU7O0FBRW5FO0FBQ21FO0FBQ25FO0FBQ0E7QUFDQSxRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBLFFBQVEsa0VBQU87QUFDZjtBQUNBO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RTs7QUFFOUU7QUFDbUU7O0FBRW5FO0FBQ21FO0FBQ25FLDBCQUEwQixrRUFBTzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQU87QUFDakIsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrRUFBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQU8sa0dBQWtHLGtCQUFrQixJQUFJLFNBQVM7QUFDcEo7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrRUFBTyxzQkFBc0Isa0VBQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyxrRUFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrRUFBTztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0VBQU8sY0FBYyxrRUFBTyxZQUFZLGtFQUFPO0FBQ3REO0FBQ0E7QUFDQSxRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrRUFBTztBQUNoRCx3RUFBd0UsSUFBSSxRQUFROztBQUVwRjtBQUNtRTs7QUFFbkU7QUFDbUU7O0FBRW5FO0FBQ21FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsa0VBQU87QUFDdEIsVUFBVSxrRUFBTztBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCLGtFQUFPO0FBQ3hCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrRUFBTztBQUN0QjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyxrRUFBTztBQUN0QixNQUFNLFNBQVMsa0VBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLGtFQUFPLGtCQUFrQixrRUFBTztBQUMvQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyxrRUFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0VBQU87QUFDckI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsWUFBWSxrRUFBTztBQUNuQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0EsaUJBQWlCLGdDQUFnQyxpQkFBaUIsY0FBYyxnQkFBZ0IsWUFBWTtBQUM1RztBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0EsSUFBSSxTQUFTLGtFQUFPO0FBQ3BCLDRCQUE0QixrRUFBTyxZQUFZLGtFQUFPO0FBQ3RELElBQUk7QUFDSixRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBLDRCQUE0QixrRUFBTztBQUNuQztBQUNBLDZCQUE2QixrRUFBTztBQUNwQztBQUNBLDZCQUE2QixrRUFBTztBQUNwQztBQUNBLFFBQVEsa0VBQU87QUFDZjtBQUNBO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQSxTQUFTLGtFQUFPLGNBQWMsa0VBQU87QUFDckM7QUFDQTtBQUNBLFFBQVEsa0VBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQWtDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0VBQU87QUFDZjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFPO0FBQ25CO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0VBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0VBQU87QUFDNUI7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtFQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFVBQVUsa0VBQU87QUFDakIsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBTztBQUNuQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxTQUFTLGtFQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBLFFBQVEsa0VBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrRUFBTztBQUNkLFFBQVEsa0VBQU87QUFDZjtBQUNBO0FBQ0EsUUFBUSxrRUFBTyxrQkFBa0Isa0VBQU87QUFDeEMsVUFBVSxrRUFBTztBQUNqQixZQUFZLGtFQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFPO0FBQ2Y7QUFDQSxNQUFNO0FBQ04sVUFBVSxrRUFBTyxjQUFjLGtFQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyxrRUFBTztBQUN0QjtBQUNBO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQSxJQUFJLFNBQVMsa0VBQU8sYUFBYSxrRUFBTztBQUN4QztBQUNBLElBQUksU0FBUyxrRUFBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0Esc0ZBQXNGLGtFQUFPO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBLHVDQUF1QywwQkFBMEI7O0FBRWpFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0VBQU87QUFDNUMsTUFBTSxrRUFBTyxXQUFXLGtFQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0VBQU8sWUFBWSxrRUFBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0VBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyREFBMkQsVUFBVSwwQkFBMEI7QUFDekc7QUFDQTtBQUNBLHdEQUF3RCx5QkFBeUIsVUFBVSx1QkFBdUIsU0FBUywyQkFBMkI7QUFDdEo7O0FBRUE7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU8sY0FBYyxrRUFBTztBQUNsQztBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtFQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFPO0FBQzFCO0FBQ0E7QUFDQSxpQ0FBaUMsMkJBQTJCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBTyxhQUFhLGtFQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrRUFBTztBQUM3QixtQkFBbUIsa0VBQU87QUFDMUIsb0JBQW9CLGtFQUFPO0FBQzNCLG9CQUFvQixrRUFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFPLGdCQUFnQixrRUFBTztBQUN0QyxVQUFVLGtFQUFPLGVBQWUsa0VBQU87QUFDdkMsWUFBWSxrRUFBTztBQUNuQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrRUFBTztBQUMxQjtBQUNBLE1BQU0sa0VBQU87QUFDYixRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0VBQU8saUJBQWlCLGtFQUFPO0FBQ3ZDO0FBQ0E7QUFDQSxRQUFRLGtFQUFPO0FBQ2YsVUFBVSxrRUFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLGtFQUFPO0FBQ2YsVUFBVSxrRUFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU8sV0FBVyxrRUFBTztBQUMvQjtBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0EsNkNBQTZDLFVBQVUsV0FBVyxzRUFBUyxJQUFJO0FBQy9FLE1BQU0sa0VBQU87QUFDYixxQ0FBcUMsc0VBQVMsRUFBRSxtQkFBbUIsSUFBSTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNFQUFTO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrRUFBTyx5Q0FBeUMsa0VBQU8sb0RBQW9ELGtFQUFPLDRDQUE0QyxrRUFBTztBQUM5SztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQSxjQUFjLGtFQUFPO0FBQ3JCO0FBQ0E7QUFDQSxtQkFBbUIsa0VBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0VBQU87QUFDaEIsVUFBVSxrRUFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVUsa0VBQU87QUFDakIsWUFBWSxrRUFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0VBQU87QUFDN0IsMkJBQTJCLGtFQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTSxrRUFBTyxnQ0FBZ0Msa0VBQU87QUFDcEQsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxXQUFXLGtFQUFPLFNBQVMsa0VBQU8sNkNBQTZDLGtFQUFPO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGdCQUFnQixrRUFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVyxRQUFRLGtCQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSxTQUFTLGtFQUFPLGFBQWEsa0VBQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsUUFBUSxrRUFBTyx1QkFBdUIsa0VBQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0VBQU87QUFDakMsK0JBQStCLGtFQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrRUFBTyxhQUFhLGtFQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0IsR0FBRyxtQkFBbUI7QUFDN0Qsd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtCQUFrQixHQUFHLG1CQUFtQjtBQUNwRjtBQUNBLFVBQVUsa0VBQU87QUFDakIsWUFBWSxrRUFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUyxrRUFBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRUFBTyxzQkFBc0Isa0VBQU87QUFDakQsUUFBUSxrRUFBTztBQUNmLHdCQUF3Qiw4TUFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU8sYUFBYSxrRUFBTztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQSxjQUFjLGtFQUFPO0FBQ3JCLDZCQUE2QixrRUFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBTztBQUNqQixZQUFZLGtFQUFPLHVCQUF1QixrRUFBTyxTQUFTLGtFQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBTztBQUNqQjtBQUNBO0FBQ0EsY0FBYyxrRUFBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBTyxVQUFVLGtFQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFVBQVUsa0VBQU87QUFDakI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0VBQU8sZ0NBQWdDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDbUU7QUFDbkU7QUFDQSxNQUFNLGtFQUFPLGFBQWEsa0VBQU87QUFDakM7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0VBQU87QUFDaEI7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQU87QUFDL0I7QUFDQSxRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdDQUFnQztBQUM3QztBQUNBO0FBQ0E7QUFDQSxjQUFjLGtFQUFPO0FBQ3JCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdCQUF3QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiO0FBQ0E7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYixRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBLFFBQVEsa0VBQU87QUFDZjtBQUNBO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQSxRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQU87QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsVUFBVSxrRUFBTztBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0VBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWixnQ0FBZ0MsY0FBYztBQUM5QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMkRBQTJELGtCQUFrQixtQkFBbUIsc0JBQXNCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFPLFVBQVUsa0VBQU8sVUFBVSxrRUFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ21FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxNQUFNLGtFQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrQkFBa0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQU87QUFDYjtBQUNBO0FBQ0EsTUFBTSxrRUFBTyxzQkFBc0Isa0VBQU87QUFDMUMsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVLGtFQUFPO0FBQ2pCO0FBQ0E7QUFDQSxzQkFBc0Isa0VBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtFQUFPO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixzQ0FBc0MsY0FBYztBQUNwRDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsaUVBQWlFLGtCQUFrQixtQkFBbUIsc0JBQXNCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVSxrRUFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQU87QUFDakIsWUFBWSxrRUFBTztBQUNuQjtBQUNBO0FBQ0EsUUFBUTtBQUNSLFlBQVksa0VBQU87QUFDbkI7QUFDQTtBQUNBLFlBQVksa0VBQU87QUFDbkI7QUFDQTtBQUNBLFlBQVksa0VBQU87QUFDbkI7QUFDQTtBQUNBLFlBQVksa0VBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBTztBQUNqQjtBQUNBO0FBQ0EsVUFBVSxrRUFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBTywyQkFBMkIsa0VBQU8sa0JBQWtCLGtFQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSxrRUFBTztBQUNmO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNtRTtBQUNuRTtBQUNBLE1BQU0sa0VBQU87QUFDYixRQUFRLGtFQUFPO0FBQ2Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrRUFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBTztBQUNmO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBTztBQUNiLE1BQU0sa0VBQU87QUFDYixNQUFNLGtFQUFPO0FBQ2IsTUFBTSxrRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sR0FBRyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU8sR0FBRyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhLEdBQUcsUUFBUTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCLEdBQUcsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxlQUFlLEdBQUcsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCLEdBQUcscUJBQXFCLEtBQUssTUFBTTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxHQUFHLE9BQU8sR0FBRyxNQUFNLEdBQUcsTUFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYSxHQUFHLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYSxHQUFHLFFBQVEsR0FBRyxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUE0REUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvaW5kZXguanM/NDJkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIFN0ZW5jaWwgQ2xpZW50IFBsYXRmb3JtIHY0LjE5LjIgfCBNSVQgTGljZW5zZWQgfCBodHRwczovL3N0ZW5jaWxqcy5jb21cbiAqL1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2NsaWVudC9jbGllbnQtYnVpbGQudHNcbmltcG9ydCB7IEJVSUxEIH0gZnJvbSBcIkBzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGFcIjtcbnZhciBCdWlsZCA9IHtcbiAgaXNEZXY6IEJVSUxELmlzRGV2ID8gdHJ1ZSA6IGZhbHNlLFxuICBpc0Jyb3dzZXI6IHRydWUsXG4gIGlzU2VydmVyOiBmYWxzZSxcbiAgaXNUZXN0aW5nOiBCVUlMRC5pc1Rlc3RpbmcgPyB0cnVlIDogZmFsc2Vcbn07XG5cbi8vIHNyYy9jbGllbnQvY2xpZW50LWhvc3QtcmVmLnRzXG5pbXBvcnQgeyBCVUlMRCBhcyBCVUlMRDIgfSBmcm9tIFwiQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YVwiO1xudmFyIGhvc3RSZWZzID0gQlVJTEQyLmhvdE1vZHVsZVJlcGxhY2VtZW50ID8gd2luZG93Ll9fU1RFTkNJTF9IT1NUUkVGU19fIHx8ICh3aW5kb3cuX19TVEVOQ0lMX0hPU1RSRUZTX18gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSkgOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBnZXRIb3N0UmVmID0gKHJlZikgPT4gaG9zdFJlZnMuZ2V0KHJlZik7XG52YXIgcmVnaXN0ZXJJbnN0YW5jZSA9IChsYXp5SW5zdGFuY2UsIGhvc3RSZWYpID0+IGhvc3RSZWZzLnNldChob3N0UmVmLiRsYXp5SW5zdGFuY2UkID0gbGF6eUluc3RhbmNlLCBob3N0UmVmKTtcbnZhciByZWdpc3Rlckhvc3QgPSAoaG9zdEVsZW1lbnQsIGNtcE1ldGEpID0+IHtcbiAgY29uc3QgaG9zdFJlZiA9IHtcbiAgICAkZmxhZ3MkOiAwLFxuICAgICRob3N0RWxlbWVudCQ6IGhvc3RFbGVtZW50LFxuICAgICRjbXBNZXRhJDogY21wTWV0YSxcbiAgICAkaW5zdGFuY2VWYWx1ZXMkOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH07XG4gIGlmIChCVUlMRDIuaXNEZXYpIHtcbiAgICBob3N0UmVmLiRyZW5kZXJDb3VudCQgPSAwO1xuICB9XG4gIGlmIChCVUlMRDIubWV0aG9kICYmIEJVSUxEMi5sYXp5TG9hZCkge1xuICAgIGhvc3RSZWYuJG9uSW5zdGFuY2VQcm9taXNlJCA9IG5ldyBQcm9taXNlKChyKSA9PiBob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQgPSByKTtcbiAgfVxuICBpZiAoQlVJTEQyLmFzeW5jTG9hZGluZykge1xuICAgIGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCA9IG5ldyBQcm9taXNlKChyKSA9PiBob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQgPSByKTtcbiAgICBob3N0RWxlbWVudFtcInMtcFwiXSA9IFtdO1xuICAgIGhvc3RFbGVtZW50W1wicy1yY1wiXSA9IFtdO1xuICB9XG4gIHJldHVybiBob3N0UmVmcy5zZXQoaG9zdEVsZW1lbnQsIGhvc3RSZWYpO1xufTtcbnZhciBpc01lbWJlckluRWxlbWVudCA9IChlbG0sIG1lbWJlck5hbWUpID0+IG1lbWJlck5hbWUgaW4gZWxtO1xuXG4vLyBzcmMvY2xpZW50L2NsaWVudC1sb2FkLW1vZHVsZS50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQ0IH0gZnJvbSBcIkBzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGFcIjtcblxuLy8gc3JjL2NsaWVudC9jbGllbnQtbG9nLnRzXG5pbXBvcnQgeyBCVUlMRCBhcyBCVUlMRDMgfSBmcm9tIFwiQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YVwiO1xudmFyIGN1c3RvbUVycm9yO1xudmFyIGNvbnNvbGVFcnJvciA9IChlLCBlbCkgPT4gKGN1c3RvbUVycm9yIHx8IGNvbnNvbGUuZXJyb3IpKGUsIGVsKTtcbnZhciBTVEVOQ0lMX0RFVl9NT0RFID0gQlVJTEQzLmlzVGVzdGluZyA/IFtcIlNURU5DSUw6XCJdIDogW1xuICBcIiVjc3RlbmNpbFwiLFxuICBcImNvbG9yOiB3aGl0ZTtiYWNrZ3JvdW5kOiM0YzQ3ZmY7Zm9udC13ZWlnaHQ6IGJvbGQ7IGZvbnQtc2l6ZToxMHB4OyBwYWRkaW5nOjJweCA2cHg7IGJvcmRlci1yYWRpdXM6IDVweFwiXG5dO1xudmFyIGNvbnNvbGVEZXZFcnJvciA9ICguLi5tKSA9PiBjb25zb2xlLmVycm9yKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xudmFyIGNvbnNvbGVEZXZXYXJuID0gKC4uLm0pID0+IGNvbnNvbGUud2FybiguLi5TVEVOQ0lMX0RFVl9NT0RFLCAuLi5tKTtcbnZhciBjb25zb2xlRGV2SW5mbyA9ICguLi5tKSA9PiBjb25zb2xlLmluZm8oLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG52YXIgc2V0RXJyb3JIYW5kbGVyID0gKGhhbmRsZXIpID0+IGN1c3RvbUVycm9yID0gaGFuZGxlcjtcblxuLy8gc3JjL2NsaWVudC9jbGllbnQtbG9hZC1tb2R1bGUudHNcbnZhciBjbXBNb2R1bGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBNT0RVTEVfSU1QT1JUX1BSRUZJWCA9IFwiLi9cIjtcbnZhciBsb2FkTW9kdWxlID0gKGNtcE1ldGEsIGhvc3RSZWYsIGhtclZlcnNpb25JZCkgPT4ge1xuICBjb25zdCBleHBvcnROYW1lID0gY21wTWV0YS4kdGFnTmFtZSQucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gIGNvbnN0IGJ1bmRsZUlkID0gY21wTWV0YS4kbGF6eUJ1bmRsZUlkJDtcbiAgaWYgKEJVSUxENC5pc0RldiAmJiB0eXBlb2YgYnVuZGxlSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zb2xlRGV2RXJyb3IoXG4gICAgICBgVHJ5aW5nIHRvIGxhemlseSBsb2FkIGNvbXBvbmVudCA8JHtjbXBNZXRhLiR0YWdOYW1lJH0+IHdpdGggc3R5bGUgbW9kZSBcIiR7aG9zdFJlZi4kbW9kZU5hbWUkfVwiLCBidXQgaXQgZG9lcyBub3QgZXhpc3QuYFxuICAgICk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfSBlbHNlIGlmICghYnVuZGxlSWQpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IG1vZHVsZSA9ICFCVUlMRDQuaG90TW9kdWxlUmVwbGFjZW1lbnQgPyBjbXBNb2R1bGVzLmdldChidW5kbGVJZCkgOiBmYWxzZTtcbiAgaWYgKG1vZHVsZSkge1xuICAgIHJldHVybiBtb2R1bGVbZXhwb3J0TmFtZV07XG4gIH1cbiAgLyohX19TVEVOQ0lMX1NUQVRJQ19JTVBPUlRfU1dJVENIX18qL1xuICByZXR1cm4gaW1wb3J0KFxuICAgIC8qIEB2aXRlLWlnbm9yZSAqL1xuICAgIC8qIHdlYnBhY2tJbmNsdWRlOiAvXFwuZW50cnlcXC5qcyQvICovXG4gICAgLyogd2VicGFja0V4Y2x1ZGU6IC9cXC5zeXN0ZW1cXC5lbnRyeVxcLmpzJC8gKi9cbiAgICAvKiB3ZWJwYWNrTW9kZTogXCJsYXp5XCIgKi9cbiAgICBgLi8ke2J1bmRsZUlkfS5lbnRyeS5qcyR7QlVJTEQ0LmhvdE1vZHVsZVJlcGxhY2VtZW50ICYmIGhtclZlcnNpb25JZCA/IFwiP3MtaG1yPVwiICsgaG1yVmVyc2lvbklkIDogXCJcIn1gXG4gICkudGhlbigoaW1wb3J0ZWRNb2R1bGUpID0+IHtcbiAgICBpZiAoIUJVSUxENC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgY21wTW9kdWxlcy5zZXQoYnVuZGxlSWQsIGltcG9ydGVkTW9kdWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydGVkTW9kdWxlW2V4cG9ydE5hbWVdO1xuICB9LCBjb25zb2xlRXJyb3IpO1xufTtcblxuLy8gc3JjL2NsaWVudC9jbGllbnQtc3R5bGUudHNcbnZhciBzdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIG1vZGVSZXNvbHV0aW9uQ2hhaW4gPSBbXTtcblxuLy8gc3JjL2NsaWVudC9jbGllbnQtdGFzay1xdWV1ZS50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQ2IH0gZnJvbSBcIkBzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGFcIjtcblxuLy8gc3JjL3J1bnRpbWUvcnVudGltZS1jb25zdGFudHMudHNcbnZhciBDT05URU5UX1JFRl9JRCA9IFwiclwiO1xudmFyIE9SR19MT0NBVElPTl9JRCA9IFwib1wiO1xudmFyIFNMT1RfTk9ERV9JRCA9IFwic1wiO1xudmFyIFRFWFRfTk9ERV9JRCA9IFwidFwiO1xudmFyIEhZRFJBVEVfSUQgPSBcInMtaWRcIjtcbnZhciBIWURSQVRFRF9TVFlMRV9JRCA9IFwic3R5LWlkXCI7XG52YXIgSFlEUkFURV9DSElMRF9JRCA9IFwiYy1pZFwiO1xudmFyIEhZRFJBVEVEX0NTUyA9IFwie3Zpc2liaWxpdHk6aGlkZGVufS5oeWRyYXRlZHt2aXNpYmlsaXR5OmluaGVyaXR9XCI7XG52YXIgU0xPVF9GQl9DU1MgPSBcInNsb3QtZmJ7ZGlzcGxheTpjb250ZW50c31zbG90LWZiW2hpZGRlbl17ZGlzcGxheTpub25lfVwiO1xudmFyIFhMSU5LX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG52YXIgRk9STV9BU1NPQ0lBVEVEX0NVU1RPTV9FTEVNRU5UX0NBTExCQUNLUyA9IFtcbiAgXCJmb3JtQXNzb2NpYXRlZENhbGxiYWNrXCIsXG4gIFwiZm9ybVJlc2V0Q2FsbGJhY2tcIixcbiAgXCJmb3JtRGlzYWJsZWRDYWxsYmFja1wiLFxuICBcImZvcm1TdGF0ZVJlc3RvcmVDYWxsYmFja1wiXG5dO1xuXG4vLyBzcmMvY2xpZW50L2NsaWVudC13aW5kb3cudHNcbmltcG9ydCB7IEJVSUxEIGFzIEJVSUxENSB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG52YXIgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9O1xudmFyIGRvYyA9IHdpbi5kb2N1bWVudCB8fCB7IGhlYWQ6IHt9IH07XG52YXIgSCA9IHdpbi5IVE1MRWxlbWVudCB8fCBjbGFzcyB7XG59O1xudmFyIHBsdCA9IHtcbiAgJGZsYWdzJDogMCxcbiAgJHJlc291cmNlc1VybCQ6IFwiXCIsXG4gIGptcDogKGgyKSA9PiBoMigpLFxuICByYWY6IChoMikgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGgyKSxcbiAgYWVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gIHJlbDogKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSA9PiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpLFxuICBjZTogKGV2ZW50TmFtZSwgb3B0cykgPT4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgb3B0cylcbn07XG52YXIgc2V0UGxhdGZvcm1IZWxwZXJzID0gKGhlbHBlcnMpID0+IHtcbiAgT2JqZWN0LmFzc2lnbihwbHQsIGhlbHBlcnMpO1xufTtcbnZhciBzdXBwb3J0c1NoYWRvdyA9IEJVSUxENS5zaGFkb3dEb207XG52YXIgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgbGV0IHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zMiA9IGZhbHNlO1xuICB0cnkge1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJlXCIsXG4gICAgICBudWxsLFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zMjtcbn0pKCk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSAodikgPT4gUHJvbWlzZS5yZXNvbHZlKHYpO1xudmFyIHN1cHBvcnRzQ29uc3RydWN0YWJsZVN0eWxlc2hlZXRzID0gQlVJTEQ1LmNvbnN0cnVjdGFibGVDU1MgPyAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgdHJ5IHtcbiAgICBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgIHJldHVybiB0eXBlb2YgbmV3IENTU1N0eWxlU2hlZXQoKS5yZXBsYWNlU3luYyA9PT0gXCJmdW5jdGlvblwiO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSkoKSA6IGZhbHNlO1xuXG4vLyBzcmMvY2xpZW50L2NsaWVudC10YXNrLXF1ZXVlLnRzXG52YXIgcXVldWVDb25nZXN0aW9uID0gMDtcbnZhciBxdWV1ZVBlbmRpbmcgPSBmYWxzZTtcbnZhciBxdWV1ZURvbVJlYWRzID0gW107XG52YXIgcXVldWVEb21Xcml0ZXMgPSBbXTtcbnZhciBxdWV1ZURvbVdyaXRlc0xvdyA9IFtdO1xudmFyIHF1ZXVlVGFzayA9IChxdWV1ZSwgd3JpdGUpID0+IChjYikgPT4ge1xuICBxdWV1ZS5wdXNoKGNiKTtcbiAgaWYgKCFxdWV1ZVBlbmRpbmcpIHtcbiAgICBxdWV1ZVBlbmRpbmcgPSB0cnVlO1xuICAgIGlmICh3cml0ZSAmJiBwbHQuJGZsYWdzJCAmIDQgLyogcXVldWVTeW5jICovKSB7XG4gICAgICBuZXh0VGljayhmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgIH1cbiAgfVxufTtcbnZhciBjb25zdW1lID0gKHF1ZXVlKSA9PiB7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBxdWV1ZS5sZW5ndGg7IGkyKyspIHtcbiAgICB0cnkge1xuICAgICAgcXVldWVbaTJdKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG59O1xudmFyIGNvbnN1bWVUaW1lb3V0ID0gKHF1ZXVlLCB0aW1lb3V0KSA9PiB7XG4gIGxldCBpMiA9IDA7XG4gIGxldCB0cyA9IDA7XG4gIHdoaWxlIChpMiA8IHF1ZXVlLmxlbmd0aCAmJiAodHMgPSBwZXJmb3JtYW5jZS5ub3coKSkgPCB0aW1lb3V0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHF1ZXVlW2kyKytdKHRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGlmIChpMiA9PT0gcXVldWUubGVuZ3RoKSB7XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgfSBlbHNlIGlmIChpMiAhPT0gMCkge1xuICAgIHF1ZXVlLnNwbGljZSgwLCBpMik7XG4gIH1cbn07XG52YXIgZmx1c2ggPSAoKSA9PiB7XG4gIGlmIChCVUlMRDYuYXN5bmNRdWV1ZSkge1xuICAgIHF1ZXVlQ29uZ2VzdGlvbisrO1xuICB9XG4gIGNvbnN1bWUocXVldWVEb21SZWFkcyk7XG4gIGlmIChCVUlMRDYuYXN5bmNRdWV1ZSkge1xuICAgIGNvbnN0IHRpbWVvdXQgPSAocGx0LiRmbGFncyQgJiA2IC8qIHF1ZXVlTWFzayAqLykgPT09IDIgLyogYXBwTG9hZGVkICovID8gcGVyZm9ybWFuY2Uubm93KCkgKyAxNCAqIE1hdGguY2VpbChxdWV1ZUNvbmdlc3Rpb24gKiAoMSAvIDEwKSkgOiBJbmZpbml0eTtcbiAgICBjb25zdW1lVGltZW91dChxdWV1ZURvbVdyaXRlcywgdGltZW91dCk7XG4gICAgY29uc3VtZVRpbWVvdXQocXVldWVEb21Xcml0ZXNMb3csIHRpbWVvdXQpO1xuICAgIGlmIChxdWV1ZURvbVdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBxdWV1ZURvbVdyaXRlc0xvdy5wdXNoKC4uLnF1ZXVlRG9tV3JpdGVzKTtcbiAgICAgIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGlmIChxdWV1ZVBlbmRpbmcgPSBxdWV1ZURvbVJlYWRzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzTG93Lmxlbmd0aCA+IDApIHtcbiAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZUNvbmdlc3Rpb24gPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdW1lKHF1ZXVlRG9tV3JpdGVzKTtcbiAgICBpZiAocXVldWVQZW5kaW5nID0gcXVldWVEb21SZWFkcy5sZW5ndGggPiAwKSB7XG4gICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgbmV4dFRpY2sgPSAoY2IpID0+IHByb21pc2VSZXNvbHZlKCkudGhlbihjYik7XG52YXIgcmVhZFRhc2sgPSAvKiBAX19QVVJFX18gKi8gcXVldWVUYXNrKHF1ZXVlRG9tUmVhZHMsIGZhbHNlKTtcbnZhciB3cml0ZVRhc2sgPSAvKiBAX19QVVJFX18gKi8gcXVldWVUYXNrKHF1ZXVlRG9tV3JpdGVzLCB0cnVlKTtcblxuLy8gc3JjL2NsaWVudC9pbmRleC50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQyNywgRW52LCBOQU1FU1BBQ0UgYXMgTkFNRVNQQUNFMiB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG5cbi8vIHNyYy9ydW50aW1lL2Fzc2V0LXBhdGgudHNcbnZhciBnZXRBc3NldFBhdGggPSAocGF0aCkgPT4ge1xuICBjb25zdCBhc3NldFVybCA9IG5ldyBVUkwocGF0aCwgcGx0LiRyZXNvdXJjZXNVcmwkKTtcbiAgcmV0dXJuIGFzc2V0VXJsLm9yaWdpbiAhPT0gd2luLmxvY2F0aW9uLm9yaWdpbiA/IGFzc2V0VXJsLmhyZWYgOiBhc3NldFVybC5wYXRobmFtZTtcbn07XG52YXIgc2V0QXNzZXRQYXRoID0gKHBhdGgpID0+IHBsdC4kcmVzb3VyY2VzVXJsJCA9IHBhdGg7XG5cbi8vIHNyYy9ydW50aW1lL2Jvb3RzdHJhcC1jdXN0b20tZWxlbWVudC50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQyNCB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG5cbi8vIHNyYy91dGlscy9jb25zdGFudHMudHNcbnZhciBFTVBUWV9PQkogPSB7fTtcbnZhciBTVkdfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG52YXIgSFRNTF9OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG4vLyBzcmMvdXRpbHMvaGVscGVycy50c1xudmFyIGlzRGVmID0gKHYpID0+IHYgIT0gbnVsbDtcbnZhciBpc0NvbXBsZXhUeXBlID0gKG8pID0+IHtcbiAgbyA9IHR5cGVvZiBvO1xuICByZXR1cm4gbyA9PT0gXCJvYmplY3RcIiB8fCBvID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG4vLyBzcmMvdXRpbHMvcXVlcnktbm9uY2UtbWV0YS10YWctY29udGVudC50c1xuZnVuY3Rpb24gcXVlcnlOb25jZU1ldGFUYWdDb250ZW50KGRvYzIpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBkb2MyLmhlYWQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJjc3Atbm9uY2VcIl0nKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIikpICE9IG51bGwgPyBfYyA6IHZvaWQgMDtcbn1cblxuLy8gc3JjL3V0aWxzL3Jlc3VsdC50c1xudmFyIHJlc3VsdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChyZXN1bHRfZXhwb3J0cywge1xuICBlcnI6ICgpID0+IGVycixcbiAgbWFwOiAoKSA9PiBtYXAsXG4gIG9rOiAoKSA9PiBvayxcbiAgdW53cmFwOiAoKSA9PiB1bndyYXAsXG4gIHVud3JhcEVycjogKCkgPT4gdW53cmFwRXJyXG59KTtcbnZhciBvayA9ICh2YWx1ZSkgPT4gKHtcbiAgaXNPazogdHJ1ZSxcbiAgaXNFcnI6IGZhbHNlLFxuICB2YWx1ZVxufSk7XG52YXIgZXJyID0gKHZhbHVlKSA9PiAoe1xuICBpc09rOiBmYWxzZSxcbiAgaXNFcnI6IHRydWUsXG4gIHZhbHVlXG59KTtcbmZ1bmN0aW9uIG1hcChyZXN1bHQsIGZuKSB7XG4gIGlmIChyZXN1bHQuaXNPaykge1xuICAgIGNvbnN0IHZhbCA9IGZuKHJlc3VsdC52YWx1ZSk7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiB2YWwudGhlbigobmV3VmFsKSA9PiBvayhuZXdWYWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9rKHZhbCk7XG4gICAgfVxuICB9XG4gIGlmIChyZXN1bHQuaXNFcnIpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICByZXR1cm4gZXJyKHZhbHVlKTtcbiAgfVxuICB0aHJvdyBcInNob3VsZCBuZXZlciBnZXQgaGVyZVwiO1xufVxudmFyIHVud3JhcCA9IChyZXN1bHQpID0+IHtcbiAgaWYgKHJlc3VsdC5pc09rKSB7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyByZXN1bHQudmFsdWU7XG4gIH1cbn07XG52YXIgdW53cmFwRXJyID0gKHJlc3VsdCkgPT4ge1xuICBpZiAocmVzdWx0LmlzRXJyKSB7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyByZXN1bHQudmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9ydW50aW1lL2Nvbm5lY3RlZC1jYWxsYmFjay50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQyMSB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG5cbi8vIHNyYy9ydW50aW1lL2NsaWVudC1oeWRyYXRlLnRzXG5pbXBvcnQgeyBCVUlMRCBhcyBCVUlMRDkgfSBmcm9tIFwiQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YVwiO1xuXG4vLyBzcmMvcnVudGltZS9wcm9maWxlLnRzXG5pbXBvcnQgeyBCVUlMRCBhcyBCVUlMRDcgfSBmcm9tIFwiQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YVwiO1xudmFyIGkgPSAwO1xudmFyIGNyZWF0ZVRpbWUgPSAoZm5OYW1lLCB0YWdOYW1lID0gXCJcIikgPT4ge1xuICBpZiAoQlVJTEQ3LnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgIGNvbnN0IGtleSA9IGBzdDoke2ZuTmFtZX06JHt0YWdOYW1lfToke2krK31gO1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoa2V5KTtcbiAgICByZXR1cm4gKCkgPT4gcGVyZm9ybWFuY2UubWVhc3VyZShgW1N0ZW5jaWxdICR7Zm5OYW1lfSgpIDwke3RhZ05hbWV9PmAsIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG59O1xudmFyIHVuaXF1ZVRpbWUgPSAoa2V5LCBtZWFzdXJlVGV4dCkgPT4ge1xuICBpZiAoQlVJTEQ3LnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgIGlmIChwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKGtleSwgXCJtYXJrXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcGVyZm9ybWFuY2UubWFyayhrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUobWVhc3VyZVRleHQsIFwibWVhc3VyZVwiKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShtZWFzdXJlVGV4dCwga2V5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxufTtcbnZhciBpbnNwZWN0ID0gKHJlZikgPT4ge1xuICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihyZWYpO1xuICBpZiAoIWhvc3RSZWYpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IGZsYWdzID0gaG9zdFJlZi4kZmxhZ3MkO1xuICBjb25zdCBob3N0RWxlbWVudCA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXJDb3VudDogaG9zdFJlZi4kcmVuZGVyQ291bnQkLFxuICAgIGZsYWdzOiB7XG4gICAgICBoYXNSZW5kZXJlZDogISEoZmxhZ3MgJiAyIC8qIGhhc1JlbmRlcmVkICovKSxcbiAgICAgIGhhc0Nvbm5lY3RlZDogISEoZmxhZ3MgJiAxIC8qIGhhc0Nvbm5lY3RlZCAqLyksXG4gICAgICBpc1dhaXRpbmdGb3JDaGlsZHJlbjogISEoZmxhZ3MgJiA0IC8qIGlzV2FpdGluZ0ZvckNoaWxkcmVuICovKSxcbiAgICAgIGlzQ29uc3RydWN0aW5nSW5zdGFuY2U6ICEhKGZsYWdzICYgOCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovKSxcbiAgICAgIGlzUXVldWVkRm9yVXBkYXRlOiAhIShmbGFncyAmIDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovKSxcbiAgICAgIGhhc0luaXRpYWxpemVkQ29tcG9uZW50OiAhIShmbGFncyAmIDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovKSxcbiAgICAgIGhhc0xvYWRlZENvbXBvbmVudDogISEoZmxhZ3MgJiA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi8pLFxuICAgICAgaXNXYXRjaFJlYWR5OiAhIShmbGFncyAmIDEyOCAvKiBpc1dhdGNoUmVhZHkgKi8pLFxuICAgICAgaXNMaXN0ZW5SZWFkeTogISEoZmxhZ3MgJiAyNTYgLyogaXNMaXN0ZW5SZWFkeSAqLyksXG4gICAgICBuZWVkc1JlcmVuZGVyOiAhIShmbGFncyAmIDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKVxuICAgIH0sXG4gICAgaW5zdGFuY2VWYWx1ZXM6IGhvc3RSZWYuJGluc3RhbmNlVmFsdWVzJCxcbiAgICBhbmNlc3RvckNvbXBvbmVudDogaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkLFxuICAgIGhvc3RFbGVtZW50LFxuICAgIGxhenlJbnN0YW5jZTogaG9zdFJlZi4kbGF6eUluc3RhbmNlJCxcbiAgICB2bm9kZTogaG9zdFJlZi4kdm5vZGUkLFxuICAgIG1vZGVOYW1lOiBob3N0UmVmLiRtb2RlTmFtZSQsXG4gICAgb25SZWFkeVByb21pc2U6IGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCxcbiAgICBvblJlYWR5UmVzb2x2ZTogaG9zdFJlZi4kb25SZWFkeVJlc29sdmUkLFxuICAgIG9uSW5zdGFuY2VQcm9taXNlOiBob3N0UmVmLiRvbkluc3RhbmNlUHJvbWlzZSQsXG4gICAgb25JbnN0YW5jZVJlc29sdmU6IGhvc3RSZWYuJG9uSW5zdGFuY2VSZXNvbHZlJCxcbiAgICBvblJlbmRlclJlc29sdmU6IGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQsXG4gICAgcXVldWVkTGlzdGVuZXJzOiBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkLFxuICAgIHJtTGlzdGVuZXJzOiBob3N0UmVmLiRybUxpc3RlbmVycyQsXG4gICAgW1wicy1pZFwiXTogaG9zdEVsZW1lbnRbXCJzLWlkXCJdLFxuICAgIFtcInMtY3JcIl06IGhvc3RFbGVtZW50W1wicy1jclwiXSxcbiAgICBbXCJzLWxyXCJdOiBob3N0RWxlbWVudFtcInMtbHJcIl0sXG4gICAgW1wicy1wXCJdOiBob3N0RWxlbWVudFtcInMtcFwiXSxcbiAgICBbXCJzLXJjXCJdOiBob3N0RWxlbWVudFtcInMtcmNcIl0sXG4gICAgW1wicy1zY1wiXTogaG9zdEVsZW1lbnRbXCJzLXNjXCJdXG4gIH07XG59O1xudmFyIGluc3RhbGxEZXZUb29scyA9ICgpID0+IHtcbiAgaWYgKEJVSUxENy5kZXZUb29scykge1xuICAgIGNvbnN0IHN0ZW5jaWwgPSB3aW4uc3RlbmNpbCA9IHdpbi5zdGVuY2lsIHx8IHt9O1xuICAgIGNvbnN0IG9yaWdpbmFsSW5zcGVjdCA9IHN0ZW5jaWwuaW5zcGVjdDtcbiAgICBzdGVuY2lsLmluc3BlY3QgPSAocmVmKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gaW5zcGVjdChyZWYpO1xuICAgICAgaWYgKCFyZXN1bHQgJiYgdHlwZW9mIG9yaWdpbmFsSW5zcGVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlc3VsdCA9IG9yaWdpbmFsSW5zcGVjdChyZWYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvcnVudGltZS92ZG9tL2gudHNcbmltcG9ydCB7IEJVSUxEIGFzIEJVSUxEOCB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG52YXIgaCA9IChub2RlTmFtZSwgdm5vZGVEYXRhLCAuLi5jaGlsZHJlbikgPT4ge1xuICBsZXQgY2hpbGQgPSBudWxsO1xuICBsZXQga2V5ID0gbnVsbDtcbiAgbGV0IHNsb3ROYW1lID0gbnVsbDtcbiAgbGV0IHNpbXBsZSA9IGZhbHNlO1xuICBsZXQgbGFzdFNpbXBsZSA9IGZhbHNlO1xuICBjb25zdCB2Tm9kZUNoaWxkcmVuID0gW107XG4gIGNvbnN0IHdhbGsgPSAoYykgPT4ge1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjLmxlbmd0aDsgaTIrKykge1xuICAgICAgY2hpbGQgPSBjW2kyXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICB3YWxrKGNoaWxkKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQgIT0gbnVsbCAmJiB0eXBlb2YgY2hpbGQgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGlmIChzaW1wbGUgPSB0eXBlb2Ygbm9kZU5hbWUgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNDb21wbGV4VHlwZShjaGlsZCkpIHtcbiAgICAgICAgICBjaGlsZCA9IFN0cmluZyhjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQlVJTEQ4LmlzRGV2ICYmIHR5cGVvZiBub2RlTmFtZSAhPT0gXCJmdW5jdGlvblwiICYmIGNoaWxkLiRmbGFncyQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnNvbGVEZXZFcnJvcihgdk5vZGUgcGFzc2VkIGFzIGNoaWxkcmVuIGhhcyB1bmV4cGVjdGVkIHR5cGUuXG5NYWtlIHN1cmUgaXQncyB1c2luZyB0aGUgY29ycmVjdCBoKCkgZnVuY3Rpb24uXG5FbXB0eSBvYmplY3RzIGNhbiBhbHNvIGJlIHRoZSBjYXVzZSwgbG9vayBmb3IgSlNYIGNvbW1lbnRzIHRoYXQgYmVjYW1lIG9iamVjdHMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbXBsZSAmJiBsYXN0U2ltcGxlKSB7XG4gICAgICAgICAgdk5vZGVDaGlsZHJlblt2Tm9kZUNoaWxkcmVuLmxlbmd0aCAtIDFdLiR0ZXh0JCArPSBjaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2Tm9kZUNoaWxkcmVuLnB1c2goc2ltcGxlID8gbmV3Vk5vZGUobnVsbCwgY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTaW1wbGUgPSBzaW1wbGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB3YWxrKGNoaWxkcmVuKTtcbiAgaWYgKHZub2RlRGF0YSkge1xuICAgIGlmIChCVUlMRDguaXNEZXYgJiYgbm9kZU5hbWUgPT09IFwiaW5wdXRcIikge1xuICAgICAgdmFsaWRhdGVJbnB1dFByb3BlcnRpZXModm5vZGVEYXRhKTtcbiAgICB9XG4gICAgaWYgKEJVSUxEOC52ZG9tS2V5ICYmIHZub2RlRGF0YS5rZXkpIHtcbiAgICAgIGtleSA9IHZub2RlRGF0YS5rZXk7XG4gICAgfVxuICAgIGlmIChCVUlMRDguc2xvdFJlbG9jYXRpb24gJiYgdm5vZGVEYXRhLm5hbWUpIHtcbiAgICAgIHNsb3ROYW1lID0gdm5vZGVEYXRhLm5hbWU7XG4gICAgfVxuICAgIGlmIChCVUlMRDgudmRvbUNsYXNzKSB7XG4gICAgICBjb25zdCBjbGFzc0RhdGEgPSB2bm9kZURhdGEuY2xhc3NOYW1lIHx8IHZub2RlRGF0YS5jbGFzcztcbiAgICAgIGlmIChjbGFzc0RhdGEpIHtcbiAgICAgICAgdm5vZGVEYXRhLmNsYXNzID0gdHlwZW9mIGNsYXNzRGF0YSAhPT0gXCJvYmplY3RcIiA/IGNsYXNzRGF0YSA6IE9iamVjdC5rZXlzKGNsYXNzRGF0YSkuZmlsdGVyKChrKSA9PiBjbGFzc0RhdGFba10pLmpvaW4oXCIgXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoQlVJTEQ4LmlzRGV2ICYmIHZOb2RlQ2hpbGRyZW4uc29tZShpc0hvc3QpKSB7XG4gICAgY29uc29sZURldkVycm9yKGBUaGUgPEhvc3Q+IG11c3QgYmUgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudC4gTWFrZSBzdXJlOlxuLSBZb3UgYXJlIE5PVCB1c2luZyBob3N0RGF0YSgpIGFuZCA8SG9zdD4gaW4gdGhlIHNhbWUgY29tcG9uZW50LlxuLSA8SG9zdD4gaXMgdXNlZCBvbmNlLCBhbmQgaXQncyB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50IG9mIHRoZSByZW5kZXIoKSBmdW5jdGlvbi5gKTtcbiAgfVxuICBpZiAoQlVJTEQ4LnZkb21GdW5jdGlvbmFsICYmIHR5cGVvZiBub2RlTmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIG5vZGVOYW1lKFxuICAgICAgdm5vZGVEYXRhID09PSBudWxsID8ge30gOiB2bm9kZURhdGEsXG4gICAgICB2Tm9kZUNoaWxkcmVuLFxuICAgICAgdmRvbUZuVXRpbHNcbiAgICApO1xuICB9XG4gIGNvbnN0IHZub2RlID0gbmV3Vk5vZGUobm9kZU5hbWUsIG51bGwpO1xuICB2bm9kZS4kYXR0cnMkID0gdm5vZGVEYXRhO1xuICBpZiAodk5vZGVDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgdm5vZGUuJGNoaWxkcmVuJCA9IHZOb2RlQ2hpbGRyZW47XG4gIH1cbiAgaWYgKEJVSUxEOC52ZG9tS2V5KSB7XG4gICAgdm5vZGUuJGtleSQgPSBrZXk7XG4gIH1cbiAgaWYgKEJVSUxEOC5zbG90UmVsb2NhdGlvbikge1xuICAgIHZub2RlLiRuYW1lJCA9IHNsb3ROYW1lO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn07XG52YXIgbmV3Vk5vZGUgPSAodGFnLCB0ZXh0KSA9PiB7XG4gIGNvbnN0IHZub2RlID0ge1xuICAgICRmbGFncyQ6IDAsXG4gICAgJHRhZyQ6IHRhZyxcbiAgICAkdGV4dCQ6IHRleHQsXG4gICAgJGVsbSQ6IG51bGwsXG4gICAgJGNoaWxkcmVuJDogbnVsbFxuICB9O1xuICBpZiAoQlVJTEQ4LnZkb21BdHRyaWJ1dGUpIHtcbiAgICB2bm9kZS4kYXR0cnMkID0gbnVsbDtcbiAgfVxuICBpZiAoQlVJTEQ4LnZkb21LZXkpIHtcbiAgICB2bm9kZS4ka2V5JCA9IG51bGw7XG4gIH1cbiAgaWYgKEJVSUxEOC5zbG90UmVsb2NhdGlvbikge1xuICAgIHZub2RlLiRuYW1lJCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufTtcbnZhciBIb3N0ID0ge307XG52YXIgaXNIb3N0ID0gKG5vZGUpID0+IG5vZGUgJiYgbm9kZS4kdGFnJCA9PT0gSG9zdDtcbnZhciB2ZG9tRm5VdGlscyA9IHtcbiAgZm9yRWFjaDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykuZm9yRWFjaChjYiksXG4gIG1hcDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykubWFwKGNiKS5tYXAoY29udmVydFRvUHJpdmF0ZSlcbn07XG52YXIgY29udmVydFRvUHVibGljID0gKG5vZGUpID0+ICh7XG4gIHZhdHRyczogbm9kZS4kYXR0cnMkLFxuICB2Y2hpbGRyZW46IG5vZGUuJGNoaWxkcmVuJCxcbiAgdmtleTogbm9kZS4ka2V5JCxcbiAgdm5hbWU6IG5vZGUuJG5hbWUkLFxuICB2dGFnOiBub2RlLiR0YWckLFxuICB2dGV4dDogbm9kZS4kdGV4dCRcbn0pO1xudmFyIGNvbnZlcnRUb1ByaXZhdGUgPSAobm9kZSkgPT4ge1xuICBpZiAodHlwZW9mIG5vZGUudnRhZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3Qgdm5vZGVEYXRhID0geyAuLi5ub2RlLnZhdHRycyB9O1xuICAgIGlmIChub2RlLnZrZXkpIHtcbiAgICAgIHZub2RlRGF0YS5rZXkgPSBub2RlLnZrZXk7XG4gICAgfVxuICAgIGlmIChub2RlLnZuYW1lKSB7XG4gICAgICB2bm9kZURhdGEubmFtZSA9IG5vZGUudm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBoKG5vZGUudnRhZywgdm5vZGVEYXRhLCAuLi5ub2RlLnZjaGlsZHJlbiB8fCBbXSk7XG4gIH1cbiAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShub2RlLnZ0YWcsIG5vZGUudnRleHQpO1xuICB2bm9kZS4kYXR0cnMkID0gbm9kZS52YXR0cnM7XG4gIHZub2RlLiRjaGlsZHJlbiQgPSBub2RlLnZjaGlsZHJlbjtcbiAgdm5vZGUuJGtleSQgPSBub2RlLnZrZXk7XG4gIHZub2RlLiRuYW1lJCA9IG5vZGUudm5hbWU7XG4gIHJldHVybiB2bm9kZTtcbn07XG52YXIgdmFsaWRhdGVJbnB1dFByb3BlcnRpZXMgPSAoaW5wdXRFbG0pID0+IHtcbiAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhpbnB1dEVsbSk7XG4gIGNvbnN0IHZhbHVlID0gcHJvcHMuaW5kZXhPZihcInZhbHVlXCIpO1xuICBpZiAodmFsdWUgPT09IC0xKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR5cGVJbmRleCA9IHByb3BzLmluZGV4T2YoXCJ0eXBlXCIpO1xuICBjb25zdCBtaW5JbmRleCA9IHByb3BzLmluZGV4T2YoXCJtaW5cIik7XG4gIGNvbnN0IG1heEluZGV4ID0gcHJvcHMuaW5kZXhPZihcIm1heFwiKTtcbiAgY29uc3Qgc3RlcEluZGV4ID0gcHJvcHMuaW5kZXhPZihcInN0ZXBcIik7XG4gIGlmICh2YWx1ZSA8IHR5cGVJbmRleCB8fCB2YWx1ZSA8IG1pbkluZGV4IHx8IHZhbHVlIDwgbWF4SW5kZXggfHwgdmFsdWUgPCBzdGVwSW5kZXgpIHtcbiAgICBjb25zb2xlRGV2V2FybihgVGhlIFwidmFsdWVcIiBwcm9wIG9mIDxpbnB1dD4gc2hvdWxkIGJlIHNldCBhZnRlciBcIm1pblwiLCBcIm1heFwiLCBcInR5cGVcIiBhbmQgXCJzdGVwXCJgKTtcbiAgfVxufTtcblxuLy8gc3JjL3J1bnRpbWUvY2xpZW50LWh5ZHJhdGUudHNcbnZhciBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZSA9IChob3N0RWxtLCB0YWdOYW1lLCBob3N0SWQsIGhvc3RSZWYpID0+IHtcbiAgY29uc3QgZW5kSHlkcmF0ZSA9IGNyZWF0ZVRpbWUoXCJoeWRyYXRlQ2xpZW50XCIsIHRhZ05hbWUpO1xuICBjb25zdCBzaGFkb3dSb290ID0gaG9zdEVsbS5zaGFkb3dSb290O1xuICBjb25zdCBjaGlsZFJlbmRlck5vZGVzID0gW107XG4gIGNvbnN0IHNsb3ROb2RlcyA9IFtdO1xuICBjb25zdCBzaGFkb3dSb290Tm9kZXMgPSBCVUlMRDkuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3QgPyBbXSA6IG51bGw7XG4gIGNvbnN0IHZub2RlID0gaG9zdFJlZi4kdm5vZGUkID0gbmV3Vk5vZGUodGFnTmFtZSwgbnVsbCk7XG4gIGlmICghcGx0LiRvcmdMb2NOb2RlcyQpIHtcbiAgICBpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlKGRvYy5ib2R5LCBwbHQuJG9yZ0xvY05vZGVzJCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICB9XG4gIGhvc3RFbG1bSFlEUkFURV9JRF0gPSBob3N0SWQ7XG4gIGhvc3RFbG0ucmVtb3ZlQXR0cmlidXRlKEhZRFJBVEVfSUQpO1xuICBjbGllbnRIeWRyYXRlKHZub2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgaG9zdEVsbSwgaG9zdElkKTtcbiAgY2hpbGRSZW5kZXJOb2Rlcy5tYXAoKGMpID0+IHtcbiAgICBjb25zdCBvcmdMb2NhdGlvbklkID0gYy4kaG9zdElkJCArIFwiLlwiICsgYy4kbm9kZUlkJDtcbiAgICBjb25zdCBvcmdMb2NhdGlvbk5vZGUgPSBwbHQuJG9yZ0xvY05vZGVzJC5nZXQob3JnTG9jYXRpb25JZCk7XG4gICAgY29uc3Qgbm9kZSA9IGMuJGVsbSQ7XG4gICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBvcmdMb2NhdGlvbk5vZGVbXCJzLWVuXCJdID09PSBcIlwiKSB7XG4gICAgICBvcmdMb2NhdGlvbk5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgb3JnTG9jYXRpb25Ob2RlLm5leHRTaWJsaW5nKTtcbiAgICB9XG4gICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICBub2RlW1wicy1oblwiXSA9IHRhZ05hbWU7XG4gICAgICBpZiAob3JnTG9jYXRpb25Ob2RlKSB7XG4gICAgICAgIG5vZGVbXCJzLW9sXCJdID0gb3JnTG9jYXRpb25Ob2RlO1xuICAgICAgICBub2RlW1wicy1vbFwiXVtcInMtbnJcIl0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBwbHQuJG9yZ0xvY05vZGVzJC5kZWxldGUob3JnTG9jYXRpb25JZCk7XG4gIH0pO1xuICBpZiAoQlVJTEQ5LnNoYWRvd0RvbSAmJiBzaGFkb3dSb290KSB7XG4gICAgc2hhZG93Um9vdE5vZGVzLm1hcCgoc2hhZG93Um9vdE5vZGUpID0+IHtcbiAgICAgIGlmIChzaGFkb3dSb290Tm9kZSkge1xuICAgICAgICBzaGFkb3dSb290LmFwcGVuZENoaWxkKHNoYWRvd1Jvb3ROb2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBlbmRIeWRyYXRlKCk7XG59O1xudmFyIGNsaWVudEh5ZHJhdGUgPSAocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLCBob3N0SWQpID0+IHtcbiAgbGV0IGNoaWxkTm9kZVR5cGU7XG4gIGxldCBjaGlsZElkU3BsdDtcbiAgbGV0IGNoaWxkVk5vZGU7XG4gIGxldCBpMjtcbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICBjaGlsZE5vZGVUeXBlID0gbm9kZS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCk7XG4gICAgaWYgKGNoaWxkTm9kZVR5cGUpIHtcbiAgICAgIGNoaWxkSWRTcGx0ID0gY2hpbGROb2RlVHlwZS5zcGxpdChcIi5cIik7XG4gICAgICBpZiAoY2hpbGRJZFNwbHRbMF0gPT09IGhvc3RJZCB8fCBjaGlsZElkU3BsdFswXSA9PT0gXCIwXCIpIHtcbiAgICAgICAgY2hpbGRWTm9kZSA9IHtcbiAgICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAgICRob3N0SWQkOiBjaGlsZElkU3BsdFswXSxcbiAgICAgICAgICAkbm9kZUlkJDogY2hpbGRJZFNwbHRbMV0sXG4gICAgICAgICAgJGRlcHRoJDogY2hpbGRJZFNwbHRbMl0sXG4gICAgICAgICAgJGluZGV4JDogY2hpbGRJZFNwbHRbM10sXG4gICAgICAgICAgJHRhZyQ6IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICRlbG0kOiBub2RlLFxuICAgICAgICAgICRhdHRycyQ6IG51bGwsXG4gICAgICAgICAgJGNoaWxkcmVuJDogbnVsbCxcbiAgICAgICAgICAka2V5JDogbnVsbCxcbiAgICAgICAgICAkbmFtZSQ6IG51bGwsXG4gICAgICAgICAgJHRleHQkOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkUmVuZGVyTm9kZXMucHVzaChjaGlsZFZOb2RlKTtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCk7XG4gICAgICAgIGlmICghcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCkge1xuICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICBwYXJlbnRWTm9kZSA9IGNoaWxkVk5vZGU7XG4gICAgICAgIGlmIChzaGFkb3dSb290Tm9kZXMgJiYgY2hpbGRWTm9kZS4kZGVwdGgkID09PSBcIjBcIikge1xuICAgICAgICAgIHNoYWRvd1Jvb3ROb2Rlc1tjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZS4kZWxtJDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkyID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICAgIGNsaWVudEh5ZHJhdGUoXG4gICAgICAgIHBhcmVudFZOb2RlLFxuICAgICAgICBjaGlsZFJlbmRlck5vZGVzLFxuICAgICAgICBzbG90Tm9kZXMsXG4gICAgICAgIHNoYWRvd1Jvb3ROb2RlcyxcbiAgICAgICAgaG9zdEVsbSxcbiAgICAgICAgbm9kZS5jaGlsZE5vZGVzW2kyXSxcbiAgICAgICAgaG9zdElkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobm9kZS5zaGFkb3dSb290KSB7XG4gICAgICBmb3IgKGkyID0gbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgICBjbGllbnRIeWRyYXRlKFxuICAgICAgICAgIHBhcmVudFZOb2RlLFxuICAgICAgICAgIGNoaWxkUmVuZGVyTm9kZXMsXG4gICAgICAgICAgc2xvdE5vZGVzLFxuICAgICAgICAgIHNoYWRvd1Jvb3ROb2RlcyxcbiAgICAgICAgICBob3N0RWxtLFxuICAgICAgICAgIG5vZGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzW2kyXSxcbiAgICAgICAgICBob3N0SWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDb21tZW50Tm9kZSAqLykge1xuICAgIGNoaWxkSWRTcGx0ID0gbm9kZS5ub2RlVmFsdWUuc3BsaXQoXCIuXCIpO1xuICAgIGlmIChjaGlsZElkU3BsdFsxXSA9PT0gaG9zdElkIHx8IGNoaWxkSWRTcGx0WzFdID09PSBcIjBcIikge1xuICAgICAgY2hpbGROb2RlVHlwZSA9IGNoaWxkSWRTcGx0WzBdO1xuICAgICAgY2hpbGRWTm9kZSA9IHtcbiAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgJGhvc3RJZCQ6IGNoaWxkSWRTcGx0WzFdLFxuICAgICAgICAkbm9kZUlkJDogY2hpbGRJZFNwbHRbMl0sXG4gICAgICAgICRkZXB0aCQ6IGNoaWxkSWRTcGx0WzNdLFxuICAgICAgICAkaW5kZXgkOiBjaGlsZElkU3BsdFs0XSxcbiAgICAgICAgJGVsbSQ6IG5vZGUsXG4gICAgICAgICRhdHRycyQ6IG51bGwsXG4gICAgICAgICRjaGlsZHJlbiQ6IG51bGwsXG4gICAgICAgICRrZXkkOiBudWxsLFxuICAgICAgICAkbmFtZSQ6IG51bGwsXG4gICAgICAgICR0YWckOiBudWxsLFxuICAgICAgICAkdGV4dCQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAoY2hpbGROb2RlVHlwZSA9PT0gVEVYVF9OT0RFX0lEKSB7XG4gICAgICAgIGNoaWxkVk5vZGUuJGVsbSQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoY2hpbGRWTm9kZS4kZWxtJCAmJiBjaGlsZFZOb2RlLiRlbG0kLm5vZGVUeXBlID09PSAzIC8qIFRleHROb2RlICovKSB7XG4gICAgICAgICAgY2hpbGRWTm9kZS4kdGV4dCQgPSBjaGlsZFZOb2RlLiRlbG0kLnRleHRDb250ZW50O1xuICAgICAgICAgIGNoaWxkUmVuZGVyTm9kZXMucHVzaChjaGlsZFZOb2RlKTtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgIGlmICghcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCkge1xuICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgIGlmIChzaGFkb3dSb290Tm9kZXMgJiYgY2hpbGRWTm9kZS4kZGVwdGgkID09PSBcIjBcIikge1xuICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGlsZFZOb2RlLiRob3N0SWQkID09PSBob3N0SWQpIHtcbiAgICAgICAgaWYgKGNoaWxkTm9kZVR5cGUgPT09IFNMT1RfTk9ERV9JRCkge1xuICAgICAgICAgIGNoaWxkVk5vZGUuJHRhZyQgPSBcInNsb3RcIjtcbiAgICAgICAgICBpZiAoY2hpbGRJZFNwbHRbNV0pIHtcbiAgICAgICAgICAgIG5vZGVbXCJzLXNuXCJdID0gY2hpbGRWTm9kZS4kbmFtZSQgPSBjaGlsZElkU3BsdFs1XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZVtcInMtc25cIl0gPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlW1wicy1zclwiXSA9IHRydWU7XG4gICAgICAgICAgaWYgKEJVSUxEOS5zaGFkb3dEb20gJiYgc2hhZG93Um9vdE5vZGVzKSB7XG4gICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kID0gZG9jLmNyZWF0ZUVsZW1lbnQoY2hpbGRWTm9kZS4kdGFnJCk7XG4gICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kbmFtZSQpIHtcbiAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kZWxtJC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIGNoaWxkVk5vZGUuJG5hbWUkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGRWTm9kZS4kZWxtJCwgbm9kZSk7XG4gICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgaWYgKGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzbG90Tm9kZXMucHVzaChjaGlsZFZOb2RlKTtcbiAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZE5vZGVUeXBlID09PSBDT05URU5UX1JFRl9JRCkge1xuICAgICAgICAgIGlmIChCVUlMRDkuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEJVSUxEOS5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAgICAgaG9zdEVsbVtcInMtY3JcIl0gPSBub2RlO1xuICAgICAgICAgICAgbm9kZVtcInMtY25cIl0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWTm9kZSAmJiBwYXJlbnRWTm9kZS4kdGFnJCA9PT0gXCJzdHlsZVwiKSB7XG4gICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShudWxsLCBub2RlLnRleHRDb250ZW50KTtcbiAgICB2bm9kZS4kZWxtJCA9IG5vZGU7XG4gICAgdm5vZGUuJGluZGV4JCA9IFwiMFwiO1xuICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbdm5vZGVdO1xuICB9XG59O1xudmFyIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUgPSAobm9kZSwgb3JnTG9jTm9kZXMpID0+IHtcbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICBsZXQgaTIgPSAwO1xuICAgIGZvciAoOyBpMiA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUobm9kZS5jaGlsZE5vZGVzW2kyXSwgb3JnTG9jTm9kZXMpO1xuICAgIH1cbiAgICBpZiAobm9kZS5zaGFkb3dSb290KSB7XG4gICAgICBmb3IgKGkyID0gMDsgaTIgPCBub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tpMl0sIG9yZ0xvY05vZGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDb21tZW50Tm9kZSAqLykge1xuICAgIGNvbnN0IGNoaWxkSWRTcGx0ID0gbm9kZS5ub2RlVmFsdWUuc3BsaXQoXCIuXCIpO1xuICAgIGlmIChjaGlsZElkU3BsdFswXSA9PT0gT1JHX0xPQ0FUSU9OX0lEKSB7XG4gICAgICBvcmdMb2NOb2Rlcy5zZXQoY2hpbGRJZFNwbHRbMV0gKyBcIi5cIiArIGNoaWxkSWRTcGx0WzJdLCBub2RlKTtcbiAgICAgIG5vZGUubm9kZVZhbHVlID0gXCJcIjtcbiAgICAgIG5vZGVbXCJzLWVuXCJdID0gY2hpbGRJZFNwbHRbM107XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcnVudGltZS9pbml0aWFsaXplLWNvbXBvbmVudC50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQyMCB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG5cbi8vIHNyYy9ydW50aW1lL21vZGUudHNcbnZhciBjb21wdXRlTW9kZSA9IChlbG0pID0+IG1vZGVSZXNvbHV0aW9uQ2hhaW4ubWFwKChoMikgPT4gaDIoZWxtKSkuZmluZCgobSkgPT4gISFtKTtcbnZhciBzZXRNb2RlID0gKGhhbmRsZXIpID0+IG1vZGVSZXNvbHV0aW9uQ2hhaW4ucHVzaChoYW5kbGVyKTtcbnZhciBnZXRNb2RlID0gKHJlZikgPT4gZ2V0SG9zdFJlZihyZWYpLiRtb2RlTmFtZSQ7XG5cbi8vIHNyYy9ydW50aW1lL3Byb3h5LWNvbXBvbmVudC50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQxOSB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG5cbi8vIHNyYy9ydW50aW1lL3NldC12YWx1ZS50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQxOCB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG5cbi8vIHNyYy9ydW50aW1lL3BhcnNlLXByb3BlcnR5LXZhbHVlLnRzXG5pbXBvcnQgeyBCVUlMRCBhcyBCVUlMRDEwIH0gZnJvbSBcIkBzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGFcIjtcbnZhciBwYXJzZVByb3BlcnR5VmFsdWUgPSAocHJvcFZhbHVlLCBwcm9wVHlwZSkgPT4ge1xuICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgIWlzQ29tcGxleFR5cGUocHJvcFZhbHVlKSkge1xuICAgIGlmIChCVUlMRDEwLnByb3BCb29sZWFuICYmIHByb3BUeXBlICYgNCAvKiBCb29sZWFuICovKSB7XG4gICAgICByZXR1cm4gcHJvcFZhbHVlID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHByb3BWYWx1ZSA9PT0gXCJcIiB8fCAhIXByb3BWYWx1ZTtcbiAgICB9XG4gICAgaWYgKEJVSUxEMTAucHJvcE51bWJlciAmJiBwcm9wVHlwZSAmIDIgLyogTnVtYmVyICovKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChwcm9wVmFsdWUpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQxMC5wcm9wU3RyaW5nICYmIHByb3BUeXBlICYgMSAvKiBTdHJpbmcgKi8pIHtcbiAgICAgIHJldHVybiBTdHJpbmcocHJvcFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgfVxuICByZXR1cm4gcHJvcFZhbHVlO1xufTtcblxuLy8gc3JjL3J1bnRpbWUvdXBkYXRlLWNvbXBvbmVudC50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQxNywgTkFNRVNQQUNFIH0gZnJvbSBcIkBzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGFcIjtcblxuLy8gc3JjL3J1bnRpbWUvZXZlbnQtZW1pdHRlci50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQxMiB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG5cbi8vIHNyYy9ydW50aW1lL2VsZW1lbnQudHNcbmltcG9ydCB7IEJVSUxEIGFzIEJVSUxEMTEgfSBmcm9tIFwiQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YVwiO1xudmFyIGdldEVsZW1lbnQgPSAocmVmKSA9PiBCVUlMRDExLmxhenlMb2FkID8gZ2V0SG9zdFJlZihyZWYpLiRob3N0RWxlbWVudCQgOiByZWY7XG5cbi8vIHNyYy9ydW50aW1lL2V2ZW50LWVtaXR0ZXIudHNcbnZhciBjcmVhdGVFdmVudCA9IChyZWYsIG5hbWUsIGZsYWdzKSA9PiB7XG4gIGNvbnN0IGVsbSA9IGdldEVsZW1lbnQocmVmKTtcbiAgcmV0dXJuIHtcbiAgICBlbWl0OiAoZGV0YWlsKSA9PiB7XG4gICAgICBpZiAoQlVJTEQxMi5pc0RldiAmJiAhZWxtLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIGNvbnNvbGVEZXZXYXJuKGBUaGUgXCIke25hbWV9XCIgZXZlbnQgd2FzIGVtaXR0ZWQsIGJ1dCB0aGUgZGlzcGF0Y2hlciBub2RlIGlzIG5vIGxvbmdlciBjb25uZWN0ZWQgdG8gdGhlIGRvbS5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbWl0RXZlbnQoZWxtLCBuYW1lLCB7XG4gICAgICAgIGJ1YmJsZXM6ICEhKGZsYWdzICYgNCAvKiBCdWJibGVzICovKSxcbiAgICAgICAgY29tcG9zZWQ6ICEhKGZsYWdzICYgMiAvKiBDb21wb3NlZCAqLyksXG4gICAgICAgIGNhbmNlbGFibGU6ICEhKGZsYWdzICYgMSAvKiBDYW5jZWxsYWJsZSAqLyksXG4gICAgICAgIGRldGFpbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbnZhciBlbWl0RXZlbnQgPSAoZWxtLCBuYW1lLCBvcHRzKSA9PiB7XG4gIGNvbnN0IGV2ID0gcGx0LmNlKG5hbWUsIG9wdHMpO1xuICBlbG0uZGlzcGF0Y2hFdmVudChldik7XG4gIHJldHVybiBldjtcbn07XG5cbi8vIHNyYy9ydW50aW1lL3N0eWxlcy50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQxMyB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG52YXIgcm9vdEFwcGxpZWRTdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciByZWdpc3RlclN0eWxlID0gKHNjb3BlSWQyLCBjc3NUZXh0LCBhbGxvd0NTKSA9PiB7XG4gIGxldCBzdHlsZSA9IHN0eWxlcy5nZXQoc2NvcGVJZDIpO1xuICBpZiAoc3VwcG9ydHNDb25zdHJ1Y3RhYmxlU3R5bGVzaGVldHMgJiYgYWxsb3dDUykge1xuICAgIHN0eWxlID0gc3R5bGUgfHwgbmV3IENTU1N0eWxlU2hlZXQoKTtcbiAgICBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzdHlsZSA9IGNzc1RleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLnJlcGxhY2VTeW5jKGNzc1RleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGNzc1RleHQ7XG4gIH1cbiAgc3R5bGVzLnNldChzY29wZUlkMiwgc3R5bGUpO1xufTtcbnZhciBhZGRTdHlsZSA9IChzdHlsZUNvbnRhaW5lck5vZGUsIGNtcE1ldGEsIG1vZGUpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBzY29wZUlkMiA9IGdldFNjb3BlSWQoY21wTWV0YSwgbW9kZSk7XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVzLmdldChzY29wZUlkMik7XG4gIGlmICghQlVJTEQxMy5hdHRhY2hTdHlsZXMpIHtcbiAgICByZXR1cm4gc2NvcGVJZDI7XG4gIH1cbiAgc3R5bGVDb250YWluZXJOb2RlID0gc3R5bGVDb250YWluZXJOb2RlLm5vZGVUeXBlID09PSAxMSAvKiBEb2N1bWVudEZyYWdtZW50ICovID8gc3R5bGVDb250YWluZXJOb2RlIDogZG9jO1xuICBpZiAoc3R5bGUpIHtcbiAgICBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzdHlsZUNvbnRhaW5lck5vZGUgPSBzdHlsZUNvbnRhaW5lck5vZGUuaGVhZCB8fCBzdHlsZUNvbnRhaW5lck5vZGU7XG4gICAgICBsZXQgYXBwbGllZFN0eWxlcyA9IHJvb3RBcHBsaWVkU3R5bGVzLmdldChzdHlsZUNvbnRhaW5lck5vZGUpO1xuICAgICAgbGV0IHN0eWxlRWxtO1xuICAgICAgaWYgKCFhcHBsaWVkU3R5bGVzKSB7XG4gICAgICAgIHJvb3RBcHBsaWVkU3R5bGVzLnNldChzdHlsZUNvbnRhaW5lck5vZGUsIGFwcGxpZWRTdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXBwbGllZFN0eWxlcy5oYXMoc2NvcGVJZDIpKSB7XG4gICAgICAgIGlmIChCVUlMRDEzLmh5ZHJhdGVDbGllbnRTaWRlICYmIHN0eWxlQ29udGFpbmVyTm9kZS5ob3N0ICYmIChzdHlsZUVsbSA9IHN0eWxlQ29udGFpbmVyTm9kZS5xdWVyeVNlbGVjdG9yKGBbJHtIWURSQVRFRF9TVFlMRV9JRH09XCIke3Njb3BlSWQyfVwiXWApKSkge1xuICAgICAgICAgIHN0eWxlRWxtLmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlRWxtID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICBzdHlsZUVsbS5pbm5lckhUTUwgPSBzdHlsZTtcbiAgICAgICAgICBjb25zdCBub25jZSA9IChfYSA9IHBsdC4kbm9uY2UkKSAhPSBudWxsID8gX2EgOiBxdWVyeU5vbmNlTWV0YVRhZ0NvbnRlbnQoZG9jKTtcbiAgICAgICAgICBpZiAobm9uY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3R5bGVFbG0uc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQlVJTEQxMy5oeWRyYXRlU2VydmVyU2lkZSB8fCBCVUlMRDEzLmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICBzdHlsZUVsbS5zZXRBdHRyaWJ1dGUoSFlEUkFURURfU1RZTEVfSUQsIHNjb3BlSWQyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlLmluc2VydEJlZm9yZShzdHlsZUVsbSwgc3R5bGVDb250YWluZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoXCJsaW5rXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21wTWV0YS4kZmxhZ3MkICYgNCAvKiBoYXNTbG90UmVsb2NhdGlvbiAqLykge1xuICAgICAgICAgIHN0eWxlRWxtLmlubmVySFRNTCArPSBTTE9UX0ZCX0NTUztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBwbGllZFN0eWxlcykge1xuICAgICAgICAgIGFwcGxpZWRTdHlsZXMuYWRkKHNjb3BlSWQyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQlVJTEQxMy5jb25zdHJ1Y3RhYmxlQ1NTICYmICFzdHlsZUNvbnRhaW5lck5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzLmluY2x1ZGVzKHN0eWxlKSkge1xuICAgICAgc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFsuLi5zdHlsZUNvbnRhaW5lck5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzLCBzdHlsZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzY29wZUlkMjtcbn07XG52YXIgYXR0YWNoU3R5bGVzID0gKGhvc3RSZWYpID0+IHtcbiAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gIGNvbnN0IGZsYWdzID0gY21wTWV0YS4kZmxhZ3MkO1xuICBjb25zdCBlbmRBdHRhY2hTdHlsZXMgPSBjcmVhdGVUaW1lKFwiYXR0YWNoU3R5bGVzXCIsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgY29uc3Qgc2NvcGVJZDIgPSBhZGRTdHlsZShcbiAgICBCVUlMRDEzLnNoYWRvd0RvbSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBlbG0uc2hhZG93Um9vdCA/IGVsbS5zaGFkb3dSb290IDogZWxtLmdldFJvb3ROb2RlKCksXG4gICAgY21wTWV0YSxcbiAgICBob3N0UmVmLiRtb2RlTmFtZSRcbiAgKTtcbiAgaWYgKChCVUlMRDEzLnNoYWRvd0RvbSB8fCBCVUlMRDEzLnNjb3BlZCkgJiYgQlVJTEQxMy5jc3NBbm5vdGF0aW9ucyAmJiBmbGFncyAmIDEwIC8qIG5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykge1xuICAgIGVsbVtcInMtc2NcIl0gPSBzY29wZUlkMjtcbiAgICBlbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkMiArIFwiLWhcIik7XG4gICAgaWYgKEJVSUxEMTMuc2NvcGVkICYmIGZsYWdzICYgMiAvKiBzY29wZWRDc3NFbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICBlbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkMiArIFwiLXNcIik7XG4gICAgfVxuICB9XG4gIGVuZEF0dGFjaFN0eWxlcygpO1xufTtcbnZhciBnZXRTY29wZUlkID0gKGNtcCwgbW9kZSkgPT4gXCJzYy1cIiArIChCVUlMRDEzLm1vZGUgJiYgbW9kZSAmJiBjbXAuJGZsYWdzJCAmIDMyIC8qIGhhc01vZGUgKi8gPyBjbXAuJHRhZ05hbWUkICsgXCItXCIgKyBtb2RlIDogY21wLiR0YWdOYW1lJCk7XG52YXIgY29udmVydFNjb3BlZFRvU2hhZG93ID0gKGNzcykgPT4gY3NzLnJlcGxhY2UoL1xcL1xcKiFAKFteXFwvXSspXFwqXFwvW15cXHtdK1xcey9nLCBcIiQxe1wiKTtcblxuLy8gc3JjL3J1bnRpbWUvdmRvbS92ZG9tLXJlbmRlci50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQxNiB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG5cbi8vIHNyYy9ydW50aW1lL3Zkb20vdXBkYXRlLWVsZW1lbnQudHNcbmltcG9ydCB7IEJVSUxEIGFzIEJVSUxEMTUgfSBmcm9tIFwiQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YVwiO1xuXG4vLyBzcmMvcnVudGltZS92ZG9tL3NldC1hY2Nlc3Nvci50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQxNCB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG52YXIgc2V0QWNjZXNzb3IgPSAoZWxtLCBtZW1iZXJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGlzU3ZnLCBmbGFncykgPT4ge1xuICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgbGV0IGlzUHJvcCA9IGlzTWVtYmVySW5FbGVtZW50KGVsbSwgbWVtYmVyTmFtZSk7XG4gICAgbGV0IGxuID0gbWVtYmVyTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChCVUlMRDE0LnZkb21DbGFzcyAmJiBtZW1iZXJOYW1lID09PSBcImNsYXNzXCIpIHtcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsbS5jbGFzc0xpc3Q7XG4gICAgICBjb25zdCBvbGRDbGFzc2VzID0gcGFyc2VDbGFzc0xpc3Qob2xkVmFsdWUpO1xuICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IHBhcnNlQ2xhc3NMaXN0KG5ld1ZhbHVlKTtcbiAgICAgIGNsYXNzTGlzdC5yZW1vdmUoLi4ub2xkQ2xhc3Nlcy5maWx0ZXIoKGMpID0+IGMgJiYgIW5ld0NsYXNzZXMuaW5jbHVkZXMoYykpKTtcbiAgICAgIGNsYXNzTGlzdC5hZGQoLi4ubmV3Q2xhc3Nlcy5maWx0ZXIoKGMpID0+IGMgJiYgIW9sZENsYXNzZXMuaW5jbHVkZXMoYykpKTtcbiAgICB9IGVsc2UgaWYgKEJVSUxEMTQudmRvbVN0eWxlICYmIG1lbWJlck5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgaWYgKEJVSUxEMTQudXBkYXRhYmxlKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvbGRWYWx1ZSkge1xuICAgICAgICAgIGlmICghbmV3VmFsdWUgfHwgbmV3VmFsdWVbcHJvcF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFCVUlMRDE0Lmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIHByb3AuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgICAgICAgICAgIGVsbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKCFvbGRWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSAhPT0gb2xkVmFsdWVbcHJvcF0pIHtcbiAgICAgICAgICBpZiAoIUJVSUxEMTQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgcHJvcC5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICAgICAgICAgIGVsbS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBuZXdWYWx1ZVtwcm9wXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9IG5ld1ZhbHVlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQlVJTEQxNC52ZG9tS2V5ICYmIG1lbWJlck5hbWUgPT09IFwia2V5XCIpIHtcbiAgICB9IGVsc2UgaWYgKEJVSUxEMTQudmRvbVJlZiAmJiBtZW1iZXJOYW1lID09PSBcInJlZlwiKSB7XG4gICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgbmV3VmFsdWUoZWxtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEJVSUxEMTQudmRvbUxpc3RlbmVyICYmIChCVUlMRDE0LmxhenlMb2FkID8gIWlzUHJvcCA6ICFlbG0uX19sb29rdXBTZXR0ZXJfXyhtZW1iZXJOYW1lKSkgJiYgbWVtYmVyTmFtZVswXSA9PT0gXCJvXCIgJiYgbWVtYmVyTmFtZVsxXSA9PT0gXCJuXCIpIHtcbiAgICAgIGlmIChtZW1iZXJOYW1lWzJdID09PSBcIi1cIikge1xuICAgICAgICBtZW1iZXJOYW1lID0gbWVtYmVyTmFtZS5zbGljZSgzKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNZW1iZXJJbkVsZW1lbnQod2luLCBsbikpIHtcbiAgICAgICAgbWVtYmVyTmFtZSA9IGxuLnNsaWNlKDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtYmVyTmFtZSA9IGxuWzJdICsgbWVtYmVyTmFtZS5zbGljZSgzKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbGRWYWx1ZSB8fCBuZXdWYWx1ZSkge1xuICAgICAgICBjb25zdCBjYXB0dXJlID0gbWVtYmVyTmFtZS5lbmRzV2l0aChDQVBUVVJFX0VWRU5UX1NVRkZJWCk7XG4gICAgICAgIG1lbWJlck5hbWUgPSBtZW1iZXJOYW1lLnJlcGxhY2UoQ0FQVFVSRV9FVkVOVF9SRUdFWCwgXCJcIik7XG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgIHBsdC5yZWwoZWxtLCBtZW1iZXJOYW1lLCBvbGRWYWx1ZSwgY2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgcGx0LmFlbChlbG0sIG1lbWJlck5hbWUsIG5ld1ZhbHVlLCBjYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQlVJTEQxNC52ZG9tUHJvcE9yQXR0cikge1xuICAgICAgY29uc3QgaXNDb21wbGV4ID0gaXNDb21wbGV4VHlwZShuZXdWYWx1ZSk7XG4gICAgICBpZiAoKGlzUHJvcCB8fCBpc0NvbXBsZXggJiYgbmV3VmFsdWUgIT09IG51bGwpICYmICFpc1N2Zykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghZWxtLnRhZ05hbWUuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gbmV3VmFsdWUgPT0gbnVsbCA/IFwiXCIgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgIGlmIChtZW1iZXJOYW1lID09PSBcImxpc3RcIikge1xuICAgICAgICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT0gbnVsbCB8fCBlbG1bbWVtYmVyTmFtZV0gIT0gbikge1xuICAgICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHhsaW5rID0gZmFsc2U7XG4gICAgICBpZiAoQlVJTEQxNC52ZG9tWGxpbmspIHtcbiAgICAgICAgaWYgKGxuICE9PSAobG4gPSBsbi5yZXBsYWNlKC9eeGxpbmtcXDo/LywgXCJcIikpKSB7XG4gICAgICAgICAgbWVtYmVyTmFtZSA9IGxuO1xuICAgICAgICAgIHhsaW5rID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5ld1ZhbHVlID09IG51bGwgfHwgbmV3VmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gZmFsc2UgfHwgZWxtLmdldEF0dHJpYnV0ZShtZW1iZXJOYW1lKSA9PT0gXCJcIikge1xuICAgICAgICAgIGlmIChCVUlMRDE0LnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKFhMSU5LX05TLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShtZW1iZXJOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKCFpc1Byb3AgfHwgZmxhZ3MgJiA0IC8qIGlzSG9zdCAqLyB8fCBpc1N2ZykgJiYgIWlzQ29tcGxleCkge1xuICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlID09PSB0cnVlID8gXCJcIiA6IG5ld1ZhbHVlO1xuICAgICAgICBpZiAoQlVJTEQxNC52ZG9tWGxpbmsgJiYgeGxpbmspIHtcbiAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIG1lbWJlck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlKG1lbWJlck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBwYXJzZUNsYXNzTGlzdFJlZ2V4ID0gL1xccy87XG52YXIgcGFyc2VDbGFzc0xpc3QgPSAodmFsdWUpID0+ICF2YWx1ZSA/IFtdIDogdmFsdWUuc3BsaXQocGFyc2VDbGFzc0xpc3RSZWdleCk7XG52YXIgQ0FQVFVSRV9FVkVOVF9TVUZGSVggPSBcIkNhcHR1cmVcIjtcbnZhciBDQVBUVVJFX0VWRU5UX1JFR0VYID0gbmV3IFJlZ0V4cChDQVBUVVJFX0VWRU5UX1NVRkZJWCArIFwiJFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdmRvbS91cGRhdGUtZWxlbWVudC50c1xudmFyIHVwZGF0ZUVsZW1lbnQgPSAob2xkVm5vZGUsIG5ld1Zub2RlLCBpc1N2Z01vZGUyKSA9PiB7XG4gIGNvbnN0IGVsbSA9IG5ld1Zub2RlLiRlbG0kLm5vZGVUeXBlID09PSAxMSAvKiBEb2N1bWVudEZyYWdtZW50ICovICYmIG5ld1Zub2RlLiRlbG0kLmhvc3QgPyBuZXdWbm9kZS4kZWxtJC5ob3N0IDogbmV3Vm5vZGUuJGVsbSQ7XG4gIGNvbnN0IG9sZFZub2RlQXR0cnMgPSBvbGRWbm9kZSAmJiBvbGRWbm9kZS4kYXR0cnMkIHx8IEVNUFRZX09CSjtcbiAgY29uc3QgbmV3Vm5vZGVBdHRycyA9IG5ld1Zub2RlLiRhdHRycyQgfHwgRU1QVFlfT0JKO1xuICBpZiAoQlVJTEQxNS51cGRhdGFibGUpIHtcbiAgICBmb3IgKGNvbnN0IG1lbWJlck5hbWUgb2Ygc29ydGVkQXR0ck5hbWVzKE9iamVjdC5rZXlzKG9sZFZub2RlQXR0cnMpKSkge1xuICAgICAgaWYgKCEobWVtYmVyTmFtZSBpbiBuZXdWbm9kZUF0dHJzKSkge1xuICAgICAgICBzZXRBY2Nlc3NvcihlbG0sIG1lbWJlck5hbWUsIG9sZFZub2RlQXR0cnNbbWVtYmVyTmFtZV0sIHZvaWQgMCwgaXNTdmdNb2RlMiwgbmV3Vm5vZGUuJGZsYWdzJCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgbWVtYmVyTmFtZSBvZiBzb3J0ZWRBdHRyTmFtZXMoT2JqZWN0LmtleXMobmV3Vm5vZGVBdHRycykpKSB7XG4gICAgc2V0QWNjZXNzb3IoZWxtLCBtZW1iZXJOYW1lLCBvbGRWbm9kZUF0dHJzW21lbWJlck5hbWVdLCBuZXdWbm9kZUF0dHJzW21lbWJlck5hbWVdLCBpc1N2Z01vZGUyLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNvcnRlZEF0dHJOYW1lcyhhdHRyTmFtZXMpIHtcbiAgcmV0dXJuIGF0dHJOYW1lcy5pbmNsdWRlcyhcInJlZlwiKSA/IChcbiAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlc2UgdG8gZW5zdXJlIHRoYXQgYCdyZWYnYCBpcyB0aGUgbGFzdCBhdHRyXG4gICAgWy4uLmF0dHJOYW1lcy5maWx0ZXIoKGF0dHIpID0+IGF0dHIgIT09IFwicmVmXCIpLCBcInJlZlwiXVxuICApIDogKFxuICAgIC8vIG5vIG5lZWQgdG8gc29ydCwgcmV0dXJuIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgIGF0dHJOYW1lc1xuICApO1xufVxuXG4vLyBzcmMvcnVudGltZS92ZG9tL3Zkb20tcmVuZGVyLnRzXG52YXIgc2NvcGVJZDtcbnZhciBjb250ZW50UmVmO1xudmFyIGhvc3RUYWdOYW1lO1xudmFyIHVzZU5hdGl2ZVNoYWRvd0RvbSA9IGZhbHNlO1xudmFyIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IGZhbHNlO1xudmFyIGNoZWNrU2xvdFJlbG9jYXRlID0gZmFsc2U7XG52YXIgaXNTdmdNb2RlID0gZmFsc2U7XG52YXIgY3JlYXRlRWxtID0gKG9sZFBhcmVudFZOb2RlLCBuZXdQYXJlbnRWTm9kZSwgY2hpbGRJbmRleCwgcGFyZW50RWxtKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgbmV3Vk5vZGUyID0gbmV3UGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZEluZGV4XTtcbiAgbGV0IGkyID0gMDtcbiAgbGV0IGVsbTtcbiAgbGV0IGNoaWxkTm9kZTtcbiAgbGV0IG9sZFZOb2RlO1xuICBpZiAoQlVJTEQxNi5zbG90UmVsb2NhdGlvbiAmJiAhdXNlTmF0aXZlU2hhZG93RG9tKSB7XG4gICAgY2hlY2tTbG90UmVsb2NhdGUgPSB0cnVlO1xuICAgIGlmIChuZXdWTm9kZTIuJHRhZyQgPT09IFwic2xvdFwiKSB7XG4gICAgICBpZiAoc2NvcGVJZCkge1xuICAgICAgICBwYXJlbnRFbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgXCItc1wiKTtcbiAgICAgIH1cbiAgICAgIG5ld1ZOb2RlMi4kZmxhZ3MkIHw9IG5ld1ZOb2RlMi4kY2hpbGRyZW4kID8gKFxuICAgICAgICAvLyBzbG90IGVsZW1lbnQgaGFzIGZhbGxiYWNrIGNvbnRlbnRcbiAgICAgICAgLy8gc3RpbGwgY3JlYXRlIGFuIGVsZW1lbnQgdGhhdCBcIm1vY2tzXCIgdGhlIHNsb3QgZWxlbWVudFxuICAgICAgICAyIC8qIGlzU2xvdEZhbGxiYWNrICovXG4gICAgICApIDogKFxuICAgICAgICAvLyBzbG90IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBmYWxsYmFjayBjb250ZW50XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBodG1sIGNvbW1lbnQgd2UnbGwgdXNlIHRvIGFsd2F5cyByZWZlcmVuY2VcbiAgICAgICAgLy8gd2hlcmUgYWN0dWFsIHNsb3QgY29udGVudCBzaG91bGQgc2l0IG5leHQgdG9cbiAgICAgICAgMSAvKiBpc1Nsb3RSZWZlcmVuY2UgKi9cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChCVUlMRDE2LmlzRGV2ICYmIG5ld1ZOb2RlMi4kZWxtJCkge1xuICAgIGNvbnNvbGVEZXZFcnJvcihcbiAgICAgIGBUaGUgSlNYICR7bmV3Vk5vZGUyLiR0ZXh0JCAhPT0gbnVsbCA/IGBcIiR7bmV3Vk5vZGUyLiR0ZXh0JH1cIiB0ZXh0YCA6IGBcIiR7bmV3Vk5vZGUyLiR0YWckfVwiIGVsZW1lbnRgfSBub2RlIHNob3VsZCBub3QgYmUgc2hhcmVkIHdpdGhpbiB0aGUgc2FtZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNhY2hlcyBlbGVtZW50IGxvb2t1cHMgaW4gb3JkZXIgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS4gSG93ZXZlciwgYSBzaWRlIGVmZmVjdCBmcm9tIHRoaXMgaXMgdGhhdCB0aGUgZXhhY3Qgc2FtZSBKU1ggbm9kZSBzaG91bGQgbm90IGJlIHJldXNlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24gcGxlYXNlIHNlZSBodHRwczovL3N0ZW5jaWxqcy5jb20vZG9jcy90ZW1wbGF0aW5nLWpzeCNhdm9pZC1zaGFyZWQtanN4LW5vZGVzYFxuICAgICk7XG4gIH1cbiAgaWYgKEJVSUxEMTYudmRvbVRleHQgJiYgbmV3Vk5vZGUyLiR0ZXh0JCAhPT0gbnVsbCkge1xuICAgIGVsbSA9IG5ld1ZOb2RlMi4kZWxtJCA9IGRvYy5jcmVhdGVUZXh0Tm9kZShuZXdWTm9kZTIuJHRleHQkKTtcbiAgfSBlbHNlIGlmIChCVUlMRDE2LnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlMi4kZmxhZ3MkICYgMSAvKiBpc1Nsb3RSZWZlcmVuY2UgKi8pIHtcbiAgICBlbG0gPSBuZXdWTm9kZTIuJGVsbSQgPSBCVUlMRDE2LmlzRGVidWcgfHwgQlVJTEQxNi5oeWRyYXRlU2VydmVyU2lkZSA/IHNsb3RSZWZlcmVuY2VEZWJ1Z05vZGUobmV3Vk5vZGUyKSA6IGRvYy5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoQlVJTEQxNi5zdmcgJiYgIWlzU3ZnTW9kZSkge1xuICAgICAgaXNTdmdNb2RlID0gbmV3Vk5vZGUyLiR0YWckID09PSBcInN2Z1wiO1xuICAgIH1cbiAgICBlbG0gPSBuZXdWTm9kZTIuJGVsbSQgPSBCVUlMRDE2LnN2ZyA/IGRvYy5jcmVhdGVFbGVtZW50TlMoXG4gICAgICBpc1N2Z01vZGUgPyBTVkdfTlMgOiBIVE1MX05TLFxuICAgICAgIXVzZU5hdGl2ZVNoYWRvd0RvbSAmJiBCVUlMRDE2LnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlMi4kZmxhZ3MkICYgMiAvKiBpc1Nsb3RGYWxsYmFjayAqLyA/IFwic2xvdC1mYlwiIDogbmV3Vk5vZGUyLiR0YWckXG4gICAgKSA6IGRvYy5jcmVhdGVFbGVtZW50KFxuICAgICAgIXVzZU5hdGl2ZVNoYWRvd0RvbSAmJiBCVUlMRDE2LnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlMi4kZmxhZ3MkICYgMiAvKiBpc1Nsb3RGYWxsYmFjayAqLyA/IFwic2xvdC1mYlwiIDogbmV3Vk5vZGUyLiR0YWckXG4gICAgKTtcbiAgICBpZiAoQlVJTEQxNi5zdmcgJiYgaXNTdmdNb2RlICYmIG5ld1ZOb2RlMi4kdGFnJCA9PT0gXCJmb3JlaWduT2JqZWN0XCIpIHtcbiAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQlVJTEQxNi52ZG9tQXR0cmlidXRlKSB7XG4gICAgICB1cGRhdGVFbGVtZW50KG51bGwsIG5ld1ZOb2RlMiwgaXNTdmdNb2RlKTtcbiAgICB9XG4gICAgaWYgKChCVUlMRDE2LnNoYWRvd0RvbSB8fCBCVUlMRDE2LnNjb3BlZCkgJiYgaXNEZWYoc2NvcGVJZCkgJiYgZWxtW1wicy1zaVwiXSAhPT0gc2NvcGVJZCkge1xuICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoZWxtW1wicy1zaVwiXSA9IHNjb3BlSWQpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQxNi5zY29wZWQpIHtcbiAgICAgIHVwZGF0ZUVsZW1lbnRTY29wZUlkcyhlbG0sIHBhcmVudEVsbSk7XG4gICAgfVxuICAgIGlmIChuZXdWTm9kZTIuJGNoaWxkcmVuJCkge1xuICAgICAgZm9yIChpMiA9IDA7IGkyIDwgbmV3Vk5vZGUyLiRjaGlsZHJlbiQubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShvbGRQYXJlbnRWTm9kZSwgbmV3Vk5vZGUyLCBpMiwgZWxtKTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgIGVsbS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRDE2LnN2Zykge1xuICAgICAgaWYgKG5ld1ZOb2RlMi4kdGFnJCA9PT0gXCJzdmdcIikge1xuICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxtLnRhZ05hbWUgPT09IFwiZm9yZWlnbk9iamVjdFwiKSB7XG4gICAgICAgIGlzU3ZnTW9kZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsbVtcInMtaG5cIl0gPSBob3N0VGFnTmFtZTtcbiAgaWYgKEJVSUxEMTYuc2xvdFJlbG9jYXRpb24pIHtcbiAgICBpZiAobmV3Vk5vZGUyLiRmbGFncyQgJiAoMiAvKiBpc1Nsb3RGYWxsYmFjayAqLyB8IDEgLyogaXNTbG90UmVmZXJlbmNlICovKSkge1xuICAgICAgZWxtW1wicy1zclwiXSA9IHRydWU7XG4gICAgICBlbG1bXCJzLWNyXCJdID0gY29udGVudFJlZjtcbiAgICAgIGVsbVtcInMtc25cIl0gPSBuZXdWTm9kZTIuJG5hbWUkIHx8IFwiXCI7XG4gICAgICBlbG1bXCJzLXJmXCJdID0gKF9hID0gbmV3Vk5vZGUyLiRhdHRycyQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWY7XG4gICAgICBvbGRWTm9kZSA9IG9sZFBhcmVudFZOb2RlICYmIG9sZFBhcmVudFZOb2RlLiRjaGlsZHJlbiQgJiYgb2xkUGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZEluZGV4XTtcbiAgICAgIGlmIChvbGRWTm9kZSAmJiBvbGRWTm9kZS4kdGFnJCA9PT0gbmV3Vk5vZGUyLiR0YWckICYmIG9sZFBhcmVudFZOb2RlLiRlbG0kKSB7XG4gICAgICAgIGlmIChCVUlMRDE2LmV4cGVyaW1lbnRhbFNsb3RGaXhlcykge1xuICAgICAgICAgIHJlbG9jYXRlVG9Ib3N0Um9vdChvbGRQYXJlbnRWTm9kZS4kZWxtJCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihvbGRQYXJlbnRWTm9kZS4kZWxtJCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlbG07XG59O1xudmFyIHJlbG9jYXRlVG9Ib3N0Um9vdCA9IChwYXJlbnRFbG0pID0+IHtcbiAgcGx0LiRmbGFncyQgfD0gMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbiAgY29uc3QgaG9zdCA9IHBhcmVudEVsbS5jbG9zZXN0KGhvc3RUYWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICBpZiAoaG9zdCAhPSBudWxsKSB7XG4gICAgY29uc3QgY29udGVudFJlZk5vZGUgPSBBcnJheS5mcm9tKGhvc3QuY2hpbGROb2RlcykuZmluZCgocmVmKSA9PiByZWZbXCJzLWNyXCJdKTtcbiAgICBjb25zdCBjaGlsZE5vZGVBcnJheSA9IEFycmF5LmZyb20ocGFyZW50RWxtLmNoaWxkTm9kZXMpO1xuICAgIGZvciAoY29uc3QgY2hpbGROb2RlIG9mIGNvbnRlbnRSZWZOb2RlID8gY2hpbGROb2RlQXJyYXkucmV2ZXJzZSgpIDogY2hpbGROb2RlQXJyYXkpIHtcbiAgICAgIGlmIChjaGlsZE5vZGVbXCJzLXNoXCJdICE9IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0QmVmb3JlKGhvc3QsIGNoaWxkTm9kZSwgY29udGVudFJlZk5vZGUgIT0gbnVsbCA/IGNvbnRlbnRSZWZOb2RlIDogbnVsbCk7XG4gICAgICAgIGNoaWxkTm9kZVtcInMtc2hcIl0gPSB2b2lkIDA7XG4gICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGx0LiRmbGFncyQgJj0gfjEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG59O1xudmFyIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24gPSAocGFyZW50RWxtLCByZWN1cnNpdmUpID0+IHtcbiAgcGx0LiRmbGFncyQgfD0gMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbiAgY29uc3Qgb2xkU2xvdENoaWxkTm9kZXMgPSBBcnJheS5mcm9tKHBhcmVudEVsbS5jaGlsZE5vZGVzKTtcbiAgaWYgKHBhcmVudEVsbVtcInMtc3JcIl0gJiYgQlVJTEQxNi5leHBlcmltZW50YWxTbG90Rml4ZXMpIHtcbiAgICBsZXQgbm9kZSA9IHBhcmVudEVsbTtcbiAgICB3aGlsZSAobm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIGlmIChub2RlICYmIG5vZGVbXCJzLXNuXCJdID09PSBwYXJlbnRFbG1bXCJzLXNuXCJdICYmIG5vZGVbXCJzLXNoXCJdID09PSBob3N0VGFnTmFtZSkge1xuICAgICAgICBvbGRTbG90Q2hpbGROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpMiA9IG9sZFNsb3RDaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSBvbGRTbG90Q2hpbGROb2Rlc1tpMl07XG4gICAgaWYgKGNoaWxkTm9kZVtcInMtaG5cIl0gIT09IGhvc3RUYWdOYW1lICYmIGNoaWxkTm9kZVtcInMtb2xcIl0pIHtcbiAgICAgIGluc2VydEJlZm9yZShwYXJlbnRSZWZlcmVuY2VOb2RlKGNoaWxkTm9kZSksIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZShjaGlsZE5vZGUpKTtcbiAgICAgIGNoaWxkTm9kZVtcInMtb2xcIl0ucmVtb3ZlKCk7XG4gICAgICBjaGlsZE5vZGVbXCJzLW9sXCJdID0gdm9pZCAwO1xuICAgICAgY2hpbGROb2RlW1wicy1zaFwiXSA9IHZvaWQgMDtcbiAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihjaGlsZE5vZGUsIHJlY3Vyc2l2ZSk7XG4gICAgfVxuICB9XG4gIHBsdC4kZmxhZ3MkICY9IH4xIC8qIGlzVG1wRGlzY29ubmVjdGVkICovO1xufTtcbnZhciBhZGRWbm9kZXMgPSAocGFyZW50RWxtLCBiZWZvcmUsIHBhcmVudFZOb2RlLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpID0+IHtcbiAgbGV0IGNvbnRhaW5lckVsbSA9IEJVSUxEMTYuc2xvdFJlbG9jYXRpb24gJiYgcGFyZW50RWxtW1wicy1jclwiXSAmJiBwYXJlbnRFbG1bXCJzLWNyXCJdLnBhcmVudE5vZGUgfHwgcGFyZW50RWxtO1xuICBsZXQgY2hpbGROb2RlO1xuICBpZiAoQlVJTEQxNi5zaGFkb3dEb20gJiYgY29udGFpbmVyRWxtLnNoYWRvd1Jvb3QgJiYgY29udGFpbmVyRWxtLnRhZ05hbWUgPT09IGhvc3RUYWdOYW1lKSB7XG4gICAgY29udGFpbmVyRWxtID0gY29udGFpbmVyRWxtLnNoYWRvd1Jvb3Q7XG4gIH1cbiAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgIGlmICh2bm9kZXNbc3RhcnRJZHhdKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjcmVhdGVFbG0obnVsbCwgcGFyZW50Vk5vZGUsIHN0YXJ0SWR4LCBwYXJlbnRFbG0pO1xuICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICB2bm9kZXNbc3RhcnRJZHhdLiRlbG0kID0gY2hpbGROb2RlO1xuICAgICAgICBpbnNlcnRCZWZvcmUoY29udGFpbmVyRWxtLCBjaGlsZE5vZGUsIEJVSUxEMTYuc2xvdFJlbG9jYXRpb24gPyByZWZlcmVuY2VOb2RlKGJlZm9yZSkgOiBiZWZvcmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciByZW1vdmVWbm9kZXMgPSAodm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSA9PiB7XG4gIGZvciAobGV0IGluZGV4ID0gc3RhcnRJZHg7IGluZGV4IDw9IGVuZElkeDsgKytpbmRleCkge1xuICAgIGNvbnN0IHZub2RlID0gdm5vZGVzW2luZGV4XTtcbiAgICBpZiAodm5vZGUpIHtcbiAgICAgIGNvbnN0IGVsbSA9IHZub2RlLiRlbG0kO1xuICAgICAgbnVsbGlmeVZOb2RlUmVmcyh2bm9kZSk7XG4gICAgICBpZiAoZWxtKSB7XG4gICAgICAgIGlmIChCVUlMRDE2LnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZWxtW1wicy1vbFwiXSkge1xuICAgICAgICAgICAgZWxtW1wicy1vbFwiXS5yZW1vdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihlbG0sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbG0ucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIHVwZGF0ZUNoaWxkcmVuID0gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld1ZOb2RlMiwgbmV3Q2gsIGlzSW5pdGlhbFJlbmRlciA9IGZhbHNlKSA9PiB7XG4gIGxldCBvbGRTdGFydElkeCA9IDA7XG4gIGxldCBuZXdTdGFydElkeCA9IDA7XG4gIGxldCBpZHhJbk9sZCA9IDA7XG4gIGxldCBpMiA9IDA7XG4gIGxldCBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICBsZXQgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICBsZXQgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICBsZXQgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgbGV0IG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgbGV0IG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgbGV0IG5vZGU7XG4gIGxldCBlbG1Ub01vdmU7XG4gIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgaWYgKG9sZFN0YXJ0Vm5vZGUgPT0gbnVsbCkge1xuICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgIH0gZWxzZSBpZiAob2xkRW5kVm5vZGUgPT0gbnVsbCkge1xuICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICB9IGVsc2UgaWYgKG5ld0VuZFZub2RlID09IG51bGwpIHtcbiAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgIH0gZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaXNJbml0aWFsUmVuZGVyKSkge1xuICAgICAgcGF0Y2gob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaXNJbml0aWFsUmVuZGVyKTtcbiAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICB9IGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaXNJbml0aWFsUmVuZGVyKSkge1xuICAgICAgcGF0Y2gob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpc0luaXRpYWxSZW5kZXIpO1xuICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICB9IGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpc0luaXRpYWxSZW5kZXIpKSB7XG4gICAgICBpZiAoQlVJTEQxNi5zbG90UmVsb2NhdGlvbiAmJiAob2xkU3RhcnRWbm9kZS4kdGFnJCA9PT0gXCJzbG90XCIgfHwgbmV3RW5kVm5vZGUuJHRhZyQgPT09IFwic2xvdFwiKSkge1xuICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKG9sZFN0YXJ0Vm5vZGUuJGVsbSQucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgcGF0Y2gob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGlzSW5pdGlhbFJlbmRlcik7XG4gICAgICBpbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLiRlbG0kLCBvbGRFbmRWbm9kZS4kZWxtJC5uZXh0U2libGluZyk7XG4gICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICB9IGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpc0luaXRpYWxSZW5kZXIpKSB7XG4gICAgICBpZiAoQlVJTEQxNi5zbG90UmVsb2NhdGlvbiAmJiAob2xkU3RhcnRWbm9kZS4kdGFnJCA9PT0gXCJzbG90XCIgfHwgbmV3RW5kVm5vZGUuJHRhZyQgPT09IFwic2xvdFwiKSkge1xuICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKG9sZEVuZFZub2RlLiRlbG0kLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHBhdGNoKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpc0luaXRpYWxSZW5kZXIpO1xuICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuJGVsbSQsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkeEluT2xkID0gLTE7XG4gICAgICBpZiAoQlVJTEQxNi52ZG9tS2V5KSB7XG4gICAgICAgIGZvciAoaTIgPSBvbGRTdGFydElkeDsgaTIgPD0gb2xkRW5kSWR4OyArK2kyKSB7XG4gICAgICAgICAgaWYgKG9sZENoW2kyXSAmJiBvbGRDaFtpMl0uJGtleSQgIT09IG51bGwgJiYgb2xkQ2hbaTJdLiRrZXkkID09PSBuZXdTdGFydFZub2RlLiRrZXkkKSB7XG4gICAgICAgICAgICBpZHhJbk9sZCA9IGkyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoQlVJTEQxNi52ZG9tS2V5ICYmIGlkeEluT2xkID49IDApIHtcbiAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICBpZiAoZWxtVG9Nb3ZlLiR0YWckICE9PSBuZXdTdGFydFZub2RlLiR0YWckKSB7XG4gICAgICAgICAgbm9kZSA9IGNyZWF0ZUVsbShvbGRDaCAmJiBvbGRDaFtuZXdTdGFydElkeF0sIG5ld1ZOb2RlMiwgaWR4SW5PbGQsIHBhcmVudEVsbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0Y2goZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpc0luaXRpYWxSZW5kZXIpO1xuICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHZvaWQgMDtcbiAgICAgICAgICBub2RlID0gZWxtVG9Nb3ZlLiRlbG0kO1xuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBjcmVhdGVFbG0ob2xkQ2ggJiYgb2xkQ2hbbmV3U3RhcnRJZHhdLCBuZXdWTm9kZTIsIG5ld1N0YXJ0SWR4LCBwYXJlbnRFbG0pO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAoQlVJTEQxNi5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAgIGluc2VydEJlZm9yZShwYXJlbnRSZWZlcmVuY2VOb2RlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQpLCBub2RlLCByZWZlcmVuY2VOb2RlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRCZWZvcmUob2xkU3RhcnRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLCBub2RlLCBvbGRTdGFydFZub2RlLiRlbG0kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICBhZGRWbm9kZXMoXG4gICAgICBwYXJlbnRFbG0sXG4gICAgICBuZXdDaFtuZXdFbmRJZHggKyAxXSA9PSBudWxsID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLiRlbG0kLFxuICAgICAgbmV3Vk5vZGUyLFxuICAgICAgbmV3Q2gsXG4gICAgICBuZXdTdGFydElkeCxcbiAgICAgIG5ld0VuZElkeFxuICAgICk7XG4gIH0gZWxzZSBpZiAoQlVJTEQxNi51cGRhdGFibGUgJiYgbmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICByZW1vdmVWbm9kZXMob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICB9XG59O1xudmFyIGlzU2FtZVZub2RlID0gKGxlZnRWTm9kZSwgcmlnaHRWTm9kZSwgaXNJbml0aWFsUmVuZGVyID0gZmFsc2UpID0+IHtcbiAgaWYgKGxlZnRWTm9kZS4kdGFnJCA9PT0gcmlnaHRWTm9kZS4kdGFnJCkge1xuICAgIGlmIChCVUlMRDE2LnNsb3RSZWxvY2F0aW9uICYmIGxlZnRWTm9kZS4kdGFnJCA9PT0gXCJzbG90XCIpIHtcbiAgICAgIHJldHVybiBsZWZ0Vk5vZGUuJG5hbWUkID09PSByaWdodFZOb2RlLiRuYW1lJDtcbiAgICB9XG4gICAgaWYgKEJVSUxEMTYudmRvbUtleSAmJiAhaXNJbml0aWFsUmVuZGVyKSB7XG4gICAgICByZXR1cm4gbGVmdFZOb2RlLiRrZXkkID09PSByaWdodFZOb2RlLiRrZXkkO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIHJlZmVyZW5jZU5vZGUgPSAobm9kZSkgPT4ge1xuICByZXR1cm4gbm9kZSAmJiBub2RlW1wicy1vbFwiXSB8fCBub2RlO1xufTtcbnZhciBwYXJlbnRSZWZlcmVuY2VOb2RlID0gKG5vZGUpID0+IChub2RlW1wicy1vbFwiXSA/IG5vZGVbXCJzLW9sXCJdIDogbm9kZSkucGFyZW50Tm9kZTtcbnZhciBwYXRjaCA9IChvbGRWTm9kZSwgbmV3Vk5vZGUyLCBpc0luaXRpYWxSZW5kZXIgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBlbG0gPSBuZXdWTm9kZTIuJGVsbSQgPSBvbGRWTm9kZS4kZWxtJDtcbiAgY29uc3Qgb2xkQ2hpbGRyZW4gPSBvbGRWTm9kZS4kY2hpbGRyZW4kO1xuICBjb25zdCBuZXdDaGlsZHJlbiA9IG5ld1ZOb2RlMi4kY2hpbGRyZW4kO1xuICBjb25zdCB0YWcgPSBuZXdWTm9kZTIuJHRhZyQ7XG4gIGNvbnN0IHRleHQgPSBuZXdWTm9kZTIuJHRleHQkO1xuICBsZXQgZGVmYXVsdEhvbGRlcjtcbiAgaWYgKCFCVUlMRDE2LnZkb21UZXh0IHx8IHRleHQgPT09IG51bGwpIHtcbiAgICBpZiAoQlVJTEQxNi5zdmcpIHtcbiAgICAgIGlzU3ZnTW9kZSA9IHRhZyA9PT0gXCJzdmdcIiA/IHRydWUgOiB0YWcgPT09IFwiZm9yZWlnbk9iamVjdFwiID8gZmFsc2UgOiBpc1N2Z01vZGU7XG4gICAgfVxuICAgIGlmIChCVUlMRDE2LnZkb21BdHRyaWJ1dGUgfHwgQlVJTEQxNi5yZWZsZWN0KSB7XG4gICAgICBpZiAoQlVJTEQxNi5zbG90ICYmIHRhZyA9PT0gXCJzbG90XCIgJiYgIXVzZU5hdGl2ZVNoYWRvd0RvbSkge1xuICAgICAgICBpZiAoQlVJTEQxNi5leHBlcmltZW50YWxTbG90Rml4ZXMgJiYgb2xkVk5vZGUuJG5hbWUkICE9PSBuZXdWTm9kZTIuJG5hbWUkKSB7XG4gICAgICAgICAgbmV3Vk5vZGUyLiRlbG0kW1wicy1zblwiXSA9IG5ld1ZOb2RlMi4kbmFtZSQgfHwgXCJcIjtcbiAgICAgICAgICByZWxvY2F0ZVRvSG9zdFJvb3QobmV3Vk5vZGUyLiRlbG0kLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVFbGVtZW50KG9sZFZOb2RlLCBuZXdWTm9kZTIsIGlzU3ZnTW9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRDE2LnVwZGF0YWJsZSAmJiBvbGRDaGlsZHJlbiAhPT0gbnVsbCAmJiBuZXdDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaGlsZHJlbiwgbmV3Vk5vZGUyLCBuZXdDaGlsZHJlbiwgaXNJbml0aWFsUmVuZGVyKTtcbiAgICB9IGVsc2UgaWYgKG5ld0NoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICBpZiAoQlVJTEQxNi51cGRhdGFibGUgJiYgQlVJTEQxNi52ZG9tVGV4dCAmJiBvbGRWTm9kZS4kdGV4dCQgIT09IG51bGwpIHtcbiAgICAgICAgZWxtLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIG5ld1ZOb2RlMiwgbmV3Q2hpbGRyZW4sIDAsIG5ld0NoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgIH0gZWxzZSBpZiAoQlVJTEQxNi51cGRhdGFibGUgJiYgb2xkQ2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhvbGRDaGlsZHJlbiwgMCwgb2xkQ2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGlmIChCVUlMRDE2LnN2ZyAmJiBpc1N2Z01vZGUgJiYgdGFnID09PSBcInN2Z1wiKSB7XG4gICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQlVJTEQxNi52ZG9tVGV4dCAmJiBCVUlMRDE2LnNsb3RSZWxvY2F0aW9uICYmIChkZWZhdWx0SG9sZGVyID0gZWxtW1wicy1jclwiXSkpIHtcbiAgICBkZWZhdWx0SG9sZGVyLnBhcmVudE5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9IGVsc2UgaWYgKEJVSUxEMTYudmRvbVRleHQgJiYgb2xkVk5vZGUuJHRleHQkICE9PSB0ZXh0KSB7XG4gICAgZWxtLmRhdGEgPSB0ZXh0O1xuICB9XG59O1xudmFyIHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkgPSAoZWxtKSA9PiB7XG4gIGNvbnN0IGNoaWxkTm9kZXMgPSBlbG0uY2hpbGROb2RlcztcbiAgZm9yIChjb25zdCBjaGlsZE5vZGUgb2YgY2hpbGROb2Rlcykge1xuICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgIGlmIChjaGlsZE5vZGVbXCJzLXNyXCJdKSB7XG4gICAgICAgIGNvbnN0IHNsb3ROYW1lID0gY2hpbGROb2RlW1wicy1zblwiXTtcbiAgICAgICAgY2hpbGROb2RlLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHNpYmxpbmdOb2RlIG9mIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoc2libGluZ05vZGUgIT09IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgaWYgKHNpYmxpbmdOb2RlW1wicy1oblwiXSAhPT0gY2hpbGROb2RlW1wicy1oblwiXSB8fCBzbG90TmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICBpZiAoc2libGluZ05vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gJiYgKHNsb3ROYW1lID09PSBzaWJsaW5nTm9kZS5nZXRBdHRyaWJ1dGUoXCJzbG90XCIpIHx8IHNsb3ROYW1lID09PSBzaWJsaW5nTm9kZVtcInMtc25cIl0pIHx8IHNpYmxpbmdOb2RlLm5vZGVUeXBlID09PSAzIC8qIFRleHROb2RlICovICYmIHNsb3ROYW1lID09PSBzaWJsaW5nTm9kZVtcInMtc25cIl0pIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHNpYmxpbmdOb2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovIHx8IHNpYmxpbmdOb2RlLm5vZGVUeXBlID09PSAzIC8qIFRleHROb2RlICovICYmIHNpYmxpbmdOb2RlLnRleHRDb250ZW50LnRyaW0oKSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5KGNoaWxkTm9kZSk7XG4gICAgfVxuICB9XG59O1xudmFyIHJlbG9jYXRlTm9kZXMgPSBbXTtcbnZhciBtYXJrU2xvdENvbnRlbnRGb3JSZWxvY2F0aW9uID0gKGVsbSkgPT4ge1xuICBsZXQgbm9kZTtcbiAgbGV0IGhvc3RDb250ZW50Tm9kZXM7XG4gIGxldCBqO1xuICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBlbG0uY2hpbGROb2Rlcykge1xuICAgIGlmIChjaGlsZE5vZGVbXCJzLXNyXCJdICYmIChub2RlID0gY2hpbGROb2RlW1wicy1jclwiXSkgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBob3N0Q29udGVudE5vZGVzID0gbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICBjb25zdCBzbG90TmFtZSA9IGNoaWxkTm9kZVtcInMtc25cIl07XG4gICAgICBmb3IgKGogPSBob3N0Q29udGVudE5vZGVzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIG5vZGUgPSBob3N0Q29udGVudE5vZGVzW2pdO1xuICAgICAgICBpZiAoIW5vZGVbXCJzLWNuXCJdICYmICFub2RlW1wicy1uclwiXSAmJiBub2RlW1wicy1oblwiXSAhPT0gY2hpbGROb2RlW1wicy1oblwiXSAmJiAoIUJVSUxEMTYuZXhwZXJpbWVudGFsU2xvdEZpeGVzIHx8ICFub2RlW1wicy1zaFwiXSB8fCBub2RlW1wicy1zaFwiXSAhPT0gY2hpbGROb2RlW1wicy1oblwiXSkpIHtcbiAgICAgICAgICBpZiAoaXNOb2RlTG9jYXRlZEluU2xvdChub2RlLCBzbG90TmFtZSkpIHtcbiAgICAgICAgICAgIGxldCByZWxvY2F0ZU5vZGVEYXRhID0gcmVsb2NhdGVOb2Rlcy5maW5kKChyKSA9PiByLiRub2RlVG9SZWxvY2F0ZSQgPT09IG5vZGUpO1xuICAgICAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGVbXCJzLXNuXCJdID0gbm9kZVtcInMtc25cIl0gfHwgc2xvdE5hbWU7XG4gICAgICAgICAgICBpZiAocmVsb2NhdGVOb2RlRGF0YSkge1xuICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhLiRub2RlVG9SZWxvY2F0ZSRbXCJzLXNoXCJdID0gY2hpbGROb2RlW1wicy1oblwiXTtcbiAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YS4kc2xvdFJlZk5vZGUkID0gY2hpbGROb2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZVtcInMtc2hcIl0gPSBjaGlsZE5vZGVbXCJzLWhuXCJdO1xuICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICRzbG90UmVmTm9kZSQ6IGNoaWxkTm9kZSxcbiAgICAgICAgICAgICAgICAkbm9kZVRvUmVsb2NhdGUkOiBub2RlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVbXCJzLXNyXCJdKSB7XG4gICAgICAgICAgICAgIHJlbG9jYXRlTm9kZXMubWFwKChyZWxvY2F0ZU5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlTG9jYXRlZEluU2xvdChyZWxvY2F0ZU5vZGUuJG5vZGVUb1JlbG9jYXRlJCwgbm9kZVtcInMtc25cIl0pKSB7XG4gICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhID0gcmVsb2NhdGVOb2Rlcy5maW5kKChyKSA9PiByLiRub2RlVG9SZWxvY2F0ZSQgPT09IG5vZGUpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlbG9jYXRlTm9kZURhdGEgJiYgIXJlbG9jYXRlTm9kZS4kc2xvdFJlZk5vZGUkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZS4kc2xvdFJlZk5vZGUkID0gcmVsb2NhdGVOb2RlRGF0YS4kc2xvdFJlZk5vZGUkO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghcmVsb2NhdGVOb2Rlcy5zb21lKChyKSA9PiByLiRub2RlVG9SZWxvY2F0ZSQgPT09IG5vZGUpKSB7XG4gICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAkbm9kZVRvUmVsb2NhdGUkOiBub2RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgbWFya1Nsb3RDb250ZW50Rm9yUmVsb2NhdGlvbihjaGlsZE5vZGUpO1xuICAgIH1cbiAgfVxufTtcbnZhciBpc05vZGVMb2NhdGVkSW5TbG90ID0gKG5vZGVUb1JlbG9jYXRlLCBzbG90TmFtZSkgPT4ge1xuICBpZiAobm9kZVRvUmVsb2NhdGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICBpZiAobm9kZVRvUmVsb2NhdGUuZ2V0QXR0cmlidXRlKFwic2xvdFwiKSA9PT0gbnVsbCAmJiBzbG90TmFtZSA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChub2RlVG9SZWxvY2F0ZS5nZXRBdHRyaWJ1dGUoXCJzbG90XCIpID09PSBzbG90TmFtZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobm9kZVRvUmVsb2NhdGVbXCJzLXNuXCJdID09PSBzbG90TmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBzbG90TmFtZSA9PT0gXCJcIjtcbn07XG52YXIgbnVsbGlmeVZOb2RlUmVmcyA9ICh2Tm9kZSkgPT4ge1xuICBpZiAoQlVJTEQxNi52ZG9tUmVmKSB7XG4gICAgdk5vZGUuJGF0dHJzJCAmJiB2Tm9kZS4kYXR0cnMkLnJlZiAmJiB2Tm9kZS4kYXR0cnMkLnJlZihudWxsKTtcbiAgICB2Tm9kZS4kY2hpbGRyZW4kICYmIHZOb2RlLiRjaGlsZHJlbiQubWFwKG51bGxpZnlWTm9kZVJlZnMpO1xuICB9XG59O1xudmFyIGluc2VydEJlZm9yZSA9IChwYXJlbnQsIG5ld05vZGUsIHJlZmVyZW5jZSkgPT4ge1xuICBjb25zdCBpbnNlcnRlZCA9IHBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGFyZW50Lmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2UpO1xuICBpZiAoQlVJTEQxNi5zY29wZWQpIHtcbiAgICB1cGRhdGVFbGVtZW50U2NvcGVJZHMobmV3Tm9kZSwgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gaW5zZXJ0ZWQ7XG59O1xudmFyIGZpbmRTY29wZUlkcyA9IChlbGVtZW50KSA9PiB7XG4gIGNvbnN0IHNjb3BlSWRzID0gW107XG4gIGlmIChlbGVtZW50KSB7XG4gICAgc2NvcGVJZHMucHVzaChcbiAgICAgIC4uLmVsZW1lbnRbXCJzLXNjc1wiXSB8fCBbXSxcbiAgICAgIGVsZW1lbnRbXCJzLXNpXCJdLFxuICAgICAgZWxlbWVudFtcInMtc2NcIl0sXG4gICAgICAuLi5maW5kU2NvcGVJZHMoZWxlbWVudC5wYXJlbnRFbGVtZW50KVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNjb3BlSWRzO1xufTtcbnZhciB1cGRhdGVFbGVtZW50U2NvcGVJZHMgPSAoZWxlbWVudCwgcGFyZW50LCBpdGVyYXRlQ2hpbGROb2RlcyA9IGZhbHNlKSA9PiB7XG4gIHZhciBfYTtcbiAgaWYgKGVsZW1lbnQgJiYgcGFyZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICBjb25zdCBzY29wZUlkcyA9IG5ldyBTZXQoZmluZFNjb3BlSWRzKHBhcmVudCkuZmlsdGVyKEJvb2xlYW4pKTtcbiAgICBpZiAoc2NvcGVJZHMuc2l6ZSkge1xuICAgICAgKF9hID0gZWxlbWVudC5jbGFzc0xpc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hZGQoLi4uZWxlbWVudFtcInMtc2NzXCJdID0gWy4uLnNjb3BlSWRzXSk7XG4gICAgICBpZiAoZWxlbWVudFtcInMtb2xcIl0gfHwgaXRlcmF0ZUNoaWxkTm9kZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZE5vZGUgb2YgQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpKSB7XG4gICAgICAgICAgdXBkYXRlRWxlbWVudFNjb3BlSWRzKGNoaWxkTm9kZSwgZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgcmVuZGVyVmRvbSA9IChob3N0UmVmLCByZW5kZXJGblJlc3VsdHMsIGlzSW5pdGlhbExvYWQgPSBmYWxzZSkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICBjb25zdCBob3N0RWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gIGNvbnN0IG9sZFZOb2RlID0gaG9zdFJlZi4kdm5vZGUkIHx8IG5ld1ZOb2RlKG51bGwsIG51bGwpO1xuICBjb25zdCByb290Vm5vZGUgPSBpc0hvc3QocmVuZGVyRm5SZXN1bHRzKSA/IHJlbmRlckZuUmVzdWx0cyA6IGgobnVsbCwgbnVsbCwgcmVuZGVyRm5SZXN1bHRzKTtcbiAgaG9zdFRhZ05hbWUgPSBob3N0RWxtLnRhZ05hbWU7XG4gIGlmIChCVUlMRDE2LmlzRGV2ICYmIEFycmF5LmlzQXJyYXkocmVuZGVyRm5SZXN1bHRzKSAmJiByZW5kZXJGblJlc3VsdHMuc29tZShpc0hvc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgPEhvc3Q+IG11c3QgYmUgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudC5cbkxvb2tzIGxpa2UgdGhlIHJlbmRlcigpIGZ1bmN0aW9uIG9mIFwiJHtob3N0VGFnTmFtZS50b0xvd2VyQ2FzZSgpfVwiIGlzIHJldHVybmluZyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSA8SG9zdD4uXG5cblRoZSByZW5kZXIoKSBmdW5jdGlvbiBzaG91bGQgbG9vayBsaWtlIHRoaXMgaW5zdGVhZDpcblxucmVuZGVyKCkge1xuICAvLyBEbyBub3QgcmV0dXJuIGFuIGFycmF5XG4gIHJldHVybiAoXG4gICAgPEhvc3Q+e2NvbnRlbnR9PC9Ib3N0PlxuICApO1xufVxuICBgKTtcbiAgfVxuICBpZiAoQlVJTEQxNi5yZWZsZWN0ICYmIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCkge1xuICAgIHJvb3RWbm9kZS4kYXR0cnMkID0gcm9vdFZub2RlLiRhdHRycyQgfHwge307XG4gICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkLm1hcChcbiAgICAgIChbcHJvcE5hbWUsIGF0dHJpYnV0ZV0pID0+IHJvb3RWbm9kZS4kYXR0cnMkW2F0dHJpYnV0ZV0gPSBob3N0RWxtW3Byb3BOYW1lXVxuICAgICk7XG4gIH1cbiAgaWYgKGlzSW5pdGlhbExvYWQgJiYgcm9vdFZub2RlLiRhdHRycyQpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyb290Vm5vZGUuJGF0dHJzJCkpIHtcbiAgICAgIGlmIChob3N0RWxtLmhhc0F0dHJpYnV0ZShrZXkpICYmICFbXCJrZXlcIiwgXCJyZWZcIiwgXCJzdHlsZVwiLCBcImNsYXNzXCJdLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcm9vdFZub2RlLiRhdHRycyRba2V5XSA9IGhvc3RFbG1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcm9vdFZub2RlLiR0YWckID0gbnVsbDtcbiAgcm9vdFZub2RlLiRmbGFncyQgfD0gNCAvKiBpc0hvc3QgKi87XG4gIGhvc3RSZWYuJHZub2RlJCA9IHJvb3RWbm9kZTtcbiAgcm9vdFZub2RlLiRlbG0kID0gb2xkVk5vZGUuJGVsbSQgPSBCVUlMRDE2LnNoYWRvd0RvbSA/IGhvc3RFbG0uc2hhZG93Um9vdCB8fCBob3N0RWxtIDogaG9zdEVsbTtcbiAgaWYgKEJVSUxEMTYuc2NvcGVkIHx8IEJVSUxEMTYuc2hhZG93RG9tKSB7XG4gICAgc2NvcGVJZCA9IGhvc3RFbG1bXCJzLXNjXCJdO1xuICB9XG4gIHVzZU5hdGl2ZVNoYWRvd0RvbSA9IHN1cHBvcnRzU2hhZG93ICYmIChjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pICE9PSAwO1xuICBpZiAoQlVJTEQxNi5zbG90UmVsb2NhdGlvbikge1xuICAgIGNvbnRlbnRSZWYgPSBob3N0RWxtW1wicy1jclwiXTtcbiAgICBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSBmYWxzZTtcbiAgfVxuICBwYXRjaChvbGRWTm9kZSwgcm9vdFZub2RlLCBpc0luaXRpYWxMb2FkKTtcbiAgaWYgKEJVSUxEMTYuc2xvdFJlbG9jYXRpb24pIHtcbiAgICBwbHQuJGZsYWdzJCB8PSAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovO1xuICAgIGlmIChjaGVja1Nsb3RSZWxvY2F0ZSkge1xuICAgICAgbWFya1Nsb3RDb250ZW50Rm9yUmVsb2NhdGlvbihyb290Vm5vZGUuJGVsbSQpO1xuICAgICAgZm9yIChjb25zdCByZWxvY2F0ZURhdGEgb2YgcmVsb2NhdGVOb2Rlcykge1xuICAgICAgICBjb25zdCBub2RlVG9SZWxvY2F0ZSA9IHJlbG9jYXRlRGF0YS4kbm9kZVRvUmVsb2NhdGUkO1xuICAgICAgICBpZiAoIW5vZGVUb1JlbG9jYXRlW1wicy1vbFwiXSkge1xuICAgICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uTm9kZSA9IEJVSUxEMTYuaXNEZWJ1ZyB8fCBCVUlMRDE2Lmh5ZHJhdGVTZXJ2ZXJTaWRlID8gb3JpZ2luYWxMb2NhdGlvbkRlYnVnTm9kZShub2RlVG9SZWxvY2F0ZSkgOiBkb2MuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICAgICAgb3JnTG9jYXRpb25Ob2RlW1wicy1uclwiXSA9IG5vZGVUb1JlbG9jYXRlO1xuICAgICAgICAgIGluc2VydEJlZm9yZShub2RlVG9SZWxvY2F0ZS5wYXJlbnROb2RlLCBub2RlVG9SZWxvY2F0ZVtcInMtb2xcIl0gPSBvcmdMb2NhdGlvbk5vZGUsIG5vZGVUb1JlbG9jYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCByZWxvY2F0ZURhdGEgb2YgcmVsb2NhdGVOb2Rlcykge1xuICAgICAgICBjb25zdCBub2RlVG9SZWxvY2F0ZSA9IHJlbG9jYXRlRGF0YS4kbm9kZVRvUmVsb2NhdGUkO1xuICAgICAgICBjb25zdCBzbG90UmVmTm9kZSA9IHJlbG9jYXRlRGF0YS4kc2xvdFJlZk5vZGUkO1xuICAgICAgICBpZiAoc2xvdFJlZk5vZGUpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnROb2RlUmVmID0gc2xvdFJlZk5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICBsZXQgaW5zZXJ0QmVmb3JlTm9kZSA9IHNsb3RSZWZOb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGlmICghQlVJTEQxNi5leHBlcmltZW50YWxTbG90Rml4ZXMgfHwgaW5zZXJ0QmVmb3JlTm9kZSAmJiBpbnNlcnRCZWZvcmVOb2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICBsZXQgb3JnTG9jYXRpb25Ob2RlID0gKF9hID0gbm9kZVRvUmVsb2NhdGVbXCJzLW9sXCJdKSA9PSBudWxsID8gdm9pZCAwIDogX2EucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgd2hpbGUgKG9yZ0xvY2F0aW9uTm9kZSkge1xuICAgICAgICAgICAgICBsZXQgcmVmTm9kZSA9IChfYiA9IG9yZ0xvY2F0aW9uTm9kZVtcInMtbnJcIl0pICE9IG51bGwgPyBfYiA6IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZWZOb2RlICYmIHJlZk5vZGVbXCJzLXNuXCJdID09PSBub2RlVG9SZWxvY2F0ZVtcInMtc25cIl0gJiYgcGFyZW50Tm9kZVJlZiA9PT0gcmVmTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVmTm9kZSA9IHJlZk5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlZk5vZGUgPT09IG5vZGVUb1JlbG9jYXRlIHx8IChyZWZOb2RlID09IG51bGwgPyB2b2lkIDAgOiByZWZOb2RlW1wicy1zclwiXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJlZk5vZGUgPSByZWZOb2RlID09IG51bGwgPyB2b2lkIDAgOiByZWZOb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlZk5vZGUgfHwgIXJlZk5vZGVbXCJzLW5yXCJdKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVOb2RlID0gcmVmTm9kZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUgPSBvcmdMb2NhdGlvbk5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWluc2VydEJlZm9yZU5vZGUgJiYgcGFyZW50Tm9kZVJlZiAhPT0gbm9kZVRvUmVsb2NhdGUucGFyZW50Tm9kZSB8fCBub2RlVG9SZWxvY2F0ZS5uZXh0U2libGluZyAhPT0gaW5zZXJ0QmVmb3JlTm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlICE9PSBpbnNlcnRCZWZvcmVOb2RlKSB7XG4gICAgICAgICAgICAgIGlmICghQlVJTEQxNi5leHBlcmltZW50YWxTbG90Rml4ZXMgJiYgIW5vZGVUb1JlbG9jYXRlW1wicy1oblwiXSAmJiBub2RlVG9SZWxvY2F0ZVtcInMtb2xcIl0pIHtcbiAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZVtcInMtaG5cIl0gPSBub2RlVG9SZWxvY2F0ZVtcInMtb2xcIl0ucGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50Tm9kZVJlZiwgbm9kZVRvUmVsb2NhdGUsIGluc2VydEJlZm9yZU5vZGUpO1xuICAgICAgICAgICAgICBpZiAobm9kZVRvUmVsb2NhdGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5oaWRkZW4gPSAoX2MgPSBub2RlVG9SZWxvY2F0ZVtcInMtaWhcIl0pICE9IG51bGwgPyBfYyA6IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVUb1JlbG9jYXRlICYmIHR5cGVvZiBzbG90UmVmTm9kZVtcInMtcmZcIl0gPT09IFwiZnVuY3Rpb25cIiAmJiBzbG90UmVmTm9kZVtcInMtcmZcIl0obm9kZVRvUmVsb2NhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGVbXCJzLWloXCJdID0gKF9kID0gbm9kZVRvUmVsb2NhdGUuaGlkZGVuKSAhPSBudWxsID8gX2QgOiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkpIHtcbiAgICAgIHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkocm9vdFZub2RlLiRlbG0kKTtcbiAgICB9XG4gICAgcGx0LiRmbGFncyQgJj0gfjEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG4gICAgcmVsb2NhdGVOb2Rlcy5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChCVUlMRDE2LmV4cGVyaW1lbnRhbFNjb3BlZFNsb3RDaGFuZ2VzICYmIGNtcE1ldGEuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgIGZvciAoY29uc3QgY2hpbGROb2RlIG9mIHJvb3RWbm9kZS4kZWxtJC5jaGlsZE5vZGVzKSB7XG4gICAgICBpZiAoY2hpbGROb2RlW1wicy1oblwiXSAhPT0gaG9zdFRhZ05hbWUgJiYgIWNoaWxkTm9kZVtcInMtc2hcIl0pIHtcbiAgICAgICAgaWYgKGlzSW5pdGlhbExvYWQgJiYgY2hpbGROb2RlW1wicy1paFwiXSA9PSBudWxsKSB7XG4gICAgICAgICAgY2hpbGROb2RlW1wicy1paFwiXSA9IChfZSA9IGNoaWxkTm9kZS5oaWRkZW4pICE9IG51bGwgPyBfZSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkTm9kZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb250ZW50UmVmID0gdm9pZCAwO1xufTtcbnZhciBzbG90UmVmZXJlbmNlRGVidWdOb2RlID0gKHNsb3RWTm9kZSkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQoXG4gIGA8c2xvdCR7c2xvdFZOb2RlLiRuYW1lJCA/ICcgbmFtZT1cIicgKyBzbG90Vk5vZGUuJG5hbWUkICsgJ1wiJyA6IFwiXCJ9PiAoaG9zdD0ke2hvc3RUYWdOYW1lLnRvTG93ZXJDYXNlKCl9KWBcbik7XG52YXIgb3JpZ2luYWxMb2NhdGlvbkRlYnVnTm9kZSA9IChub2RlVG9SZWxvY2F0ZSkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQoXG4gIGBvcmctbG9jYXRpb24gZm9yIGAgKyAobm9kZVRvUmVsb2NhdGUubG9jYWxOYW1lID8gYDwke25vZGVUb1JlbG9jYXRlLmxvY2FsTmFtZX0+IChob3N0PSR7bm9kZVRvUmVsb2NhdGVbXCJzLWhuXCJdfSlgIDogYFske25vZGVUb1JlbG9jYXRlLnRleHRDb250ZW50fV1gKVxuKTtcblxuLy8gc3JjL3J1bnRpbWUvdXBkYXRlLWNvbXBvbmVudC50c1xudmFyIGF0dGFjaFRvQW5jZXN0b3IgPSAoaG9zdFJlZiwgYW5jZXN0b3JDb21wb25lbnQpID0+IHtcbiAgaWYgKEJVSUxEMTcuYXN5bmNMb2FkaW5nICYmIGFuY2VzdG9yQ29tcG9uZW50ICYmICFob3N0UmVmLiRvblJlbmRlclJlc29sdmUkICYmIGFuY2VzdG9yQ29tcG9uZW50W1wicy1wXCJdKSB7XG4gICAgYW5jZXN0b3JDb21wb25lbnRbXCJzLXBcIl0ucHVzaChuZXcgUHJvbWlzZSgocikgPT4gaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCA9IHIpKTtcbiAgfVxufTtcbnZhciBzY2hlZHVsZVVwZGF0ZSA9IChob3N0UmVmLCBpc0luaXRpYWxMb2FkKSA9PiB7XG4gIGlmIChCVUlMRDE3LnRhc2tRdWV1ZSAmJiBCVUlMRDE3LnVwZGF0YWJsZSkge1xuICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLztcbiAgfVxuICBpZiAoQlVJTEQxNy5hc3luY0xvYWRpbmcgJiYgaG9zdFJlZi4kZmxhZ3MkICYgNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLykge1xuICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA1MTIgLyogbmVlZHNSZXJlbmRlciAqLztcbiAgICByZXR1cm47XG4gIH1cbiAgYXR0YWNoVG9BbmNlc3Rvcihob3N0UmVmLCBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQpO1xuICBjb25zdCBkaXNwYXRjaCA9ICgpID0+IGRpc3BhdGNoSG9va3MoaG9zdFJlZiwgaXNJbml0aWFsTG9hZCk7XG4gIHJldHVybiBCVUlMRDE3LnRhc2tRdWV1ZSA/IHdyaXRlVGFzayhkaXNwYXRjaCkgOiBkaXNwYXRjaCgpO1xufTtcbnZhciBkaXNwYXRjaEhvb2tzID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICBjb25zdCBlbmRTY2hlZHVsZSA9IGNyZWF0ZVRpbWUoXCJzY2hlZHVsZVVwZGF0ZVwiLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICBjb25zdCBpbnN0YW5jZSA9IEJVSUxEMTcubGF6eUxvYWQgPyBob3N0UmVmLiRsYXp5SW5zdGFuY2UkIDogZWxtO1xuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbid0IHJlbmRlciBjb21wb25lbnQgPCR7ZWxtLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0gLz4gd2l0aCBpbnZhbGlkIFN0ZW5jaWwgcnVudGltZSEgTWFrZSBzdXJlIHRoaXMgaW1wb3J0ZWQgY29tcG9uZW50IGlzIGNvbXBpbGVkIHdpdGggYSBcXGBleHRlcm5hbFJ1bnRpbWU6IHRydWVcXGAgZmxhZy4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHBsZWFzZSByZWZlciB0byBodHRwczovL3N0ZW5jaWxqcy5jb20vZG9jcy9jdXN0b20tZWxlbWVudHMjZXh0ZXJuYWxydW50aW1lYFxuICAgICk7XG4gIH1cbiAgbGV0IG1heWJlUHJvbWlzZTtcbiAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICBpZiAoQlVJTEQxNy5sYXp5TG9hZCAmJiBCVUlMRDE3Lmhvc3RMaXN0ZW5lcikge1xuICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDI1NiAvKiBpc0xpc3RlblJlYWR5ICovO1xuICAgICAgaWYgKGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQpIHtcbiAgICAgICAgaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJC5tYXAoKFttZXRob2ROYW1lLCBldmVudF0pID0+IHNhZmVDYWxsKGluc3RhbmNlLCBtZXRob2ROYW1lLCBldmVudCkpO1xuICAgICAgICBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCBcImNvbXBvbmVudFdpbGxMb2FkXCIpO1xuICAgIGlmIChCVUlMRDE3LmNtcFdpbGxMb2FkKSB7XG4gICAgICBtYXliZVByb21pc2UgPSBzYWZlQ2FsbChpbnN0YW5jZSwgXCJjb21wb25lbnRXaWxsTG9hZFwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgXCJjb21wb25lbnRXaWxsVXBkYXRlXCIpO1xuICAgIGlmIChCVUlMRDE3LmNtcFdpbGxVcGRhdGUpIHtcbiAgICAgIG1heWJlUHJvbWlzZSA9IHNhZmVDYWxsKGluc3RhbmNlLCBcImNvbXBvbmVudFdpbGxVcGRhdGVcIik7XG4gICAgfVxuICB9XG4gIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sIFwiY29tcG9uZW50V2lsbFJlbmRlclwiKTtcbiAgaWYgKEJVSUxEMTcuY21wV2lsbFJlbmRlcikge1xuICAgIG1heWJlUHJvbWlzZSA9IGVucXVldWUobWF5YmVQcm9taXNlLCAoKSA9PiBzYWZlQ2FsbChpbnN0YW5jZSwgXCJjb21wb25lbnRXaWxsUmVuZGVyXCIpKTtcbiAgfVxuICBlbmRTY2hlZHVsZSgpO1xuICByZXR1cm4gZW5xdWV1ZShtYXliZVByb21pc2UsICgpID0+IHVwZGF0ZUNvbXBvbmVudChob3N0UmVmLCBpbnN0YW5jZSwgaXNJbml0aWFsTG9hZCkpO1xufTtcbnZhciBlbnF1ZXVlID0gKG1heWJlUHJvbWlzZSwgZm4pID0+IGlzUHJvbWlzZXkobWF5YmVQcm9taXNlKSA/IG1heWJlUHJvbWlzZS50aGVuKGZuKS5jYXRjaCgoZXJyMikgPT4ge1xuICBjb25zb2xlLmVycm9yKGVycjIpO1xuICBmbigpO1xufSkgOiBmbigpO1xudmFyIGlzUHJvbWlzZXkgPSAobWF5YmVQcm9taXNlKSA9PiBtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IG1heWJlUHJvbWlzZSAmJiBtYXliZVByb21pc2UudGhlbiAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbnZhciB1cGRhdGVDb21wb25lbnQgPSBhc3luYyAoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gIGNvbnN0IGVuZFVwZGF0ZSA9IGNyZWF0ZVRpbWUoXCJ1cGRhdGVcIiwgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgY29uc3QgcmMgPSBlbG1bXCJzLXJjXCJdO1xuICBpZiAoQlVJTEQxNy5zdHlsZSAmJiBpc0luaXRpYWxMb2FkKSB7XG4gICAgYXR0YWNoU3R5bGVzKGhvc3RSZWYpO1xuICB9XG4gIGNvbnN0IGVuZFJlbmRlciA9IGNyZWF0ZVRpbWUoXCJyZW5kZXJcIiwgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgaWYgKEJVSUxEMTcuaXNEZXYpIHtcbiAgICBob3N0UmVmLiRmbGFncyQgfD0gMTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgfVxuICBpZiAoQlVJTEQxNy5oeWRyYXRlU2VydmVyU2lkZSkge1xuICAgIGF3YWl0IGNhbGxSZW5kZXIoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSwgaXNJbml0aWFsTG9hZCk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbFJlbmRlcihob3N0UmVmLCBpbnN0YW5jZSwgZWxtLCBpc0luaXRpYWxMb2FkKTtcbiAgfVxuICBpZiAoQlVJTEQxNy5pc0Rldikge1xuICAgIGhvc3RSZWYuJHJlbmRlckNvdW50JCA9IGhvc3RSZWYuJHJlbmRlckNvdW50JCA9PT0gdm9pZCAwID8gMSA6IGhvc3RSZWYuJHJlbmRlckNvdW50JCArIDE7XG4gICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICB9XG4gIGlmIChCVUlMRDE3Lmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlcnZlclNpZGVDb25uZWN0ZWQoZWxtKTtcbiAgICAgIGlmIChpc0luaXRpYWxMb2FkKSB7XG4gICAgICAgIGlmIChob3N0UmVmLiRjbXBNZXRhJC4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgZWxtW1wicy1lblwiXSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaG9zdFJlZi4kY21wTWV0YSQuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgIGVsbVtcInMtZW5cIl0gPSBcImNcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgIH1cbiAgfVxuICBpZiAoQlVJTEQxNy5hc3luY0xvYWRpbmcgJiYgcmMpIHtcbiAgICByYy5tYXAoKGNiKSA9PiBjYigpKTtcbiAgICBlbG1bXCJzLXJjXCJdID0gdm9pZCAwO1xuICB9XG4gIGVuZFJlbmRlcigpO1xuICBlbmRVcGRhdGUoKTtcbiAgaWYgKEJVSUxEMTcuYXN5bmNMb2FkaW5nKSB7XG4gICAgY29uc3QgY2hpbGRyZW5Qcm9taXNlcyA9IChfYSA9IGVsbVtcInMtcFwiXSkgIT0gbnVsbCA/IF9hIDogW107XG4gICAgY29uc3QgcG9zdFVwZGF0ZSA9ICgpID0+IHBvc3RVcGRhdGVDb21wb25lbnQoaG9zdFJlZik7XG4gICAgaWYgKGNoaWxkcmVuUHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBwb3N0VXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFByb21pc2UuYWxsKGNoaWxkcmVuUHJvbWlzZXMpLnRoZW4ocG9zdFVwZGF0ZSk7XG4gICAgICBob3N0UmVmLiRmbGFncyQgfD0gNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLztcbiAgICAgIGNoaWxkcmVuUHJvbWlzZXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9zdFVwZGF0ZUNvbXBvbmVudChob3N0UmVmKTtcbiAgfVxufTtcbnZhciByZW5kZXJpbmdSZWYgPSBudWxsO1xudmFyIGNhbGxSZW5kZXIgPSAoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSwgaXNJbml0aWFsTG9hZCkgPT4ge1xuICBjb25zdCBhbGxSZW5kZXJGbiA9IEJVSUxEMTcuYWxsUmVuZGVyRm4gPyB0cnVlIDogZmFsc2U7XG4gIGNvbnN0IGxhenlMb2FkID0gQlVJTEQxNy5sYXp5TG9hZCA/IHRydWUgOiBmYWxzZTtcbiAgY29uc3QgdGFza1F1ZXVlID0gQlVJTEQxNy50YXNrUXVldWUgPyB0cnVlIDogZmFsc2U7XG4gIGNvbnN0IHVwZGF0YWJsZSA9IEJVSUxEMTcudXBkYXRhYmxlID8gdHJ1ZSA6IGZhbHNlO1xuICB0cnkge1xuICAgIHJlbmRlcmluZ1JlZiA9IGluc3RhbmNlO1xuICAgIGluc3RhbmNlID0gYWxsUmVuZGVyRm4gPyBpbnN0YW5jZS5yZW5kZXIoKSA6IGluc3RhbmNlLnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICBpZiAodXBkYXRhYmxlICYmIHRhc2tRdWV1ZSkge1xuICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLztcbiAgICB9XG4gICAgaWYgKHVwZGF0YWJsZSB8fCBsYXp5TG9hZCkge1xuICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDIgLyogaGFzUmVuZGVyZWQgKi87XG4gICAgfVxuICAgIGlmIChCVUlMRDE3Lmhhc1JlbmRlckZuIHx8IEJVSUxEMTcucmVmbGVjdCkge1xuICAgICAgaWYgKEJVSUxEMTcudmRvbVJlbmRlciB8fCBCVUlMRDE3LnJlZmxlY3QpIHtcbiAgICAgICAgaWYgKEJVSUxEMTcuaHlkcmF0ZVNlcnZlclNpZGUpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluc3RhbmNlKS50aGVuKCh2YWx1ZSkgPT4gcmVuZGVyVmRvbShob3N0UmVmLCB2YWx1ZSwgaXNJbml0aWFsTG9hZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlclZkb20oaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxtLnNoYWRvd1Jvb3Q7XG4gICAgICAgIGlmIChob3N0UmVmLiRjbXBNZXRhJC4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgc2hhZG93Um9vdC50ZXh0Q29udGVudCA9IGluc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbS50ZXh0Q29udGVudCA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZUVycm9yKGUsIGhvc3RSZWYuJGhvc3RFbGVtZW50JCk7XG4gIH1cbiAgcmVuZGVyaW5nUmVmID0gbnVsbDtcbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIGdldFJlbmRlcmluZ1JlZiA9ICgpID0+IHJlbmRlcmluZ1JlZjtcbnZhciBwb3N0VXBkYXRlQ29tcG9uZW50ID0gKGhvc3RSZWYpID0+IHtcbiAgY29uc3QgdGFnTmFtZSA9IGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJDtcbiAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICBjb25zdCBlbmRQb3N0VXBkYXRlID0gY3JlYXRlVGltZShcInBvc3RVcGRhdGVcIiwgdGFnTmFtZSk7XG4gIGNvbnN0IGluc3RhbmNlID0gQlVJTEQxNy5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50ID0gaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkO1xuICBpZiAoQlVJTEQxNy5jbXBEaWRSZW5kZXIpIHtcbiAgICBpZiAoQlVJTEQxNy5pc0Rldikge1xuICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgfVxuICAgIHNhZmVDYWxsKGluc3RhbmNlLCBcImNvbXBvbmVudERpZFJlbmRlclwiKTtcbiAgICBpZiAoQlVJTEQxNy5pc0Rldikge1xuICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgIH1cbiAgfVxuICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCBcImNvbXBvbmVudERpZFJlbmRlclwiKTtcbiAgaWYgKCEoaG9zdFJlZi4kZmxhZ3MkICYgNjQgLyogaGFzTG9hZGVkQ29tcG9uZW50ICovKSkge1xuICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi87XG4gICAgaWYgKEJVSUxEMTcuYXN5bmNMb2FkaW5nICYmIEJVSUxEMTcuY3NzQW5ub3RhdGlvbnMpIHtcbiAgICAgIGFkZEh5ZHJhdGVkRmxhZyhlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQxNy5jbXBEaWRMb2FkKSB7XG4gICAgICBpZiAoQlVJTEQxNy5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMjA0OCAvKiBkZXZPbkRpZExvYWQgKi87XG4gICAgICB9XG4gICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgXCJjb21wb25lbnREaWRMb2FkXCIpO1xuICAgICAgaWYgKEJVSUxEMTcuaXNEZXYpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4yMDQ4IC8qIGRldk9uRGlkTG9hZCAqLztcbiAgICAgIH1cbiAgICB9XG4gICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgXCJjb21wb25lbnREaWRMb2FkXCIpO1xuICAgIGVuZFBvc3RVcGRhdGUoKTtcbiAgICBpZiAoQlVJTEQxNy5hc3luY0xvYWRpbmcpIHtcbiAgICAgIGhvc3RSZWYuJG9uUmVhZHlSZXNvbHZlJChlbG0pO1xuICAgICAgaWYgKCFhbmNlc3RvckNvbXBvbmVudCkge1xuICAgICAgICBhcHBEaWRMb2FkKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoQlVJTEQxNy5jbXBEaWRVcGRhdGUpIHtcbiAgICAgIGlmIChCVUlMRDE3LmlzRGV2KSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgfVxuICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsIFwiY29tcG9uZW50RGlkVXBkYXRlXCIpO1xuICAgICAgaWYgKEJVSUxEMTcuaXNEZXYpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgfVxuICAgIH1cbiAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCBcImNvbXBvbmVudERpZFVwZGF0ZVwiKTtcbiAgICBlbmRQb3N0VXBkYXRlKCk7XG4gIH1cbiAgaWYgKEJVSUxEMTcubWV0aG9kICYmIEJVSUxEMTcubGF6eUxvYWQpIHtcbiAgICBob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQoZWxtKTtcbiAgfVxuICBpZiAoQlVJTEQxNy5hc3luY0xvYWRpbmcpIHtcbiAgICBpZiAoaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCkge1xuICAgICAgaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCgpO1xuICAgICAgaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKSB7XG4gICAgICBuZXh0VGljaygoKSA9PiBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSkpO1xuICAgIH1cbiAgICBob3N0UmVmLiRmbGFncyQgJj0gfig0IC8qIGlzV2FpdGluZ0ZvckNoaWxkcmVuICovIHwgNTEyIC8qIG5lZWRzUmVyZW5kZXIgKi8pO1xuICB9XG59O1xudmFyIGZvcmNlVXBkYXRlID0gKHJlZikgPT4ge1xuICBpZiAoQlVJTEQxNy51cGRhdGFibGUgJiYgKEJ1aWxkLmlzQnJvd3NlciB8fCBCdWlsZC5pc1Rlc3RpbmcpKSB7XG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICBjb25zdCBpc0Nvbm5lY3RlZCA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JC5pc0Nvbm5lY3RlZDtcbiAgICBpZiAoaXNDb25uZWN0ZWQgJiYgKGhvc3RSZWYuJGZsYWdzJCAmICgyIC8qIGhhc1JlbmRlcmVkICovIHwgMTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi8pKSA9PT0gMiAvKiBoYXNSZW5kZXJlZCAqLykge1xuICAgICAgc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gaXNDb25uZWN0ZWQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBhcHBEaWRMb2FkID0gKHdobykgPT4ge1xuICBpZiAoQlVJTEQxNy5jc3NBbm5vdGF0aW9ucykge1xuICAgIGFkZEh5ZHJhdGVkRmxhZyhkb2MuZG9jdW1lbnRFbGVtZW50KTtcbiAgfVxuICBpZiAoQlVJTEQxNy5hc3luY1F1ZXVlKSB7XG4gICAgcGx0LiRmbGFncyQgfD0gMiAvKiBhcHBMb2FkZWQgKi87XG4gIH1cbiAgbmV4dFRpY2soKCkgPT4gZW1pdEV2ZW50KHdpbiwgXCJhcHBsb2FkXCIsIHsgZGV0YWlsOiB7IG5hbWVzcGFjZTogTkFNRVNQQUNFIH0gfSkpO1xuICBpZiAoQlVJTEQxNy5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1lYXN1cmUpIHtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKGBbU3RlbmNpbF0gJHtOQU1FU1BBQ0V9IGluaXRpYWwgbG9hZCAoYnkgJHt3aG99KWAsIFwic3Q6YXBwOnN0YXJ0XCIpO1xuICB9XG59O1xudmFyIHNhZmVDYWxsID0gKGluc3RhbmNlLCBtZXRob2QsIGFyZykgPT4ge1xuICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2VbbWV0aG9kXSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2VbbWV0aG9kXShhcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn07XG52YXIgZW1pdExpZmVjeWNsZUV2ZW50ID0gKGVsbSwgbGlmZWN5Y2xlTmFtZSkgPT4ge1xuICBpZiAoQlVJTEQxNy5saWZlY3ljbGVET01FdmVudHMpIHtcbiAgICBlbWl0RXZlbnQoZWxtLCBcInN0ZW5jaWxfXCIgKyBsaWZlY3ljbGVOYW1lLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICBkZXRhaWw6IHtcbiAgICAgICAgbmFtZXNwYWNlOiBOQU1FU1BBQ0VcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbnZhciBhZGRIeWRyYXRlZEZsYWcgPSAoZWxtKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiBCVUlMRDE3Lmh5ZHJhdGVkQ2xhc3MgPyBlbG0uY2xhc3NMaXN0LmFkZCgoX2EgPSBCVUlMRDE3Lmh5ZHJhdGVkU2VsZWN0b3JOYW1lKSAhPSBudWxsID8gX2EgOiBcImh5ZHJhdGVkXCIpIDogQlVJTEQxNy5oeWRyYXRlZEF0dHJpYnV0ZSA/IGVsbS5zZXRBdHRyaWJ1dGUoKF9iID0gQlVJTEQxNy5oeWRyYXRlZFNlbGVjdG9yTmFtZSkgIT0gbnVsbCA/IF9iIDogXCJoeWRyYXRlZFwiLCBcIlwiKSA6IHZvaWQgMDtcbn07XG52YXIgc2VydmVyU2lkZUNvbm5lY3RlZCA9IChlbG0pID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBlbG0uY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgZm9yIChsZXQgaTIgPSAwLCBpaSA9IGNoaWxkcmVuLmxlbmd0aDsgaTIgPCBpaTsgaTIrKykge1xuICAgICAgY29uc3QgY2hpbGRFbG0gPSBjaGlsZHJlbltpMl07XG4gICAgICBpZiAodHlwZW9mIGNoaWxkRWxtLmNvbm5lY3RlZENhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2hpbGRFbG0uY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHNlcnZlclNpZGVDb25uZWN0ZWQoY2hpbGRFbG0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3J1bnRpbWUvc2V0LXZhbHVlLnRzXG52YXIgZ2V0VmFsdWUgPSAocmVmLCBwcm9wTmFtZSkgPT4gZ2V0SG9zdFJlZihyZWYpLiRpbnN0YW5jZVZhbHVlcyQuZ2V0KHByb3BOYW1lKTtcbnZhciBzZXRWYWx1ZSA9IChyZWYsIHByb3BOYW1lLCBuZXdWYWwsIGNtcE1ldGEpID0+IHtcbiAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgaWYgKEJVSUxEMTgubGF6eUxvYWQgJiYgIWhvc3RSZWYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ291bGRuJ3QgZmluZCBob3N0IGVsZW1lbnQgZm9yIFwiJHtjbXBNZXRhLiR0YWdOYW1lJH1cIiBhcyBpdCBpcyB1bmtub3duIHRvIHRoaXMgU3RlbmNpbCBydW50aW1lLiBUaGlzIHVzdWFsbHkgaGFwcGVucyB3aGVuIGludGVncmF0aW5nIGEgM3JkIHBhcnR5IFN0ZW5jaWwgY29tcG9uZW50IHdpdGggYW5vdGhlciBTdGVuY2lsIGNvbXBvbmVudCBvciBhcHBsaWNhdGlvbi4gUGxlYXNlIHJlYWNoIG91dCB0byB0aGUgbWFpbnRhaW5lcnMgb2YgdGhlIDNyZCBwYXJ0eSBTdGVuY2lsIGNvbXBvbmVudCBvciByZXBvcnQgdGhpcyBvbiB0aGUgU3RlbmNpbCBEaXNjb3JkIHNlcnZlciAoaHR0cHM6Ly9jaGF0LnN0ZW5jaWxqcy5jb20pIG9yIGNvbW1lbnQgb24gdGhpcyBzaW1pbGFyIFtHaXRIdWIgaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9pb25pYy10ZWFtL3N0ZW5jaWwvaXNzdWVzLzU0NTcpLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IGVsbSA9IEJVSUxEMTgubGF6eUxvYWQgPyBob3N0UmVmLiRob3N0RWxlbWVudCQgOiByZWY7XG4gIGNvbnN0IG9sZFZhbCA9IGhvc3RSZWYuJGluc3RhbmNlVmFsdWVzJC5nZXQocHJvcE5hbWUpO1xuICBjb25zdCBmbGFncyA9IGhvc3RSZWYuJGZsYWdzJDtcbiAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRDE4LmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgbmV3VmFsID0gcGFyc2VQcm9wZXJ0eVZhbHVlKG5ld1ZhbCwgY21wTWV0YS4kbWVtYmVycyRbcHJvcE5hbWVdWzBdKTtcbiAgY29uc3QgYXJlQm90aE5hTiA9IE51bWJlci5pc05hTihvbGRWYWwpICYmIE51bWJlci5pc05hTihuZXdWYWwpO1xuICBjb25zdCBkaWRWYWx1ZUNoYW5nZSA9IG5ld1ZhbCAhPT0gb2xkVmFsICYmICFhcmVCb3RoTmFOO1xuICBpZiAoKCFCVUlMRDE4LmxhenlMb2FkIHx8ICEoZmxhZ3MgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pIHx8IG9sZFZhbCA9PT0gdm9pZCAwKSAmJiBkaWRWYWx1ZUNoYW5nZSkge1xuICAgIGhvc3RSZWYuJGluc3RhbmNlVmFsdWVzJC5zZXQocHJvcE5hbWUsIG5ld1ZhbCk7XG4gICAgaWYgKEJVSUxEMTguaXNEZXYpIHtcbiAgICAgIGlmIChob3N0UmVmLiRmbGFncyQgJiAxMDI0IC8qIGRldk9uUmVuZGVyICovKSB7XG4gICAgICAgIGNvbnNvbGVEZXZXYXJuKFxuICAgICAgICAgIGBUaGUgc3RhdGUvcHJvcCBcIiR7cHJvcE5hbWV9XCIgY2hhbmdlZCBkdXJpbmcgcmVuZGVyaW5nLiBUaGlzIGNhbiBwb3RlbnRpYWxseSBsZWFkIHRvIGluZmluaXRlLWxvb3BzIGFuZCBvdGhlciBidWdzLmAsXG4gICAgICAgICAgXCJcXG5FbGVtZW50XCIsXG4gICAgICAgICAgZWxtLFxuICAgICAgICAgIFwiXFxuTmV3IHZhbHVlXCIsXG4gICAgICAgICAgbmV3VmFsLFxuICAgICAgICAgIFwiXFxuT2xkIHZhbHVlXCIsXG4gICAgICAgICAgb2xkVmFsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDIwNDggLyogZGV2T25EaWRMb2FkICovKSB7XG4gICAgICAgIGNvbnNvbGVEZXZXYXJuKFxuICAgICAgICAgIGBUaGUgc3RhdGUvcHJvcCBcIiR7cHJvcE5hbWV9XCIgY2hhbmdlZCBkdXJpbmcgXCJjb21wb25lbnREaWRMb2FkKClcIiwgdGhpcyB0cmlnZ2VycyBleHRyYSByZS1yZW5kZXJzLCB0cnkgdG8gc2V0dXAgb24gXCJjb21wb25lbnRXaWxsTG9hZCgpXCJgLFxuICAgICAgICAgIFwiXFxuRWxlbWVudFwiLFxuICAgICAgICAgIGVsbSxcbiAgICAgICAgICBcIlxcbk5ldyB2YWx1ZVwiLFxuICAgICAgICAgIG5ld1ZhbCxcbiAgICAgICAgICBcIlxcbk9sZCB2YWx1ZVwiLFxuICAgICAgICAgIG9sZFZhbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIUJVSUxEMTgubGF6eUxvYWQgfHwgaW5zdGFuY2UpIHtcbiAgICAgIGlmIChCVUlMRDE4LndhdGNoQ2FsbGJhY2sgJiYgY21wTWV0YS4kd2F0Y2hlcnMkICYmIGZsYWdzICYgMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLykge1xuICAgICAgICBjb25zdCB3YXRjaE1ldGhvZHMgPSBjbXBNZXRhLiR3YXRjaGVycyRbcHJvcE5hbWVdO1xuICAgICAgICBpZiAod2F0Y2hNZXRob2RzKSB7XG4gICAgICAgICAgd2F0Y2hNZXRob2RzLm1hcCgod2F0Y2hNZXRob2ROYW1lKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpbnN0YW5jZVt3YXRjaE1ldGhvZE5hbWVdKG5ld1ZhbCwgb2xkVmFsLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoQlVJTEQxOC51cGRhdGFibGUgJiYgKGZsYWdzICYgKDIgLyogaGFzUmVuZGVyZWQgKi8gfCAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLykpID09PSAyIC8qIGhhc1JlbmRlcmVkICovKSB7XG4gICAgICAgIGlmIChCVUlMRDE4LmNtcFNob3VsZFVwZGF0ZSAmJiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlKG5ld1ZhbCwgb2xkVmFsLCBwcm9wTmFtZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ydW50aW1lL3Byb3h5LWNvbXBvbmVudC50c1xudmFyIHByb3h5Q29tcG9uZW50ID0gKENzdHIsIGNtcE1ldGEsIGZsYWdzKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHByb3RvdHlwZSA9IENzdHIucHJvdG90eXBlO1xuICBpZiAoQlVJTEQxOS5mb3JtQXNzb2NpYXRlZCAmJiBjbXBNZXRhLiRmbGFncyQgJiA2NCAvKiBmb3JtQXNzb2NpYXRlZCAqLyAmJiBmbGFncyAmIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8pIHtcbiAgICBGT1JNX0FTU09DSUFURURfQ1VTVE9NX0VMRU1FTlRfQ0FMTEJBQ0tTLmZvckVhY2goXG4gICAgICAoY2JOYW1lKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBjYk5hbWUsIHtcbiAgICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKHRoaXMpO1xuICAgICAgICAgIGNvbnN0IGVsbSA9IEJVSUxEMTkubGF6eUxvYWQgPyBob3N0UmVmLiRob3N0RWxlbWVudCQgOiB0aGlzO1xuICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gQlVJTEQxOS5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgICAgaG9zdFJlZi4kb25SZWFkeVByb21pc2UkLnRoZW4oKGluc3RhbmNlMikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjYiA9IGluc3RhbmNlMltjYk5hbWVdO1xuICAgICAgICAgICAgICB0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIiAmJiBjYi5jYWxsKGluc3RhbmNlMiwgLi4uYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2IgPSBpbnN0YW5jZVtjYk5hbWVdO1xuICAgICAgICAgICAgdHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIgJiYgY2IuY2FsbChpbnN0YW5jZSwgLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgaWYgKEJVSUxEMTkubWVtYmVyICYmIGNtcE1ldGEuJG1lbWJlcnMkIHx8IEJVSUxEMTkud2F0Y2hDYWxsYmFjayAmJiAoY21wTWV0YS4kd2F0Y2hlcnMkIHx8IENzdHIud2F0Y2hlcnMpKSB7XG4gICAgaWYgKEJVSUxEMTkud2F0Y2hDYWxsYmFjayAmJiBDc3RyLndhdGNoZXJzICYmICFjbXBNZXRhLiR3YXRjaGVycyQpIHtcbiAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgfVxuICAgIGNvbnN0IG1lbWJlcnMgPSBPYmplY3QuZW50cmllcygoX2EgPSBjbXBNZXRhLiRtZW1iZXJzJCkgIT0gbnVsbCA/IF9hIDoge30pO1xuICAgIG1lbWJlcnMubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgIGlmICgoQlVJTEQxOS5wcm9wIHx8IEJVSUxEMTkuc3RhdGUpICYmIChtZW1iZXJGbGFncyAmIDMxIC8qIFByb3AgKi8gfHwgKCFCVUlMRDE5LmxhenlMb2FkIHx8IGZsYWdzICYgMiAvKiBwcm94eVN0YXRlICovKSAmJiBtZW1iZXJGbGFncyAmIDMyIC8qIFN0YXRlICovKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBtZW1iZXJOYW1lLCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlKHRoaXMsIG1lbWJlck5hbWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoQlVJTEQxOS5pc0Rldikge1xuICAgICAgICAgICAgICBjb25zdCByZWYgPSBnZXRIb3N0UmVmKHRoaXMpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIHByb3h5aW5nIHRoZSBpbnN0YW5jZSAobm90IGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykgPT09IDAgJiYgLy8gdGhlIGVsZW1lbnQgaXMgbm90IGNvbnN0cnVjdGluZ1xuICAgICAgICAgICAgICAgIChyZWYgJiYgcmVmLiRmbGFncyQgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pID09PSAwICYmIC8vIHRoZSBtZW1iZXIgaXMgYSBwcm9wXG4gICAgICAgICAgICAgICAgKG1lbWJlckZsYWdzICYgMzEgLyogUHJvcCAqLykgIT09IDAgJiYgLy8gdGhlIG1lbWJlciBpcyBub3QgbXV0YWJsZVxuICAgICAgICAgICAgICAgIChtZW1iZXJGbGFncyAmIDEwMjQgLyogTXV0YWJsZSAqLykgPT09IDBcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oXG4gICAgICAgICAgICAgICAgICBgQFByb3AoKSBcIiR7bWVtYmVyTmFtZX1cIiBvbiA8JHtjbXBNZXRhLiR0YWdOYW1lJH0+IGlzIGltbXV0YWJsZSBidXQgd2FzIG1vZGlmaWVkIGZyb20gd2l0aGluIHRoZSBjb21wb25lbnQuXG5Nb3JlIGluZm9ybWF0aW9uOiBodHRwczovL3N0ZW5jaWxqcy5jb20vZG9jcy9wcm9wZXJ0aWVzI3Byb3AtbXV0YWJpbGl0eWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRWYWx1ZSh0aGlzLCBtZW1iZXJOYW1lLCBuZXdWYWx1ZSwgY21wTWV0YSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoQlVJTEQxOS5sYXp5TG9hZCAmJiBCVUlMRDE5Lm1ldGhvZCAmJiBmbGFncyAmIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8gJiYgbWVtYmVyRmxhZ3MgJiA2NCAvKiBNZXRob2QgKi8pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbWVtYmVyTmFtZSwge1xuICAgICAgICAgIHZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICBjb25zdCByZWYgPSBnZXRIb3N0UmVmKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIChfYTIgPSByZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi4kb25JbnN0YW5jZVByb21pc2UkKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hMyA9IHJlZi4kbGF6eUluc3RhbmNlJCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hM1ttZW1iZXJOYW1lXSguLi5hcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKEJVSUxEMTkub2JzZXJ2ZUF0dHJpYnV0ZSAmJiAoIUJVSUxEMTkubGF6eUxvYWQgfHwgZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovKSkge1xuICAgICAgY29uc3QgYXR0ck5hbWVUb1Byb3BOYW1lID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbihhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHBsdC5qbXAoKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBhdHRyTmFtZVRvUHJvcE5hbWUuZ2V0KGF0dHJOYW1lKTtcbiAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpc1twcm9wTmFtZV07XG4gICAgICAgICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmIHR5cGVvZiB0aGlzW3Byb3BOYW1lXSA9PT0gXCJudW1iZXJcIiAmJiB0aGlzW3Byb3BOYW1lXSA9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBmbGFnczIgPSBob3N0UmVmID09IG51bGwgPyB2b2lkIDAgOiBob3N0UmVmLiRmbGFncyQ7XG4gICAgICAgICAgICBpZiAoZmxhZ3MyICYmICEoZmxhZ3MyICYgOCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovKSAmJiBmbGFnczIgJiAxMjggLyogaXNXYXRjaFJlYWR5ICovICYmIG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICBjb25zdCBlbG0gPSBCVUlMRDE5LmxhenlMb2FkID8gaG9zdFJlZi4kaG9zdEVsZW1lbnQkIDogdGhpcztcbiAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRDE5LmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSAoX2EyID0gY21wTWV0YS4kd2F0Y2hlcnMkKSA9PSBudWxsID8gdm9pZCAwIDogX2EyW2F0dHJOYW1lXTtcbiAgICAgICAgICAgICAgZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJ5LmZvckVhY2goKGNhbGxiYWNrTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZVtjYWxsYmFja05hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlW2NhbGxiYWNrTmFtZV0uY2FsbChpbnN0YW5jZSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuZXdWYWx1ZSA9PT0gbnVsbCAmJiB0eXBlb2YgdGhpc1twcm9wTmFtZV0gPT09IFwiYm9vbGVhblwiID8gZmFsc2UgOiBuZXdWYWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgQ3N0ci5vYnNlcnZlZEF0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgICAgICAgLi4uT2JqZWN0LmtleXMoKF9iID0gY21wTWV0YS4kd2F0Y2hlcnMkKSAhPSBudWxsID8gX2IgOiB7fSksXG4gICAgICAgICAgLi4ubWVtYmVycy5maWx0ZXIoKFtfLCBtXSkgPT4gbVswXSAmIDE1IC8qIEhhc0F0dHJpYnV0ZSAqLykubWFwKChbcHJvcE5hbWUsIG1dKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgY29uc3QgYXR0ck5hbWUgPSBtWzFdIHx8IHByb3BOYW1lO1xuICAgICAgICAgICAgYXR0ck5hbWVUb1Byb3BOYW1lLnNldChhdHRyTmFtZSwgcHJvcE5hbWUpO1xuICAgICAgICAgICAgaWYgKEJVSUxEMTkucmVmbGVjdCAmJiBtWzBdICYgNTEyIC8qIFJlZmxlY3RBdHRyICovKSB7XG4gICAgICAgICAgICAgIChfYTIgPSBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucHVzaChbcHJvcE5hbWUsIGF0dHJOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXR0ck5hbWU7XG4gICAgICAgICAgfSlcbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBDc3RyO1xufTtcblxuLy8gc3JjL3J1bnRpbWUvaW5pdGlhbGl6ZS1jb21wb25lbnQudHNcbnZhciBpbml0aWFsaXplQ29tcG9uZW50ID0gYXN5bmMgKGVsbSwgaG9zdFJlZiwgY21wTWV0YSwgaG1yVmVyc2lvbklkKSA9PiB7XG4gIGxldCBDc3RyO1xuICBpZiAoKGhvc3RSZWYuJGZsYWdzJCAmIDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovKSA9PT0gMCkge1xuICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAzMiAvKiBoYXNJbml0aWFsaXplZENvbXBvbmVudCAqLztcbiAgICBjb25zdCBidW5kbGVJZCA9IGNtcE1ldGEuJGxhenlCdW5kbGVJZCQ7XG4gICAgaWYgKChCVUlMRDIwLmxhenlMb2FkIHx8IEJVSUxEMjAuaHlkcmF0ZUNsaWVudFNpZGUpICYmIGJ1bmRsZUlkKSB7XG4gICAgICBjb25zdCBDc3RySW1wb3J0ID0gbG9hZE1vZHVsZShjbXBNZXRhLCBob3N0UmVmLCBobXJWZXJzaW9uSWQpO1xuICAgICAgaWYgKENzdHJJbXBvcnQgJiYgXCJ0aGVuXCIgaW4gQ3N0ckltcG9ydCkge1xuICAgICAgICBjb25zdCBlbmRMb2FkID0gdW5pcXVlVGltZShcbiAgICAgICAgICBgc3Q6bG9hZDoke2NtcE1ldGEuJHRhZ05hbWUkfToke2hvc3RSZWYuJG1vZGVOYW1lJH1gLFxuICAgICAgICAgIGBbU3RlbmNpbF0gTG9hZCBtb2R1bGUgZm9yIDwke2NtcE1ldGEuJHRhZ05hbWUkfT5gXG4gICAgICAgICk7XG4gICAgICAgIENzdHIgPSBhd2FpdCBDc3RySW1wb3J0O1xuICAgICAgICBlbmRMb2FkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDc3RyID0gQ3N0ckltcG9ydDtcbiAgICAgIH1cbiAgICAgIGlmICghQ3N0cikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnN0cnVjdG9yIGZvciBcIiR7Y21wTWV0YS4kdGFnTmFtZSR9IyR7aG9zdFJlZi4kbW9kZU5hbWUkfVwiIHdhcyBub3QgZm91bmRgKTtcbiAgICAgIH1cbiAgICAgIGlmIChCVUlMRDIwLm1lbWJlciAmJiAhQ3N0ci5pc1Byb3hpZWQpIHtcbiAgICAgICAgaWYgKEJVSUxEMjAud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcHJveHlDb21wb25lbnQoQ3N0ciwgY21wTWV0YSwgMiAvKiBwcm94eVN0YXRlICovKTtcbiAgICAgICAgQ3N0ci5pc1Byb3hpZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZW5kTmV3SW5zdGFuY2UgPSBjcmVhdGVUaW1lKFwiY3JlYXRlSW5zdGFuY2VcIiwgY21wTWV0YS4kdGFnTmFtZSQpO1xuICAgICAgaWYgKEJVSUxEMjAubWVtYmVyKSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi87XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQ3N0cihob3N0UmVmKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgICAgfVxuICAgICAgaWYgKEJVSUxEMjAubWVtYmVyKSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+OCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovO1xuICAgICAgfVxuICAgICAgaWYgKEJVSUxEMjAud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLztcbiAgICAgIH1cbiAgICAgIGVuZE5ld0luc3RhbmNlKCk7XG4gICAgICBmaXJlQ29ubmVjdGVkQ2FsbGJhY2soaG9zdFJlZi4kbGF6eUluc3RhbmNlJCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENzdHIgPSBlbG0uY29uc3RydWN0b3I7XG4gICAgICBjb25zdCBjbXBUYWcgPSBlbG0ubG9jYWxOYW1lO1xuICAgICAgY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQoY21wVGFnKS50aGVuKCgpID0+IGhvc3RSZWYuJGZsYWdzJCB8PSAxMjggLyogaXNXYXRjaFJlYWR5ICovKTtcbiAgICB9XG4gICAgaWYgKEJVSUxEMjAuc3R5bGUgJiYgQ3N0ciAmJiBDc3RyLnN0eWxlKSB7XG4gICAgICBsZXQgc3R5bGU7XG4gICAgICBpZiAodHlwZW9mIENzdHIuc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3R5bGUgPSBDc3RyLnN0eWxlO1xuICAgICAgfSBlbHNlIGlmIChCVUlMRDIwLm1vZGUgJiYgdHlwZW9mIENzdHIuc3R5bGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaG9zdFJlZi4kbW9kZU5hbWUkID0gY29tcHV0ZU1vZGUoZWxtKTtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG1vZGVOYW1lJCkge1xuICAgICAgICAgIHN0eWxlID0gQ3N0ci5zdHlsZVtob3N0UmVmLiRtb2RlTmFtZSRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRDIwLmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIGhvc3RSZWYuJG1vZGVOYW1lJCkge1xuICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoXCJzLW1vZGVcIiwgaG9zdFJlZi4kbW9kZU5hbWUkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2NvcGVJZDIgPSBnZXRTY29wZUlkKGNtcE1ldGEsIGhvc3RSZWYuJG1vZGVOYW1lJCk7XG4gICAgICBpZiAoIXN0eWxlcy5oYXMoc2NvcGVJZDIpKSB7XG4gICAgICAgIGNvbnN0IGVuZFJlZ2lzdGVyU3R5bGVzID0gY3JlYXRlVGltZShcInJlZ2lzdGVyU3R5bGVzXCIsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgaWYgKCFCVUlMRDIwLmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIEJVSUxEMjAuc2hhZG93RG9tICYmIC8vIFRPRE8oU1RFTkNJTC04NTQpOiBSZW1vdmUgY29kZSByZWxhdGVkIHRvIGxlZ2FjeSBzaGFkb3dEb21TaGltIGZpZWxkXG4gICAgICAgIEJVSUxEMjAuc2hhZG93RG9tU2hpbSAmJiBjbXBNZXRhLiRmbGFncyQgJiA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLykge1xuICAgICAgICAgIHN0eWxlID0gYXdhaXQgaW1wb3J0KFwiLi9zaGFkb3ctY3NzLmpzXCIpLnRoZW4oKG0pID0+IG0uc2NvcGVDc3Moc3R5bGUsIHNjb3BlSWQyLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyU3R5bGUoc2NvcGVJZDIsIHN0eWxlLCAhIShjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pKTtcbiAgICAgICAgZW5kUmVnaXN0ZXJTdHlsZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgYW5jZXN0b3JDb21wb25lbnQgPSBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQ7XG4gIGNvbnN0IHNjaGVkdWxlID0gKCkgPT4gc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgdHJ1ZSk7XG4gIGlmIChCVUlMRDIwLmFzeW5jTG9hZGluZyAmJiBhbmNlc3RvckNvbXBvbmVudCAmJiBhbmNlc3RvckNvbXBvbmVudFtcInMtcmNcIl0pIHtcbiAgICBhbmNlc3RvckNvbXBvbmVudFtcInMtcmNcIl0ucHVzaChzY2hlZHVsZSk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGUoKTtcbiAgfVxufTtcbnZhciBmaXJlQ29ubmVjdGVkQ2FsbGJhY2sgPSAoaW5zdGFuY2UpID0+IHtcbiAgaWYgKEJVSUxEMjAubGF6eUxvYWQgJiYgQlVJTEQyMC5jb25uZWN0ZWRDYWxsYmFjaykge1xuICAgIHNhZmVDYWxsKGluc3RhbmNlLCBcImNvbm5lY3RlZENhbGxiYWNrXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvcnVudGltZS9jb25uZWN0ZWQtY2FsbGJhY2sudHNcbnZhciBjb25uZWN0ZWRDYWxsYmFjayA9IChlbG0pID0+IHtcbiAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgY29uc3QgZW5kQ29ubmVjdGVkID0gY3JlYXRlVGltZShcImNvbm5lY3RlZENhbGxiYWNrXCIsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICBpZiAoQlVJTEQyMS5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQpIHtcbiAgICAgIGFkZEhvc3RFdmVudExpc3RlbmVycyhlbG0sIGhvc3RSZWYsIGNtcE1ldGEuJGxpc3RlbmVycyQsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiAxIC8qIGhhc0Nvbm5lY3RlZCAqLykpIHtcbiAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxIC8qIGhhc0Nvbm5lY3RlZCAqLztcbiAgICAgIGxldCBob3N0SWQ7XG4gICAgICBpZiAoQlVJTEQyMS5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICBob3N0SWQgPSBlbG0uZ2V0QXR0cmlidXRlKEhZRFJBVEVfSUQpO1xuICAgICAgICBpZiAoaG9zdElkKSB7XG4gICAgICAgICAgaWYgKEJVSUxEMjEuc2hhZG93RG9tICYmIHN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVJZDIgPSBCVUlMRDIxLm1vZGUgPyBhZGRTdHlsZShlbG0uc2hhZG93Um9vdCwgY21wTWV0YSwgZWxtLmdldEF0dHJpYnV0ZShcInMtbW9kZVwiKSkgOiBhZGRTdHlsZShlbG0uc2hhZG93Um9vdCwgY21wTWV0YSk7XG4gICAgICAgICAgICBlbG0uY2xhc3NMaXN0LnJlbW92ZShzY29wZUlkMiArIFwiLWhcIiwgc2NvcGVJZDIgKyBcIi1zXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZShlbG0sIGNtcE1ldGEuJHRhZ05hbWUkLCBob3N0SWQsIGhvc3RSZWYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoQlVJTEQyMS5zbG90UmVsb2NhdGlvbiAmJiAhaG9zdElkKSB7XG4gICAgICAgIGlmIChCVUlMRDIxLmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8IChCVUlMRDIxLnNsb3QgfHwgQlVJTEQyMS5zaGFkb3dEb20pICYmIC8vIFRPRE8oU1RFTkNJTC04NTQpOiBSZW1vdmUgY29kZSByZWxhdGVkIHRvIGxlZ2FjeSBzaGFkb3dEb21TaGltIGZpZWxkXG4gICAgICAgIGNtcE1ldGEuJGZsYWdzJCAmICg0IC8qIGhhc1Nsb3RSZWxvY2F0aW9uICovIHwgOCAvKiBuZWVkc1NoYWRvd0RvbVNoaW0gKi8pKSB7XG4gICAgICAgICAgc2V0Q29udGVudFJlZmVyZW5jZShlbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoQlVJTEQyMS5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgbGV0IGFuY2VzdG9yQ29tcG9uZW50ID0gZWxtO1xuICAgICAgICB3aGlsZSAoYW5jZXN0b3JDb21wb25lbnQgPSBhbmNlc3RvckNvbXBvbmVudC5wYXJlbnROb2RlIHx8IGFuY2VzdG9yQ29tcG9uZW50Lmhvc3QpIHtcbiAgICAgICAgICBpZiAoQlVJTEQyMS5oeWRyYXRlQ2xpZW50U2lkZSAmJiBhbmNlc3RvckNvbXBvbmVudC5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLyAmJiBhbmNlc3RvckNvbXBvbmVudC5oYXNBdHRyaWJ1dGUoXCJzLWlkXCIpICYmIGFuY2VzdG9yQ29tcG9uZW50W1wicy1wXCJdIHx8IGFuY2VzdG9yQ29tcG9uZW50W1wicy1wXCJdKSB7XG4gICAgICAgICAgICBhdHRhY2hUb0FuY2VzdG9yKGhvc3RSZWYsIGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JCA9IGFuY2VzdG9yQ29tcG9uZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKEJVSUxEMjEucHJvcCAmJiAhQlVJTEQyMS5oeWRyYXRlU2VydmVyU2lkZSAmJiBjbXBNZXRhLiRtZW1iZXJzJCkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhjbXBNZXRhLiRtZW1iZXJzJCkubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgICAgICBpZiAobWVtYmVyRmxhZ3MgJiAzMSAvKiBQcm9wICovICYmIGVsbS5oYXNPd25Qcm9wZXJ0eShtZW1iZXJOYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbG1bbWVtYmVyTmFtZV07XG4gICAgICAgICAgICBkZWxldGUgZWxtW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgZWxtW21lbWJlck5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChCVUlMRDIxLmluaXRpYWxpemVOZXh0VGljaykge1xuICAgICAgICBuZXh0VGljaygoKSA9PiBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbGl6ZUNvbXBvbmVudChlbG0sIGhvc3RSZWYsIGNtcE1ldGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkLCBmYWxzZSk7XG4gICAgICBpZiAoaG9zdFJlZiA9PSBudWxsID8gdm9pZCAwIDogaG9zdFJlZi4kbGF6eUluc3RhbmNlJCkge1xuICAgICAgICBmaXJlQ29ubmVjdGVkQ2FsbGJhY2soaG9zdFJlZi4kbGF6eUluc3RhbmNlJCk7XG4gICAgICB9IGVsc2UgaWYgKGhvc3RSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCkge1xuICAgICAgICBob3N0UmVmLiRvblJlYWR5UHJvbWlzZSQudGhlbigoKSA9PiBmaXJlQ29ubmVjdGVkQ2FsbGJhY2soaG9zdFJlZi4kbGF6eUluc3RhbmNlJCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbmRDb25uZWN0ZWQoKTtcbiAgfVxufTtcbnZhciBzZXRDb250ZW50UmVmZXJlbmNlID0gKGVsbSkgPT4ge1xuICBjb25zdCBjb250ZW50UmVmRWxtID0gZWxtW1wicy1jclwiXSA9IGRvYy5jcmVhdGVDb21tZW50KFxuICAgIEJVSUxEMjEuaXNEZWJ1ZyA/IGBjb250ZW50LXJlZiAoaG9zdD0ke2VsbS5sb2NhbE5hbWV9KWAgOiBcIlwiXG4gICk7XG4gIGNvbnRlbnRSZWZFbG1bXCJzLWNuXCJdID0gdHJ1ZTtcbiAgaW5zZXJ0QmVmb3JlKGVsbSwgY29udGVudFJlZkVsbSwgZWxtLmZpcnN0Q2hpbGQpO1xufTtcblxuLy8gc3JjL3J1bnRpbWUvZGlzY29ubmVjdGVkLWNhbGxiYWNrLnRzXG5pbXBvcnQgeyBCVUlMRCBhcyBCVUlMRDIyIH0gZnJvbSBcIkBzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGFcIjtcbnZhciBkaXNjb25uZWN0SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgaWYgKEJVSUxEMjIubGF6eUxvYWQgJiYgQlVJTEQyMi5kaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgIHNhZmVDYWxsKGluc3RhbmNlLCBcImRpc2Nvbm5lY3RlZENhbGxiYWNrXCIpO1xuICB9XG4gIGlmIChCVUlMRDIyLmNtcERpZFVubG9hZCkge1xuICAgIHNhZmVDYWxsKGluc3RhbmNlLCBcImNvbXBvbmVudERpZFVubG9hZFwiKTtcbiAgfVxufTtcbnZhciBkaXNjb25uZWN0ZWRDYWxsYmFjayA9IGFzeW5jIChlbG0pID0+IHtcbiAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICBpZiAoQlVJTEQyMi5ob3N0TGlzdGVuZXIpIHtcbiAgICAgIGlmIChob3N0UmVmLiRybUxpc3RlbmVycyQpIHtcbiAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkLm1hcCgocm1MaXN0ZW5lcikgPT4gcm1MaXN0ZW5lcigpKTtcbiAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIUJVSUxEMjIubGF6eUxvYWQpIHtcbiAgICAgIGRpc2Nvbm5lY3RJbnN0YW5jZShlbG0pO1xuICAgIH0gZWxzZSBpZiAoaG9zdFJlZiA9PSBudWxsID8gdm9pZCAwIDogaG9zdFJlZi4kbGF6eUluc3RhbmNlJCkge1xuICAgICAgZGlzY29ubmVjdEluc3RhbmNlKGhvc3RSZWYuJGxhenlJbnN0YW5jZSQpO1xuICAgIH0gZWxzZSBpZiAoaG9zdFJlZiA9PSBudWxsID8gdm9pZCAwIDogaG9zdFJlZi4kb25SZWFkeVByb21pc2UkKSB7XG4gICAgICBob3N0UmVmLiRvblJlYWR5UHJvbWlzZSQudGhlbigoKSA9PiBkaXNjb25uZWN0SW5zdGFuY2UoaG9zdFJlZi4kbGF6eUluc3RhbmNlJCkpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3J1bnRpbWUvZG9tLWV4dHJhcy50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQyMyB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG52YXIgcGF0Y2hQc2V1ZG9TaGFkb3dEb20gPSAoaG9zdEVsZW1lbnRQcm90b3R5cGUsIGRlc2NyaXB0b3JQcm90b3R5cGUpID0+IHtcbiAgcGF0Y2hDbG9uZU5vZGUoaG9zdEVsZW1lbnRQcm90b3R5cGUpO1xuICBwYXRjaFNsb3RBcHBlbmRDaGlsZChob3N0RWxlbWVudFByb3RvdHlwZSk7XG4gIHBhdGNoU2xvdEFwcGVuZChob3N0RWxlbWVudFByb3RvdHlwZSk7XG4gIHBhdGNoU2xvdFByZXBlbmQoaG9zdEVsZW1lbnRQcm90b3R5cGUpO1xuICBwYXRjaFNsb3RJbnNlcnRBZGphY2VudEVsZW1lbnQoaG9zdEVsZW1lbnRQcm90b3R5cGUpO1xuICBwYXRjaFNsb3RJbnNlcnRBZGphY2VudEhUTUwoaG9zdEVsZW1lbnRQcm90b3R5cGUpO1xuICBwYXRjaFNsb3RJbnNlcnRBZGphY2VudFRleHQoaG9zdEVsZW1lbnRQcm90b3R5cGUpO1xuICBwYXRjaFRleHRDb250ZW50KGhvc3RFbGVtZW50UHJvdG90eXBlKTtcbiAgcGF0Y2hDaGlsZFNsb3ROb2Rlcyhob3N0RWxlbWVudFByb3RvdHlwZSwgZGVzY3JpcHRvclByb3RvdHlwZSk7XG4gIHBhdGNoU2xvdFJlbW92ZUNoaWxkKGhvc3RFbGVtZW50UHJvdG90eXBlKTtcbn07XG52YXIgcGF0Y2hDbG9uZU5vZGUgPSAoSG9zdEVsZW1lbnRQcm90b3R5cGUpID0+IHtcbiAgY29uc3Qgb3JnQ2xvbmVOb2RlID0gSG9zdEVsZW1lbnRQcm90b3R5cGUuY2xvbmVOb2RlO1xuICBIb3N0RWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGUgPSBmdW5jdGlvbihkZWVwKSB7XG4gICAgY29uc3Qgc3JjTm9kZSA9IHRoaXM7XG4gICAgY29uc3QgaXNTaGFkb3dEb20gPSBCVUlMRDIzLnNoYWRvd0RvbSA/IHNyY05vZGUuc2hhZG93Um9vdCAmJiBzdXBwb3J0c1NoYWRvdyA6IGZhbHNlO1xuICAgIGNvbnN0IGNsb25lZE5vZGUgPSBvcmdDbG9uZU5vZGUuY2FsbChzcmNOb2RlLCBpc1NoYWRvd0RvbSA/IGRlZXAgOiBmYWxzZSk7XG4gICAgaWYgKEJVSUxEMjMuc2xvdCAmJiAhaXNTaGFkb3dEb20gJiYgZGVlcCkge1xuICAgICAgbGV0IGkyID0gMDtcbiAgICAgIGxldCBzbG90dGVkLCBub25TdGVuY2lsTm9kZTtcbiAgICAgIGNvbnN0IHN0ZW5jaWxQcml2YXRlcyA9IFtcbiAgICAgICAgXCJzLWlkXCIsXG4gICAgICAgIFwicy1jclwiLFxuICAgICAgICBcInMtbHJcIixcbiAgICAgICAgXCJzLXJjXCIsXG4gICAgICAgIFwicy1zY1wiLFxuICAgICAgICBcInMtcFwiLFxuICAgICAgICBcInMtY25cIixcbiAgICAgICAgXCJzLXNyXCIsXG4gICAgICAgIFwicy1zblwiLFxuICAgICAgICBcInMtaG5cIixcbiAgICAgICAgXCJzLW9sXCIsXG4gICAgICAgIFwicy1uclwiLFxuICAgICAgICBcInMtc2lcIixcbiAgICAgICAgXCJzLXJmXCIsXG4gICAgICAgIFwicy1zY3NcIlxuICAgICAgXTtcbiAgICAgIGZvciAoOyBpMiA8IHNyY05vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgc2xvdHRlZCA9IHNyY05vZGUuY2hpbGROb2Rlc1tpMl1bXCJzLW5yXCJdO1xuICAgICAgICBub25TdGVuY2lsTm9kZSA9IHN0ZW5jaWxQcml2YXRlcy5ldmVyeSgocHJpdmF0ZUZpZWxkKSA9PiAhc3JjTm9kZS5jaGlsZE5vZGVzW2kyXVtwcml2YXRlRmllbGRdKTtcbiAgICAgICAgaWYgKHNsb3R0ZWQpIHtcbiAgICAgICAgICBpZiAoQlVJTEQyMy5hcHBlbmRDaGlsZFNsb3RGaXggJiYgY2xvbmVkTm9kZS5fX2FwcGVuZENoaWxkKSB7XG4gICAgICAgICAgICBjbG9uZWROb2RlLl9fYXBwZW5kQ2hpbGQoc2xvdHRlZC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbG9uZWROb2RlLmFwcGVuZENoaWxkKHNsb3R0ZWQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vblN0ZW5jaWxOb2RlKSB7XG4gICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChzcmNOb2RlLmNoaWxkTm9kZXNbaTJdLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZE5vZGU7XG4gIH07XG59O1xudmFyIHBhdGNoU2xvdEFwcGVuZENoaWxkID0gKEhvc3RFbGVtZW50UHJvdG90eXBlKSA9PiB7XG4gIEhvc3RFbGVtZW50UHJvdG90eXBlLl9fYXBwZW5kQ2hpbGQgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5hcHBlbmRDaGlsZDtcbiAgSG9zdEVsZW1lbnRQcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbihuZXdDaGlsZCkge1xuICAgIGNvbnN0IHNsb3ROYW1lID0gbmV3Q2hpbGRbXCJzLXNuXCJdID0gZ2V0U2xvdE5hbWUobmV3Q2hpbGQpO1xuICAgIGNvbnN0IHNsb3ROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKHRoaXMuY2hpbGROb2Rlcywgc2xvdE5hbWUsIHRoaXMudGFnTmFtZSk7XG4gICAgaWYgKHNsb3ROb2RlKSB7XG4gICAgICBjb25zdCBzbG90Q2hpbGROb2RlcyA9IGdldEhvc3RTbG90Q2hpbGROb2RlcyhzbG90Tm9kZSwgc2xvdE5hbWUpO1xuICAgICAgY29uc3QgYXBwZW5kQWZ0ZXIgPSBzbG90Q2hpbGROb2Rlc1tzbG90Q2hpbGROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGluc2VydGVkTm9kZSA9IGluc2VydEJlZm9yZShhcHBlbmRBZnRlci5wYXJlbnROb2RlLCBuZXdDaGlsZCwgYXBwZW5kQWZ0ZXIubmV4dFNpYmxpbmcpO1xuICAgICAgdXBkYXRlRmFsbGJhY2tTbG90VmlzaWJpbGl0eSh0aGlzKTtcbiAgICAgIHJldHVybiBpbnNlcnRlZE5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICB9O1xufTtcbnZhciBwYXRjaFNsb3RSZW1vdmVDaGlsZCA9IChFbGVtZW50UHJvdG90eXBlKSA9PiB7XG4gIEVsZW1lbnRQcm90b3R5cGUuX19yZW1vdmVDaGlsZCA9IEVsZW1lbnRQcm90b3R5cGUucmVtb3ZlQ2hpbGQ7XG4gIEVsZW1lbnRQcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbih0b1JlbW92ZSkge1xuICAgIGlmICh0b1JlbW92ZSAmJiB0eXBlb2YgdG9SZW1vdmVbXCJzLXNuXCJdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zdCBzbG90Tm9kZSA9IGdldEhvc3RTbG90Tm9kZSh0aGlzLmNoaWxkTm9kZXMsIHRvUmVtb3ZlW1wicy1zblwiXSwgdGhpcy50YWdOYW1lKTtcbiAgICAgIGlmIChzbG90Tm9kZSkge1xuICAgICAgICBjb25zdCBzbG90Q2hpbGROb2RlcyA9IGdldEhvc3RTbG90Q2hpbGROb2RlcyhzbG90Tm9kZSwgdG9SZW1vdmVbXCJzLXNuXCJdKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdOb2RlID0gc2xvdENoaWxkTm9kZXMuZmluZCgobikgPT4gbiA9PT0gdG9SZW1vdmUpO1xuICAgICAgICBpZiAoZXhpc3RpbmdOb2RlKSB7XG4gICAgICAgICAgZXhpc3RpbmdOb2RlLnJlbW92ZSgpO1xuICAgICAgICAgIHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkodGhpcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fcmVtb3ZlQ2hpbGQodG9SZW1vdmUpO1xuICB9O1xufTtcbnZhciBwYXRjaFNsb3RQcmVwZW5kID0gKEhvc3RFbGVtZW50UHJvdG90eXBlKSA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsUHJlcGVuZCA9IEhvc3RFbGVtZW50UHJvdG90eXBlLnByZXBlbmQ7XG4gIEhvc3RFbGVtZW50UHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiguLi5uZXdDaGlsZHJlbikge1xuICAgIG5ld0NoaWxkcmVuLmZvckVhY2goKG5ld0NoaWxkKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5ld0NoaWxkID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld0NoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNsb3ROYW1lID0gbmV3Q2hpbGRbXCJzLXNuXCJdID0gZ2V0U2xvdE5hbWUobmV3Q2hpbGQpO1xuICAgICAgY29uc3Qgc2xvdE5vZGUgPSBnZXRIb3N0U2xvdE5vZGUodGhpcy5jaGlsZE5vZGVzLCBzbG90TmFtZSwgdGhpcy50YWdOYW1lKTtcbiAgICAgIGlmIChzbG90Tm9kZSkge1xuICAgICAgICBjb25zdCBzbG90UGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICAgICAgc2xvdFBsYWNlaG9sZGVyW1wicy1uclwiXSA9IG5ld0NoaWxkO1xuICAgICAgICBzbG90Tm9kZVtcInMtY3JcIl0ucGFyZW50Tm9kZS5fX2FwcGVuZENoaWxkKHNsb3RQbGFjZWhvbGRlcik7XG4gICAgICAgIG5ld0NoaWxkW1wicy1vbFwiXSA9IHNsb3RQbGFjZWhvbGRlcjtcbiAgICAgICAgY29uc3Qgc2xvdENoaWxkTm9kZXMgPSBnZXRIb3N0U2xvdENoaWxkTm9kZXMoc2xvdE5vZGUsIHNsb3ROYW1lKTtcbiAgICAgICAgY29uc3QgYXBwZW5kQWZ0ZXIgPSBzbG90Q2hpbGROb2Rlc1swXTtcbiAgICAgICAgcmV0dXJuIGluc2VydEJlZm9yZShhcHBlbmRBZnRlci5wYXJlbnROb2RlLCBuZXdDaGlsZCwgYXBwZW5kQWZ0ZXIubmV4dFNpYmxpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0NoaWxkLm5vZGVUeXBlID09PSAxICYmICEhbmV3Q2hpbGQuZ2V0QXR0cmlidXRlKFwic2xvdFwiKSkge1xuICAgICAgICBuZXdDaGlsZC5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsUHJlcGVuZC5jYWxsKHRoaXMsIG5ld0NoaWxkKTtcbiAgICB9KTtcbiAgfTtcbn07XG52YXIgcGF0Y2hTbG90QXBwZW5kID0gKEhvc3RFbGVtZW50UHJvdG90eXBlKSA9PiB7XG4gIEhvc3RFbGVtZW50UHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKC4uLm5ld0NoaWxkcmVuKSB7XG4gICAgbmV3Q2hpbGRyZW4uZm9yRWFjaCgobmV3Q2hpbGQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmV3Q2hpbGQgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmV3Q2hpbGQpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdDaGlsZCk7XG4gICAgfSk7XG4gIH07XG59O1xudmFyIHBhdGNoU2xvdEluc2VydEFkamFjZW50SFRNTCA9IChIb3N0RWxlbWVudFByb3RvdHlwZSkgPT4ge1xuICBjb25zdCBvcmlnaW5hbEluc2VydEFkamFjZW50SHRtbCA9IEhvc3RFbGVtZW50UHJvdG90eXBlLmluc2VydEFkamFjZW50SFRNTDtcbiAgSG9zdEVsZW1lbnRQcm90b3R5cGUuaW5zZXJ0QWRqYWNlbnRIVE1MID0gZnVuY3Rpb24ocG9zaXRpb24sIHRleHQpIHtcbiAgICBpZiAocG9zaXRpb24gIT09IFwiYWZ0ZXJiZWdpblwiICYmIHBvc2l0aW9uICE9PSBcImJlZm9yZWVuZFwiKSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWxJbnNlcnRBZGphY2VudEh0bWwuY2FsbCh0aGlzLCBwb3NpdGlvbiwgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKTtcbiAgICBsZXQgbm9kZTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdGV4dDtcbiAgICBpZiAocG9zaXRpb24gPT09IFwiYWZ0ZXJiZWdpblwiKSB7XG4gICAgICB3aGlsZSAobm9kZSA9IGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgIHRoaXMucHJlcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcImJlZm9yZWVuZFwiKSB7XG4gICAgICB3aGlsZSAobm9kZSA9IGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG52YXIgcGF0Y2hTbG90SW5zZXJ0QWRqYWNlbnRUZXh0ID0gKEhvc3RFbGVtZW50UHJvdG90eXBlKSA9PiB7XG4gIEhvc3RFbGVtZW50UHJvdG90eXBlLmluc2VydEFkamFjZW50VGV4dCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCB0ZXh0KSB7XG4gICAgdGhpcy5pbnNlcnRBZGphY2VudEhUTUwocG9zaXRpb24sIHRleHQpO1xuICB9O1xufTtcbnZhciBwYXRjaFNsb3RJbnNlcnRBZGphY2VudEVsZW1lbnQgPSAoSG9zdEVsZW1lbnRQcm90b3R5cGUpID0+IHtcbiAgY29uc3Qgb3JpZ2luYWxJbnNlcnRBZGphY2VudEVsZW1lbnQgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5pbnNlcnRBZGphY2VudEVsZW1lbnQ7XG4gIEhvc3RFbGVtZW50UHJvdG90eXBlLmluc2VydEFkamFjZW50RWxlbWVudCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBlbGVtZW50KSB7XG4gICAgaWYgKHBvc2l0aW9uICE9PSBcImFmdGVyYmVnaW5cIiAmJiBwb3NpdGlvbiAhPT0gXCJiZWZvcmVlbmRcIikge1xuICAgICAgcmV0dXJuIG9yaWdpbmFsSW5zZXJ0QWRqYWNlbnRFbGVtZW50LmNhbGwodGhpcywgcG9zaXRpb24sIGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAocG9zaXRpb24gPT09IFwiYWZ0ZXJiZWdpblwiKSB7XG4gICAgICB0aGlzLnByZXBlbmQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcImJlZm9yZWVuZFwiKSB7XG4gICAgICB0aGlzLmFwcGVuZChlbGVtZW50KTtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcbn07XG52YXIgcGF0Y2hUZXh0Q29udGVudCA9IChob3N0RWxlbWVudFByb3RvdHlwZSkgPT4ge1xuICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgXCJ0ZXh0Q29udGVudFwiKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3RFbGVtZW50UHJvdG90eXBlLCBcIl9fdGV4dENvbnRlbnRcIiwgZGVzY3JpcHRvcik7XG4gIGlmIChCVUlMRDIzLmV4cGVyaW1lbnRhbFNjb3BlZFNsb3RDaGFuZ2VzKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3RFbGVtZW50UHJvdG90eXBlLCBcInRleHRDb250ZW50XCIsIHtcbiAgICAgIC8vIFRvIG1pbWljIHNoYWRvdyByb290IGJlaGF2aW9yLCB3ZSBuZWVkIHRvIHJldHVybiB0aGUgdGV4dCBjb250ZW50IG9mIGFsbFxuICAgICAgLy8gbm9kZXMgaW4gYSBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHNsb3RSZWZOb2RlcyA9IGdldEFsbENoaWxkU2xvdE5vZGVzKHRoaXMuY2hpbGROb2Rlcyk7XG4gICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gc2xvdFJlZk5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgY29uc3QgdGV4dCA9IFtdO1xuICAgICAgICAgIGxldCBzbG90Q29udGVudCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgd2hpbGUgKHNsb3RDb250ZW50ICYmIHNsb3RDb250ZW50W1wicy1zblwiXSA9PT0gbm9kZVtcInMtc25cIl0pIHtcbiAgICAgICAgICAgIGlmIChzbG90Q29udGVudC5ub2RlVHlwZSA9PT0gMyAvKiBURVhUX05PREUgKi8gfHwgc2xvdENvbnRlbnQubm9kZVR5cGUgPT09IDEgLyogRUxFTUVOVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgIHRleHQucHVzaCgoX2IgPSAoX2EgPSBzbG90Q29udGVudC50ZXh0Q29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRyaW0oKSkgIT0gbnVsbCA/IF9iIDogXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzbG90Q29udGVudCA9IHNsb3RDb250ZW50Lm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGV4dC5maWx0ZXIoKHJlZikgPT4gcmVmICE9PSBcIlwiKS5qb2luKFwiIFwiKTtcbiAgICAgICAgfSkuZmlsdGVyKCh0ZXh0KSA9PiB0ZXh0ICE9PSBcIlwiKS5qb2luKFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIFwiIFwiICsgdGV4dENvbnRlbnQgKyBcIiBcIjtcbiAgICAgIH0sXG4gICAgICAvLyBUbyBtaW1pYyBzaGFkb3cgcm9vdCBiZWhhdmlvciwgd2UgbmVlZCB0byBvdmVyd3JpdGUgYWxsIG5vZGVzIGluIGEgc2xvdFxuICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIElmIGEgZGVmYXVsdCBzbG90IHJlZmVyZW5jZSBub2RlIGV4aXN0cywgdGhlIHRleHQgY29udGVudCB3aWxsIGJlXG4gICAgICAvLyBwbGFjZWQgdGhlcmUuIE90aGVyd2lzZSwgdGhlIG5ldyB0ZXh0IG5vZGUgd2lsbCBiZSBoaWRkZW5cbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzbG90UmVmTm9kZXMgPSBnZXRBbGxDaGlsZFNsb3ROb2Rlcyh0aGlzLmNoaWxkTm9kZXMpO1xuICAgICAgICBzbG90UmVmTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgIGxldCBzbG90Q29udGVudCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgd2hpbGUgKHNsb3RDb250ZW50ICYmIHNsb3RDb250ZW50W1wicy1zblwiXSA9PT0gbm9kZVtcInMtc25cIl0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHNsb3RDb250ZW50O1xuICAgICAgICAgICAgc2xvdENvbnRlbnQgPSBzbG90Q29udGVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgIHRtcC5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGVbXCJzLXNuXCJdID09PSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgICAgICAgICB0ZXh0Tm9kZVtcInMtc25cIl0gPSBcIlwiO1xuICAgICAgICAgICAgaW5zZXJ0QmVmb3JlKG5vZGUucGFyZW50RWxlbWVudCwgdGV4dE5vZGUsIG5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3RFbGVtZW50UHJvdG90eXBlLCBcInRleHRDb250ZW50XCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzbG90Tm9kZSA9IGdldEhvc3RTbG90Tm9kZSh0aGlzLmNoaWxkTm9kZXMsIFwiXCIsIHRoaXMudGFnTmFtZSk7XG4gICAgICAgIGlmICgoKF9hID0gc2xvdE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IHNsb3ROb2RlLm5leHRTaWJsaW5nKSA9PSBudWxsID8gdm9pZCAwIDogX2Eubm9kZVR5cGUpID09PSAzIC8qIFRFWFRfTk9ERSAqLykge1xuICAgICAgICAgIHJldHVybiBzbG90Tm9kZS5uZXh0U2libGluZy50ZXh0Q29udGVudDtcbiAgICAgICAgfSBlbHNlIGlmIChzbG90Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBzbG90Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3RleHRDb250ZW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc2xvdE5vZGUgPSBnZXRIb3N0U2xvdE5vZGUodGhpcy5jaGlsZE5vZGVzLCBcIlwiLCB0aGlzLnRhZ05hbWUpO1xuICAgICAgICBpZiAoKChfYSA9IHNsb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiBzbG90Tm9kZS5uZXh0U2libGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5vZGVUeXBlKSA9PT0gMyAvKiBURVhUX05PREUgKi8pIHtcbiAgICAgICAgICBzbG90Tm9kZS5uZXh0U2libGluZy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgc2xvdE5vZGUudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fdGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICBjb25zdCBjb250ZW50UmVmRWxtID0gdGhpc1tcInMtY3JcIl07XG4gICAgICAgICAgaWYgKGNvbnRlbnRSZWZFbG0pIHtcbiAgICAgICAgICAgIGluc2VydEJlZm9yZSh0aGlzLCBjb250ZW50UmVmRWxtLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xudmFyIHBhdGNoQ2hpbGRTbG90Tm9kZXMgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gIGNsYXNzIEZha2VOb2RlTGlzdCBleHRlbmRzIEFycmF5IHtcbiAgICBpdGVtKG4pIHtcbiAgICAgIHJldHVybiB0aGlzW25dO1xuICAgIH1cbiAgfVxuICBpZiAoY21wTWV0YS4kZmxhZ3MkICYgOCAvKiBuZWVkc1NoYWRvd0RvbVNoaW0gKi8pIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzRm4gPSBlbG0uX19sb29rdXBHZXR0ZXJfXyhcImNoaWxkTm9kZXNcIik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsbSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubWFwKChuKSA9PiBuLm5vZGVUeXBlID09PSAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCBcImNoaWxkRWxlbWVudENvdW50XCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGVsbS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsbSwgXCJjaGlsZE5vZGVzXCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IGNoaWxkTm9kZXNGbi5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoKHBsdC4kZmxhZ3MkICYgMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLykgPT09IDAgJiYgZ2V0SG9zdFJlZih0aGlzKS4kZmxhZ3MkICYgMiAvKiBoYXNSZW5kZXJlZCAqLykge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGYWtlTm9kZUxpc3QoKTtcbiAgICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZE5vZGVzW2kyXVtcInMtbnJcIl07XG4gICAgICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChzbG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRmFrZU5vZGVMaXN0LmZyb20oY2hpbGROb2Rlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG52YXIgZ2V0QWxsQ2hpbGRTbG90Tm9kZXMgPSAoY2hpbGROb2RlcykgPT4ge1xuICBjb25zdCBzbG90UmVmTm9kZXMgPSBbXTtcbiAgZm9yIChjb25zdCBjaGlsZE5vZGUgb2YgQXJyYXkuZnJvbShjaGlsZE5vZGVzKSkge1xuICAgIGlmIChjaGlsZE5vZGVbXCJzLXNyXCJdKSB7XG4gICAgICBzbG90UmVmTm9kZXMucHVzaChjaGlsZE5vZGUpO1xuICAgIH1cbiAgICBzbG90UmVmTm9kZXMucHVzaCguLi5nZXRBbGxDaGlsZFNsb3ROb2RlcyhjaGlsZE5vZGUuY2hpbGROb2RlcykpO1xuICB9XG4gIHJldHVybiBzbG90UmVmTm9kZXM7XG59O1xudmFyIGdldFNsb3ROYW1lID0gKG5vZGUpID0+IG5vZGVbXCJzLXNuXCJdIHx8IG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoXCJzbG90XCIpIHx8IFwiXCI7XG52YXIgZ2V0SG9zdFNsb3ROb2RlID0gKGNoaWxkTm9kZXMsIHNsb3ROYW1lLCBob3N0TmFtZSkgPT4ge1xuICBsZXQgaTIgPSAwO1xuICBsZXQgY2hpbGROb2RlO1xuICBmb3IgKDsgaTIgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaTIrKykge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaTJdO1xuICAgIGlmIChjaGlsZE5vZGVbXCJzLXNyXCJdICYmIGNoaWxkTm9kZVtcInMtc25cIl0gPT09IHNsb3ROYW1lICYmIGNoaWxkTm9kZVtcInMtaG5cIl0gPT09IGhvc3ROYW1lKSB7XG4gICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgIH1cbiAgICBjaGlsZE5vZGUgPSBnZXRIb3N0U2xvdE5vZGUoY2hpbGROb2RlLmNoaWxkTm9kZXMsIHNsb3ROYW1lLCBob3N0TmFtZSk7XG4gICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgcmV0dXJuIGNoaWxkTm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIGdldEhvc3RTbG90Q2hpbGROb2RlcyA9IChuLCBzbG90TmFtZSkgPT4ge1xuICBjb25zdCBjaGlsZE5vZGVzID0gW25dO1xuICB3aGlsZSAoKG4gPSBuLm5leHRTaWJsaW5nKSAmJiBuW1wicy1zblwiXSA9PT0gc2xvdE5hbWUpIHtcbiAgICBjaGlsZE5vZGVzLnB1c2gobik7XG4gIH1cbiAgcmV0dXJuIGNoaWxkTm9kZXM7XG59O1xuXG4vLyBzcmMvcnVudGltZS9ib290c3RyYXAtY3VzdG9tLWVsZW1lbnQudHNcbnZhciBkZWZpbmVDdXN0b21FbGVtZW50ID0gKENzdHIsIGNvbXBhY3RNZXRhKSA9PiB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShjb21wYWN0TWV0YVsxXSwgcHJveHlDdXN0b21FbGVtZW50KENzdHIsIGNvbXBhY3RNZXRhKSk7XG59O1xudmFyIHByb3h5Q3VzdG9tRWxlbWVudCA9IChDc3RyLCBjb21wYWN0TWV0YSkgPT4ge1xuICBjb25zdCBjbXBNZXRhID0ge1xuICAgICRmbGFncyQ6IGNvbXBhY3RNZXRhWzBdLFxuICAgICR0YWdOYW1lJDogY29tcGFjdE1ldGFbMV1cbiAgfTtcbiAgaWYgKEJVSUxEMjQubWVtYmVyKSB7XG4gICAgY21wTWV0YS4kbWVtYmVycyQgPSBjb21wYWN0TWV0YVsyXTtcbiAgfVxuICBpZiAoQlVJTEQyNC5ob3N0TGlzdGVuZXIpIHtcbiAgICBjbXBNZXRhLiRsaXN0ZW5lcnMkID0gY29tcGFjdE1ldGFbM107XG4gIH1cbiAgaWYgKEJVSUxEMjQud2F0Y2hDYWxsYmFjaykge1xuICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIuJHdhdGNoZXJzJDtcbiAgfVxuICBpZiAoQlVJTEQyNC5yZWZsZWN0KSB7XG4gICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkID0gW107XG4gIH1cbiAgaWYgKEJVSUxEMjQuc2hhZG93RG9tICYmICFzdXBwb3J0c1NoYWRvdyAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICBjbXBNZXRhLiRmbGFncyQgfD0gOCAvKiBuZWVkc1NoYWRvd0RvbVNoaW0gKi87XG4gIH1cbiAgaWYgKEJVSUxEMjQuZXhwZXJpbWVudGFsU2xvdEZpeGVzKSB7XG4gICAgaWYgKEJVSUxEMjQuc2NvcGVkICYmIGNtcE1ldGEuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgcGF0Y2hQc2V1ZG9TaGFkb3dEb20oQ3N0ci5wcm90b3R5cGUsIGNtcE1ldGEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoQlVJTEQyNC5zbG90Q2hpbGROb2Rlc0ZpeCkge1xuICAgICAgcGF0Y2hDaGlsZFNsb3ROb2RlcyhDc3RyLnByb3RvdHlwZSwgY21wTWV0YSk7XG4gICAgfVxuICAgIGlmIChCVUlMRDI0LmNsb25lTm9kZUZpeCkge1xuICAgICAgcGF0Y2hDbG9uZU5vZGUoQ3N0ci5wcm90b3R5cGUpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQyNC5hcHBlbmRDaGlsZFNsb3RGaXgpIHtcbiAgICAgIHBhdGNoU2xvdEFwcGVuZENoaWxkKENzdHIucHJvdG90eXBlKTtcbiAgICB9XG4gICAgaWYgKEJVSUxEMjQuc2NvcGVkU2xvdFRleHRDb250ZW50Rml4ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgcGF0Y2hUZXh0Q29udGVudChDc3RyLnByb3RvdHlwZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2sgPSBDc3RyLnByb3RvdHlwZS5jb25uZWN0ZWRDYWxsYmFjaztcbiAgY29uc3Qgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjayA9IENzdHIucHJvdG90eXBlLmRpc2Nvbm5lY3RlZENhbGxiYWNrO1xuICBPYmplY3QuYXNzaWduKENzdHIucHJvdG90eXBlLCB7XG4gICAgX19yZWdpc3Rlckhvc3QoKSB7XG4gICAgICByZWdpc3Rlckhvc3QodGhpcywgY21wTWV0YSk7XG4gICAgfSxcbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKHRoaXMpO1xuICAgICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKHRoaXMsIGhvc3RSZWYsIGNtcE1ldGEuJGxpc3RlbmVycyQsIGZhbHNlKTtcbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrKHRoaXMpO1xuICAgICAgaWYgKEJVSUxEMjQuY29ubmVjdGVkQ2FsbGJhY2sgJiYgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICBvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKHRoaXMpO1xuICAgICAgaWYgKEJVSUxEMjQuZGlzY29ubmVjdGVkQ2FsbGJhY2sgJiYgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICBvcmlnaW5hbERpc2Nvbm5lY3RlZENhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfX2F0dGFjaFNoYWRvdygpIHtcbiAgICAgIGlmIChzdXBwb3J0c1NoYWRvdykge1xuICAgICAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAgIGlmIChCVUlMRDI0LnNoYWRvd0RlbGVnYXRlc0ZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7XG4gICAgICAgICAgICAgIG1vZGU6IFwib3BlblwiLFxuICAgICAgICAgICAgICBkZWxlZ2F0ZXNGb2N1czogISEoY21wTWV0YS4kZmxhZ3MkICYgMTYgLyogc2hhZG93RGVsZWdhdGVzRm9jdXMgKi8pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdC5tb2RlICE9PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgVW5hYmxlIHRvIHJlLXVzZSBleGlzdGluZyBzaGFkb3cgcm9vdCBmb3IgJHtjbXBNZXRhLiR0YWdOYW1lJH0hIE1vZGUgaXMgc2V0IHRvICR7dGhpcy5zaGFkb3dSb290Lm1vZGV9IGJ1dCBTdGVuY2lsIG9ubHkgc3VwcG9ydHMgb3BlbiBzaGFkb3cgcm9vdHMuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hhZG93Um9vdCA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgQ3N0ci5pcyA9IGNtcE1ldGEuJHRhZ05hbWUkO1xuICByZXR1cm4gcHJveHlDb21wb25lbnQoQ3N0ciwgY21wTWV0YSwgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLyB8IDIgLyogcHJveHlTdGF0ZSAqLyk7XG59O1xudmFyIGZvcmNlTW9kZVVwZGF0ZSA9IChlbG0pID0+IHtcbiAgaWYgKEJVSUxEMjQuc3R5bGUgJiYgQlVJTEQyNC5tb2RlICYmICFCVUlMRDI0LmxhenlMb2FkKSB7XG4gICAgY29uc3QgbW9kZSA9IGNvbXB1dGVNb2RlKGVsbSk7XG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICBpZiAoaG9zdFJlZi4kbW9kZU5hbWUkICE9PSBtb2RlKSB7XG4gICAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgICBjb25zdCBvbGRTY29wZUlkID0gZWxtW1wicy1zY1wiXTtcbiAgICAgIGNvbnN0IHNjb3BlSWQyID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBtb2RlKTtcbiAgICAgIGNvbnN0IHN0eWxlID0gZWxtLmNvbnN0cnVjdG9yLnN0eWxlW21vZGVdO1xuICAgICAgY29uc3QgZmxhZ3MgPSBjbXBNZXRhLiRmbGFncyQ7XG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQyKSkge1xuICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc2NvcGVJZDIsIHN0eWxlLCAhIShmbGFncyAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGhvc3RSZWYuJG1vZGVOYW1lJCA9IG1vZGU7XG4gICAgICAgIGVsbS5jbGFzc0xpc3QucmVtb3ZlKG9sZFNjb3BlSWQgKyBcIi1oXCIsIG9sZFNjb3BlSWQgKyBcIi1zXCIpO1xuICAgICAgICBhdHRhY2hTdHlsZXMoaG9zdFJlZik7XG4gICAgICAgIGZvcmNlVXBkYXRlKGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcnVudGltZS9ib290c3RyYXAtbGF6eS50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQyNSB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG5cbi8vIHNyYy9ydW50aW1lL2htci1jb21wb25lbnQudHNcbnZhciBobXJTdGFydCA9IChob3N0RWxlbWVudCwgY21wTWV0YSwgaG1yVmVyc2lvbklkKSA9PiB7XG4gIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGhvc3RFbGVtZW50KTtcbiAgaG9zdFJlZi4kZmxhZ3MkID0gMSAvKiBoYXNDb25uZWN0ZWQgKi87XG4gIGluaXRpYWxpemVDb21wb25lbnQoaG9zdEVsZW1lbnQsIGhvc3RSZWYsIGNtcE1ldGEsIGhtclZlcnNpb25JZCk7XG59O1xuXG4vLyBzcmMvcnVudGltZS9ib290c3RyYXAtbGF6eS50c1xudmFyIGJvb3RzdHJhcExhenkgPSAobGF6eUJ1bmRsZXMsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICB2YXIgX2E7XG4gIGlmIChCVUlMRDI1LnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoXCJzdDphcHA6c3RhcnRcIik7XG4gIH1cbiAgaW5zdGFsbERldlRvb2xzKCk7XG4gIGNvbnN0IGVuZEJvb3RzdHJhcCA9IGNyZWF0ZVRpbWUoXCJib290c3RyYXBMYXp5XCIpO1xuICBjb25zdCBjbXBUYWdzID0gW107XG4gIGNvbnN0IGV4Y2x1ZGUgPSBvcHRpb25zLmV4Y2x1ZGUgfHwgW107XG4gIGNvbnN0IGN1c3RvbUVsZW1lbnRzMiA9IHdpbi5jdXN0b21FbGVtZW50cztcbiAgY29uc3QgaGVhZCA9IGRvYy5oZWFkO1xuICBjb25zdCBtZXRhQ2hhcnNldCA9IC8qIEBfX1BVUkVfXyAqLyBoZWFkLnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW2NoYXJzZXRdXCIpO1xuICBjb25zdCBkYXRhU3R5bGVzID0gLyogQF9fUFVSRV9fICovIGRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIGNvbnN0IGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzID0gW107XG4gIGNvbnN0IHN0eWxlczIgPSAvKiBAX19QVVJFX18gKi8gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoYFske0hZRFJBVEVEX1NUWUxFX0lEfV1gKTtcbiAgbGV0IGFwcExvYWRGYWxsYmFjaztcbiAgbGV0IGlzQm9vdHN0cmFwcGluZyA9IHRydWU7XG4gIGxldCBpMiA9IDA7XG4gIE9iamVjdC5hc3NpZ24ocGx0LCBvcHRpb25zKTtcbiAgcGx0LiRyZXNvdXJjZXNVcmwkID0gbmV3IFVSTChvcHRpb25zLnJlc291cmNlc1VybCB8fCBcIi4vXCIsIGRvYy5iYXNlVVJJKS5ocmVmO1xuICBpZiAoQlVJTEQyNS5hc3luY1F1ZXVlKSB7XG4gICAgaWYgKG9wdGlvbnMuc3luY1F1ZXVlKSB7XG4gICAgICBwbHQuJGZsYWdzJCB8PSA0IC8qIHF1ZXVlU3luYyAqLztcbiAgICB9XG4gIH1cbiAgaWYgKEJVSUxEMjUuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICBwbHQuJGZsYWdzJCB8PSAyIC8qIGFwcExvYWRlZCAqLztcbiAgfVxuICBpZiAoQlVJTEQyNS5oeWRyYXRlQ2xpZW50U2lkZSAmJiBCVUlMRDI1LnNoYWRvd0RvbSkge1xuICAgIGZvciAoOyBpMiA8IHN0eWxlczIubGVuZ3RoOyBpMisrKSB7XG4gICAgICByZWdpc3RlclN0eWxlKHN0eWxlczJbaTJdLmdldEF0dHJpYnV0ZShIWURSQVRFRF9TVFlMRV9JRCksIGNvbnZlcnRTY29wZWRUb1NoYWRvdyhzdHlsZXMyW2kyXS5pbm5lckhUTUwpLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgbGV0IGhhc1Nsb3RSZWxvY2F0aW9uID0gZmFsc2U7XG4gIGxhenlCdW5kbGVzLm1hcCgobGF6eUJ1bmRsZSkgPT4ge1xuICAgIGxhenlCdW5kbGVbMV0ubWFwKChjb21wYWN0TWV0YSkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICRmbGFncyQ6IGNvbXBhY3RNZXRhWzBdLFxuICAgICAgICAkdGFnTmFtZSQ6IGNvbXBhY3RNZXRhWzFdLFxuICAgICAgICAkbWVtYmVycyQ6IGNvbXBhY3RNZXRhWzJdLFxuICAgICAgICAkbGlzdGVuZXJzJDogY29tcGFjdE1ldGFbM11cbiAgICAgIH07XG4gICAgICBpZiAoY21wTWV0YS4kZmxhZ3MkICYgNCAvKiBoYXNTbG90UmVsb2NhdGlvbiAqLykge1xuICAgICAgICBoYXNTbG90UmVsb2NhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoQlVJTEQyNS5tZW1iZXIpIHtcbiAgICAgICAgY21wTWV0YS4kbWVtYmVycyQgPSBjb21wYWN0TWV0YVsyXTtcbiAgICAgIH1cbiAgICAgIGlmIChCVUlMRDI1Lmhvc3RMaXN0ZW5lcikge1xuICAgICAgICBjbXBNZXRhLiRsaXN0ZW5lcnMkID0gY29tcGFjdE1ldGFbM107XG4gICAgICB9XG4gICAgICBpZiAoQlVJTEQyNS5yZWZsZWN0KSB7XG4gICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKEJVSUxEMjUud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSAoX2EyID0gY29tcGFjdE1ldGFbNF0pICE9IG51bGwgPyBfYTIgOiB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChCVUlMRDI1LnNoYWRvd0RvbSAmJiAhc3VwcG9ydHNTaGFkb3cgJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhZ05hbWUgPSBCVUlMRDI1LnRyYW5zZm9ybVRhZ05hbWUgJiYgb3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lID8gb3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKGNtcE1ldGEuJHRhZ05hbWUkKSA6IGNtcE1ldGEuJHRhZ05hbWUkO1xuICAgICAgY29uc3QgSG9zdEVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgLy8gU3RlbmNpbExhenlIb3N0XG4gICAgICAgIGNvbnN0cnVjdG9yKHNlbGYpIHtcbiAgICAgICAgICBzdXBlcihzZWxmKTtcbiAgICAgICAgICB0aGlzLmhhc1JlZ2lzdGVyZWRFdmVudExpc3RlbmVycyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHJlZ2lzdGVySG9zdChzZWxmLCBjbXBNZXRhKTtcbiAgICAgICAgICBpZiAoQlVJTEQyNS5zaGFkb3dEb20gJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTaGFkb3cpIHtcbiAgICAgICAgICAgICAgaWYgKCFzZWxmLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQyNS5zaGFkb3dEZWxlZ2F0ZXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcIm9wZW5cIixcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVzRm9jdXM6ICEhKGNtcE1ldGEuJGZsYWdzJCAmIDE2IC8qIHNoYWRvd0RlbGVnYXRlc0ZvY3VzICovKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNoYWRvd1Jvb3QubW9kZSAhPT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYFVuYWJsZSB0byByZS11c2UgZXhpc3Rpbmcgc2hhZG93IHJvb3QgZm9yICR7Y21wTWV0YS4kdGFnTmFtZSR9ISBNb2RlIGlzIHNldCB0byAke3NlbGYuc2hhZG93Um9vdC5tb2RlfSBidXQgU3RlbmNpbCBvbmx5IHN1cHBvcnRzIG9wZW4gc2hhZG93IHJvb3RzLmBcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFCVUlMRDI1Lmh5ZHJhdGVTZXJ2ZXJTaWRlICYmICEoXCJzaGFkb3dSb290XCIgaW4gc2VsZikpIHtcbiAgICAgICAgICAgICAgc2VsZi5zaGFkb3dSb290ID0gc2VsZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYodGhpcyk7XG4gICAgICAgICAgaWYgKCF0aGlzLmhhc1JlZ2lzdGVyZWRFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5oYXNSZWdpc3RlcmVkRXZlbnRMaXN0ZW5lcnMgPSB0cnVlO1xuICAgICAgICAgICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKHRoaXMsIGhvc3RSZWYsIGNtcE1ldGEuJGxpc3RlbmVycyQsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFwcExvYWRGYWxsYmFjaykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFwcExvYWRGYWxsYmFjayk7XG4gICAgICAgICAgICBhcHBMb2FkRmFsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNCb290c3RyYXBwaW5nKSB7XG4gICAgICAgICAgICBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5wdXNoKHRoaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbHQuam1wKCgpID0+IGNvbm5lY3RlZENhbGxiYWNrKHRoaXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgcGx0LmptcCgoKSA9PiBkaXNjb25uZWN0ZWRDYWxsYmFjayh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50T25SZWFkeSgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0SG9zdFJlZih0aGlzKS4kb25SZWFkeVByb21pc2UkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKEJVSUxEMjUuZXhwZXJpbWVudGFsU2xvdEZpeGVzKSB7XG4gICAgICAgIGlmIChCVUlMRDI1LnNjb3BlZCAmJiBjbXBNZXRhLiRmbGFncyQgJiAyIC8qIHNjb3BlZENzc0VuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICBwYXRjaFBzZXVkb1NoYWRvd0RvbShIb3N0RWxlbWVudC5wcm90b3R5cGUsIGNtcE1ldGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQyNS5zbG90Q2hpbGROb2Rlc0ZpeCkge1xuICAgICAgICAgIHBhdGNoQ2hpbGRTbG90Tm9kZXMoSG9zdEVsZW1lbnQucHJvdG90eXBlLCBjbXBNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQyNS5jbG9uZU5vZGVGaXgpIHtcbiAgICAgICAgICBwYXRjaENsb25lTm9kZShIb3N0RWxlbWVudC5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRDI1LmFwcGVuZENoaWxkU2xvdEZpeCkge1xuICAgICAgICAgIHBhdGNoU2xvdEFwcGVuZENoaWxkKEhvc3RFbGVtZW50LnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxEMjUuc2NvcGVkU2xvdFRleHRDb250ZW50Rml4ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgIHBhdGNoVGV4dENvbnRlbnQoSG9zdEVsZW1lbnQucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKEJVSUxEMjUuZm9ybUFzc29jaWF0ZWQgJiYgY21wTWV0YS4kZmxhZ3MkICYgNjQgLyogZm9ybUFzc29jaWF0ZWQgKi8pIHtcbiAgICAgICAgSG9zdEVsZW1lbnQuZm9ybUFzc29jaWF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKEJVSUxEMjUuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgSG9zdEVsZW1lbnQucHJvdG90eXBlW1wicy1obXJcIl0gPSBmdW5jdGlvbihobXJWZXJzaW9uSWQpIHtcbiAgICAgICAgICBobXJTdGFydCh0aGlzLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY21wTWV0YS4kbGF6eUJ1bmRsZUlkJCA9IGxhenlCdW5kbGVbMF07XG4gICAgICBpZiAoIWV4Y2x1ZGUuaW5jbHVkZXModGFnTmFtZSkgJiYgIWN1c3RvbUVsZW1lbnRzMi5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY21wVGFncy5wdXNoKHRhZ05hbWUpO1xuICAgICAgICBjdXN0b21FbGVtZW50czIuZGVmaW5lKFxuICAgICAgICAgIHRhZ05hbWUsXG4gICAgICAgICAgcHJveHlDb21wb25lbnQoSG9zdEVsZW1lbnQsIGNtcE1ldGEsIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpZiAoY21wVGFncy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGhhc1Nsb3RSZWxvY2F0aW9uKSB7XG4gICAgICBkYXRhU3R5bGVzLnRleHRDb250ZW50ICs9IFNMT1RfRkJfQ1NTO1xuICAgIH1cbiAgICBpZiAoQlVJTEQyNS5pbnZpc2libGVQcmVoeWRyYXRpb24gJiYgKEJVSUxEMjUuaHlkcmF0ZWRDbGFzcyB8fCBCVUlMRDI1Lmh5ZHJhdGVkQXR0cmlidXRlKSkge1xuICAgICAgZGF0YVN0eWxlcy50ZXh0Q29udGVudCArPSBjbXBUYWdzLnNvcnQoKSArIEhZRFJBVEVEX0NTUztcbiAgICB9XG4gICAgaWYgKGRhdGFTdHlsZXMuaW5uZXJIVE1MLmxlbmd0aCkge1xuICAgICAgZGF0YVN0eWxlcy5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlc1wiLCBcIlwiKTtcbiAgICAgIGNvbnN0IG5vbmNlID0gKF9hID0gcGx0LiRub25jZSQpICE9IG51bGwgPyBfYSA6IHF1ZXJ5Tm9uY2VNZXRhVGFnQ29udGVudChkb2MpO1xuICAgICAgaWYgKG5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgZGF0YVN0eWxlcy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gICAgICB9XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShkYXRhU3R5bGVzLCBtZXRhQ2hhcnNldCA/IG1ldGFDaGFyc2V0Lm5leHRTaWJsaW5nIDogaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG4gIH1cbiAgaXNCb290c3RyYXBwaW5nID0gZmFsc2U7XG4gIGlmIChkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5tYXAoKGhvc3QpID0+IGhvc3QuY29ubmVjdGVkQ2FsbGJhY2soKSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEJVSUxEMjUucHJvZmlsZSkge1xuICAgICAgcGx0LmptcCgoKSA9PiBhcHBMb2FkRmFsbGJhY2sgPSBzZXRUaW1lb3V0KGFwcERpZExvYWQsIDMwLCBcInRpbWVvdXRcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbHQuam1wKCgpID0+IGFwcExvYWRGYWxsYmFjayA9IHNldFRpbWVvdXQoYXBwRGlkTG9hZCwgMzApKTtcbiAgICB9XG4gIH1cbiAgZW5kQm9vdHN0cmFwKCk7XG59O1xuXG4vLyBzcmMvcnVudGltZS9mcmFnbWVudC50c1xudmFyIEZyYWdtZW50ID0gKF8sIGNoaWxkcmVuKSA9PiBjaGlsZHJlbjtcblxuLy8gc3JjL3J1bnRpbWUvaG9zdC1saXN0ZW5lci50c1xuaW1wb3J0IHsgQlVJTEQgYXMgQlVJTEQyNiB9IGZyb20gXCJAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhXCI7XG52YXIgYWRkSG9zdEV2ZW50TGlzdGVuZXJzID0gKGVsbSwgaG9zdFJlZiwgbGlzdGVuZXJzLCBhdHRhY2hQYXJlbnRMaXN0ZW5lcnMpID0+IHtcbiAgaWYgKEJVSUxEMjYuaG9zdExpc3RlbmVyICYmIGxpc3RlbmVycykge1xuICAgIGlmIChCVUlMRDI2Lmhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCkge1xuICAgICAgaWYgKGF0dGFjaFBhcmVudExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKChbZmxhZ3NdKSA9PiBmbGFncyAmIDMyIC8qIFRhcmdldFBhcmVudCAqLyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKChbZmxhZ3NdKSA9PiAhKGZsYWdzICYgMzIgLyogVGFyZ2V0UGFyZW50ICovKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxpc3RlbmVycy5tYXAoKFtmbGFncywgbmFtZSwgbWV0aG9kXSkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gQlVJTEQyNi5ob3N0TGlzdGVuZXJUYXJnZXQgPyBnZXRIb3N0TGlzdGVuZXJUYXJnZXQoZWxtLCBmbGFncykgOiBlbG07XG4gICAgICBjb25zdCBoYW5kbGVyID0gaG9zdExpc3RlbmVyUHJveHkoaG9zdFJlZiwgbWV0aG9kKTtcbiAgICAgIGNvbnN0IG9wdHMgPSBob3N0TGlzdGVuZXJPcHRzKGZsYWdzKTtcbiAgICAgIHBsdC5hZWwodGFyZ2V0LCBuYW1lLCBoYW5kbGVyLCBvcHRzKTtcbiAgICAgIChob3N0UmVmLiRybUxpc3RlbmVycyQgPSBob3N0UmVmLiRybUxpc3RlbmVycyQgfHwgW10pLnB1c2goKCkgPT4gcGx0LnJlbCh0YXJnZXQsIG5hbWUsIGhhbmRsZXIsIG9wdHMpKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBob3N0TGlzdGVuZXJQcm94eSA9IChob3N0UmVmLCBtZXRob2ROYW1lKSA9PiAoZXYpID0+IHtcbiAgdmFyIF9hO1xuICB0cnkge1xuICAgIGlmIChCVUlMRDI2LmxhenlMb2FkKSB7XG4gICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMjU2IC8qIGlzTGlzdGVuUmVhZHkgKi8pIHtcbiAgICAgICAgKF9hID0gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW21ldGhvZE5hbWVdKGV2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkID0gaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCB8fCBbXSkucHVzaChbbWV0aG9kTmFtZSwgZXZdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaG9zdFJlZi4kaG9zdEVsZW1lbnQkW21ldGhvZE5hbWVdKGV2KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlRXJyb3IoZSk7XG4gIH1cbn07XG52YXIgZ2V0SG9zdExpc3RlbmVyVGFyZ2V0ID0gKGVsbSwgZmxhZ3MpID0+IHtcbiAgaWYgKEJVSUxEMjYuaG9zdExpc3RlbmVyVGFyZ2V0RG9jdW1lbnQgJiYgZmxhZ3MgJiA0IC8qIFRhcmdldERvY3VtZW50ICovKSByZXR1cm4gZG9jO1xuICBpZiAoQlVJTEQyNi5ob3N0TGlzdGVuZXJUYXJnZXRXaW5kb3cgJiYgZmxhZ3MgJiA4IC8qIFRhcmdldFdpbmRvdyAqLykgcmV0dXJuIHdpbjtcbiAgaWYgKEJVSUxEMjYuaG9zdExpc3RlbmVyVGFyZ2V0Qm9keSAmJiBmbGFncyAmIDE2IC8qIFRhcmdldEJvZHkgKi8pIHJldHVybiBkb2MuYm9keTtcbiAgaWYgKEJVSUxEMjYuaG9zdExpc3RlbmVyVGFyZ2V0UGFyZW50ICYmIGZsYWdzICYgMzIgLyogVGFyZ2V0UGFyZW50ICovICYmIGVsbS5wYXJlbnRFbGVtZW50KVxuICAgIHJldHVybiBlbG0ucGFyZW50RWxlbWVudDtcbiAgcmV0dXJuIGVsbTtcbn07XG52YXIgaG9zdExpc3RlbmVyT3B0cyA9IChmbGFncykgPT4gc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPyB7XG4gIHBhc3NpdmU6IChmbGFncyAmIDEgLyogUGFzc2l2ZSAqLykgIT09IDAsXG4gIGNhcHR1cmU6IChmbGFncyAmIDIgLyogQ2FwdHVyZSAqLykgIT09IDBcbn0gOiAoZmxhZ3MgJiAyIC8qIENhcHR1cmUgKi8pICE9PSAwO1xuXG4vLyBzcmMvcnVudGltZS9ub25jZS50c1xudmFyIHNldE5vbmNlID0gKG5vbmNlKSA9PiBwbHQuJG5vbmNlJCA9IG5vbmNlO1xuXG4vLyBzcmMvcnVudGltZS9wbGF0Zm9ybS1vcHRpb25zLnRzXG52YXIgc2V0UGxhdGZvcm1PcHRpb25zID0gKG9wdHMpID0+IE9iamVjdC5hc3NpZ24ocGx0LCBvcHRzKTtcblxuLy8gc3JjL3J1bnRpbWUvdmRvbS92ZG9tLWFubm90YXRpb25zLnRzXG52YXIgaW5zZXJ0VmRvbUFubm90YXRpb25zID0gKGRvYzIsIHN0YXRpY0NvbXBvbmVudHMpID0+IHtcbiAgaWYgKGRvYzIgIT0gbnVsbCkge1xuICAgIGNvbnN0IGRvY0RhdGEgPSB7XG4gICAgICBob3N0SWRzOiAwLFxuICAgICAgcm9vdExldmVsSWRzOiAwLFxuICAgICAgc3RhdGljQ29tcG9uZW50czogbmV3IFNldChzdGF0aWNDb21wb25lbnRzKVxuICAgIH07XG4gICAgY29uc3Qgb3JnTG9jYXRpb25Ob2RlcyA9IFtdO1xuICAgIHBhcnNlVk5vZGVBbm5vdGF0aW9ucyhkb2MyLCBkb2MyLmJvZHksIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgIG9yZ0xvY2F0aW9uTm9kZXMuZm9yRWFjaCgob3JnTG9jYXRpb25Ob2RlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAob3JnTG9jYXRpb25Ob2RlICE9IG51bGwgJiYgb3JnTG9jYXRpb25Ob2RlW1wicy1uclwiXSkge1xuICAgICAgICBjb25zdCBub2RlUmVmID0gb3JnTG9jYXRpb25Ob2RlW1wicy1uclwiXTtcbiAgICAgICAgbGV0IGhvc3RJZCA9IG5vZGVSZWZbXCJzLWhvc3QtaWRcIl07XG4gICAgICAgIGxldCBub2RlSWQgPSBub2RlUmVmW1wicy1ub2RlLWlkXCJdO1xuICAgICAgICBsZXQgY2hpbGRJZCA9IGAke2hvc3RJZH0uJHtub2RlSWR9YDtcbiAgICAgICAgaWYgKGhvc3RJZCA9PSBudWxsKSB7XG4gICAgICAgICAgaG9zdElkID0gMDtcbiAgICAgICAgICBkb2NEYXRhLnJvb3RMZXZlbElkcysrO1xuICAgICAgICAgIG5vZGVJZCA9IGRvY0RhdGEucm9vdExldmVsSWRzO1xuICAgICAgICAgIGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfWA7XG4gICAgICAgICAgaWYgKG5vZGVSZWYubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgICAgIG5vZGVSZWYuc2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQsIGNoaWxkSWQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLykge1xuICAgICAgICAgICAgaWYgKGhvc3RJZCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudCA9IChfYSA9IG5vZGVSZWYubm9kZVZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHJpbSgpO1xuICAgICAgICAgICAgICBpZiAodGV4dENvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb21tZW50QmVmb3JlVGV4dE5vZGUgPSBkb2MyLmNyZWF0ZUNvbW1lbnQoY2hpbGRJZCk7XG4gICAgICAgICAgICBjb21tZW50QmVmb3JlVGV4dE5vZGUubm9kZVZhbHVlID0gYCR7VEVYVF9OT0RFX0lEfS4ke2NoaWxkSWR9YDtcbiAgICAgICAgICAgIGluc2VydEJlZm9yZShub2RlUmVmLnBhcmVudE5vZGUsIGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSwgbm9kZVJlZik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvcmdMb2NhdGlvbk5vZGVJZCA9IGAke09SR19MT0NBVElPTl9JRH0uJHtjaGlsZElkfWA7XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uUGFyZW50Tm9kZSA9IG9yZ0xvY2F0aW9uTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAob3JnTG9jYXRpb25QYXJlbnROb2RlKSB7XG4gICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uUGFyZW50Tm9kZVtcInMtZW5cIl0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZUlkICs9IGAuYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9yZ0xvY2F0aW9uUGFyZW50Tm9kZVtcInMtZW5cIl0gPT09IFwiY1wiKSB7XG4gICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVJZCArPSBgLmNgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcmdMb2NhdGlvbk5vZGUubm9kZVZhbHVlID0gb3JnTG9jYXRpb25Ob2RlSWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG52YXIgcGFyc2VWTm9kZUFubm90YXRpb25zID0gKGRvYzIsIG5vZGUsIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpID0+IHtcbiAgdmFyIF9hO1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChub2RlW1wicy1uclwiXSAhPSBudWxsKSB7XG4gICAgb3JnTG9jYXRpb25Ob2Rlcy5wdXNoKG5vZGUpO1xuICB9XG4gIGlmIChub2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IFsuLi5BcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcyksIC4uLkFycmF5LmZyb20oKChfYSA9IG5vZGUuc2hhZG93Um9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNoaWxkTm9kZXMpIHx8IFtdKV07XG4gICAgY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGNoaWxkTm9kZSk7XG4gICAgICBpZiAoaG9zdFJlZiAhPSBudWxsICYmICFkb2NEYXRhLnN0YXRpY0NvbXBvbmVudHMuaGFzKGNoaWxkTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBjb25zdCBjbXBEYXRhID0ge1xuICAgICAgICAgIG5vZGVJZHM6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaW5zZXJ0Vk5vZGVBbm5vdGF0aW9ucyhkb2MyLCBjaGlsZE5vZGUsIGhvc3RSZWYuJHZub2RlJCwgZG9jRGF0YSwgY21wRGF0YSk7XG4gICAgICB9XG4gICAgICBwYXJzZVZOb2RlQW5ub3RhdGlvbnMoZG9jMiwgY2hpbGROb2RlLCBkb2NEYXRhLCBvcmdMb2NhdGlvbk5vZGVzKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBpbnNlcnRWTm9kZUFubm90YXRpb25zID0gKGRvYzIsIGhvc3RFbG0sIHZub2RlLCBkb2NEYXRhLCBjbXBEYXRhKSA9PiB7XG4gIGlmICh2bm9kZSAhPSBudWxsKSB7XG4gICAgY29uc3QgaG9zdElkID0gKytkb2NEYXRhLmhvc3RJZHM7XG4gICAgaG9zdEVsbS5zZXRBdHRyaWJ1dGUoSFlEUkFURV9JRCwgaG9zdElkKTtcbiAgICBpZiAoaG9zdEVsbVtcInMtY3JcIl0gIT0gbnVsbCkge1xuICAgICAgaG9zdEVsbVtcInMtY3JcIl0ubm9kZVZhbHVlID0gYCR7Q09OVEVOVF9SRUZfSUR9LiR7aG9zdElkfWA7XG4gICAgfVxuICAgIGlmICh2bm9kZS4kY2hpbGRyZW4kICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRlcHRoID0gMDtcbiAgICAgIHZub2RlLiRjaGlsZHJlbiQuZm9yRWFjaCgodm5vZGVDaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgaW5zZXJ0Q2hpbGRWTm9kZUFubm90YXRpb25zKGRvYzIsIHZub2RlQ2hpbGQsIGNtcERhdGEsIGhvc3RJZCwgZGVwdGgsIGluZGV4KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaG9zdEVsbSAmJiB2bm9kZSAmJiB2bm9kZS4kZWxtJCAmJiAhaG9zdEVsbS5oYXNBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGhvc3RFbG0ucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmNoaWxkTm9kZXMpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Q2hpbGROb2RlcyA9IEFycmF5LmZyb20ocGFyZW50LmNoaWxkTm9kZXMpO1xuICAgICAgICBjb25zdCBjb21tZW50ID0gcGFyZW50Q2hpbGROb2Rlcy5maW5kKFxuICAgICAgICAgIChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovICYmIG5vZGVbXCJzLXNyXCJdXG4gICAgICAgICk7XG4gICAgICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnRDaGlsZE5vZGVzLmluZGV4T2YoaG9zdEVsbSkgLSAxO1xuICAgICAgICAgIHZub2RlLiRlbG0kLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgIEhZRFJBVEVfQ0hJTERfSUQsXG4gICAgICAgICAgICBgJHtjb21tZW50W1wicy1ob3N0LWlkXCJdfS4ke2NvbW1lbnRbXCJzLW5vZGUtaWRcIl19LjAuJHtpbmRleH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBpbnNlcnRDaGlsZFZOb2RlQW5ub3RhdGlvbnMgPSAoZG9jMiwgdm5vZGVDaGlsZCwgY21wRGF0YSwgaG9zdElkLCBkZXB0aCwgaW5kZXgpID0+IHtcbiAgY29uc3QgY2hpbGRFbG0gPSB2bm9kZUNoaWxkLiRlbG0kO1xuICBpZiAoY2hpbGRFbG0gPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBub2RlSWQgPSBjbXBEYXRhLm5vZGVJZHMrKztcbiAgY29uc3QgY2hpbGRJZCA9IGAke2hvc3RJZH0uJHtub2RlSWR9LiR7ZGVwdGh9LiR7aW5kZXh9YDtcbiAgY2hpbGRFbG1bXCJzLWhvc3QtaWRcIl0gPSBob3N0SWQ7XG4gIGNoaWxkRWxtW1wicy1ub2RlLWlkXCJdID0gbm9kZUlkO1xuICBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICBjaGlsZEVsbS5zZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCwgY2hpbGRJZCk7XG4gIH0gZWxzZSBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8pIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gY2hpbGRFbG0ucGFyZW50Tm9kZTtcbiAgICBjb25zdCBub2RlTmFtZSA9IHBhcmVudE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudE5vZGUubm9kZU5hbWU7XG4gICAgaWYgKG5vZGVOYW1lICE9PSBcIlNUWUxFXCIgJiYgbm9kZU5hbWUgIT09IFwiU0NSSVBUXCIpIHtcbiAgICAgIGNvbnN0IHRleHROb2RlSWQgPSBgJHtURVhUX05PREVfSUR9LiR7Y2hpbGRJZH1gO1xuICAgICAgY29uc3QgY29tbWVudEJlZm9yZVRleHROb2RlID0gZG9jMi5jcmVhdGVDb21tZW50KHRleHROb2RlSWQpO1xuICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudE5vZGUsIGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSwgY2hpbGRFbG0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaGlsZEVsbS5ub2RlVHlwZSA9PT0gOCAvKiBDb21tZW50Tm9kZSAqLykge1xuICAgIGlmIChjaGlsZEVsbVtcInMtc3JcIl0pIHtcbiAgICAgIGNvbnN0IHNsb3ROYW1lID0gY2hpbGRFbG1bXCJzLXNuXCJdIHx8IFwiXCI7XG4gICAgICBjb25zdCBzbG90Tm9kZUlkID0gYCR7U0xPVF9OT0RFX0lEfS4ke2NoaWxkSWR9LiR7c2xvdE5hbWV9YDtcbiAgICAgIGNoaWxkRWxtLm5vZGVWYWx1ZSA9IHNsb3ROb2RlSWQ7XG4gICAgfVxuICB9XG4gIGlmICh2bm9kZUNoaWxkLiRjaGlsZHJlbiQgIT0gbnVsbCkge1xuICAgIGNvbnN0IGNoaWxkRGVwdGggPSBkZXB0aCArIDE7XG4gICAgdm5vZGVDaGlsZC4kY2hpbGRyZW4kLmZvckVhY2goKHZub2RlLCBpbmRleDIpID0+IHtcbiAgICAgIGluc2VydENoaWxkVk5vZGVBbm5vdGF0aW9ucyhkb2MyLCB2bm9kZSwgY21wRGF0YSwgaG9zdElkLCBjaGlsZERlcHRoLCBpbmRleDIpO1xuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQlVJTEQyNyBhcyBCVUlMRCxcbiAgQnVpbGQsXG4gIEVudixcbiAgRnJhZ21lbnQsXG4gIEgsXG4gIEggYXMgSFRNTEVsZW1lbnQsXG4gIEhvc3QsXG4gIE5BTUVTUEFDRTIgYXMgTkFNRVNQQUNFLFxuICBTVEVOQ0lMX0RFVl9NT0RFLFxuICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMsXG4gIGJvb3RzdHJhcExhenksXG4gIGNtcE1vZHVsZXMsXG4gIGNvbm5lY3RlZENhbGxiYWNrLFxuICBjb25zb2xlRGV2RXJyb3IsXG4gIGNvbnNvbGVEZXZJbmZvLFxuICBjb25zb2xlRGV2V2FybixcbiAgY29uc29sZUVycm9yLFxuICBjcmVhdGVFdmVudCxcbiAgZGVmaW5lQ3VzdG9tRWxlbWVudCxcbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2ssXG4gIGRvYyxcbiAgZm9yY2VNb2RlVXBkYXRlLFxuICBmb3JjZVVwZGF0ZSxcbiAgZ2V0QXNzZXRQYXRoLFxuICBnZXRFbGVtZW50LFxuICBnZXRIb3N0UmVmLFxuICBnZXRNb2RlLFxuICBnZXRSZW5kZXJpbmdSZWYsXG4gIGdldFZhbHVlLFxuICBoLFxuICBpbnNlcnRWZG9tQW5ub3RhdGlvbnMsXG4gIGlzTWVtYmVySW5FbGVtZW50LFxuICBsb2FkTW9kdWxlLFxuICBtb2RlUmVzb2x1dGlvbkNoYWluLFxuICBuZXh0VGljayxcbiAgcGFyc2VQcm9wZXJ0eVZhbHVlLFxuICBwbHQsXG4gIHBvc3RVcGRhdGVDb21wb25lbnQsXG4gIHByb21pc2VSZXNvbHZlLFxuICBwcm94eUNvbXBvbmVudCxcbiAgcHJveHlDdXN0b21FbGVtZW50LFxuICByZWFkVGFzayxcbiAgcmVnaXN0ZXJIb3N0LFxuICByZWdpc3Rlckluc3RhbmNlLFxuICByZW5kZXJWZG9tLFxuICBzZXRBc3NldFBhdGgsXG4gIHNldEVycm9ySGFuZGxlcixcbiAgc2V0TW9kZSxcbiAgc2V0Tm9uY2UsXG4gIHNldFBsYXRmb3JtSGVscGVycyxcbiAgc2V0UGxhdGZvcm1PcHRpb25zLFxuICBzZXRWYWx1ZSxcbiAgc3R5bGVzLFxuICBzdXBwb3J0c0NvbnN0cnVjdGFibGVTdHlsZXNoZWV0cyxcbiAgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMsXG4gIHN1cHBvcnRzU2hhZG93LFxuICB3aW4sXG4gIHdyaXRlVGFza1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stencil/core/internal/client/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stencil/core/internal/client/shadow-css.js":
/*!******************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/client/shadow-css.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scopeCss: () => (/* binding */ scopeCss)\n/* harmony export */ });\n// src/utils/regular-expression.ts\nvar escapeRegExpSpecialCharacters = (text) => {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n};\n\n// src/utils/shadow-css.ts\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n *\n * This file is a port of shadowCSS from `webcomponents.js` to TypeScript.\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts\n */\nvar safeSelector = (selector) => {\n  const placeholders = [];\n  let index = 0;\n  selector = selector.replace(/(\\[[^\\]]*\\])/g, (_, keep) => {\n    const replaceBy = `__ph-${index}__`;\n    placeholders.push(keep);\n    index++;\n    return replaceBy;\n  });\n  const content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n    const replaceBy = `__ph-${index}__`;\n    placeholders.push(exp);\n    index++;\n    return pseudo + replaceBy;\n  });\n  const ss = {\n    content,\n    placeholders\n  };\n  return ss;\n};\nvar restoreSafeSelector = (placeholders, content) => {\n  return content.replace(/__ph-(\\d+)__/g, (_, index) => placeholders[+index]);\n};\nvar _polyfillHost = \"-shadowcsshost\";\nvar _polyfillSlotted = \"-shadowcssslotted\";\nvar _polyfillHostContext = \"-shadowcsscontext\";\nvar _parenSuffix = \")(?:\\\\(((?:\\\\([^)(]*\\\\)|[^)(]*)+?)\\\\))?([^,{]*)\";\nvar _cssColonHostRe = new RegExp(\"(\" + _polyfillHost + _parenSuffix, \"gim\");\nvar _cssColonHostContextRe = new RegExp(\"(\" + _polyfillHostContext + _parenSuffix, \"gim\");\nvar _cssColonSlottedRe = new RegExp(\"(\" + _polyfillSlotted + _parenSuffix, \"gim\");\nvar _polyfillHostNoCombinator = _polyfillHost + \"-no-combinator\";\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [/::shadow/g, /::content/g];\nvar _selectorReSuffix = \"([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$\";\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar createSupportsRuleRe = (selector) => new RegExp(`((?<!(^@supports(.*)))|(?<={.*))(${selector}\\\\b)`, \"gim\");\nvar _colonSlottedRe = createSupportsRuleRe(\"::slotted\");\nvar _colonHostRe = createSupportsRuleRe(\":host\");\nvar _colonHostContextRe = createSupportsRuleRe(\":host-context\");\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\nvar stripComments = (input) => {\n  return input.replace(_commentRe, \"\");\n};\nvar _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\nvar extractCommentsWithHash = (input) => {\n  return input.match(_commentWithHashRe) || [];\n};\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _curlyRe = /([{}])/g;\nvar _selectorPartsRe = /(^.*?[^\\\\])??((:+)(.*)|$)/;\nvar OPEN_CURLY = \"{\";\nvar CLOSE_CURLY = \"}\";\nvar BLOCK_PLACEHOLDER = \"%BLOCK%\";\nvar processRules = (input, ruleCallback) => {\n  const inputWithEscapedBlocks = escapeBlocks(input);\n  let nextBlockIndex = 0;\n  return inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {\n    const selector = m[2];\n    let content = \"\";\n    let suffix = m[4];\n    let contentPrefix = \"\";\n    if (suffix && suffix.startsWith(\"{\" + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = \"{\";\n    }\n    const cssRule = {\n      selector,\n      content\n    };\n    const rule = ruleCallback(cssRule);\n    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n  });\n};\nvar escapeBlocks = (input) => {\n  const inputParts = input.split(_curlyRe);\n  const resultParts = [];\n  const escapedBlocks = [];\n  let bracketCount = 0;\n  let currentBlockParts = [];\n  for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {\n    const part = inputParts[partIndex];\n    if (part === CLOSE_CURLY) {\n      bracketCount--;\n    }\n    if (bracketCount > 0) {\n      currentBlockParts.push(part);\n    } else {\n      if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(\"\"));\n        resultParts.push(BLOCK_PLACEHOLDER);\n        currentBlockParts = [];\n      }\n      resultParts.push(part);\n    }\n    if (part === OPEN_CURLY) {\n      bracketCount++;\n    }\n  }\n  if (currentBlockParts.length > 0) {\n    escapedBlocks.push(currentBlockParts.join(\"\"));\n    resultParts.push(BLOCK_PLACEHOLDER);\n  }\n  const strEscapedBlocks = {\n    escapedString: resultParts.join(\"\"),\n    blocks: escapedBlocks\n  };\n  return strEscapedBlocks;\n};\nvar insertPolyfillHostInCssText = (cssText) => {\n  cssText = cssText.replace(_colonHostContextRe, `$1${_polyfillHostContext}`).replace(_colonHostRe, `$1${_polyfillHost}`).replace(_colonSlottedRe, `$1${_polyfillSlotted}`);\n  return cssText;\n};\nvar convertColonRule = (cssText, regExp, partReplacer) => {\n  return cssText.replace(regExp, (...m) => {\n    if (m[2]) {\n      const parts = m[2].split(\",\");\n      const r = [];\n      for (let i = 0; i < parts.length; i++) {\n        const p = parts[i].trim();\n        if (!p) break;\n        r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n      }\n      return r.join(\",\");\n    } else {\n      return _polyfillHostNoCombinator + m[3];\n    }\n  });\n};\nvar colonHostPartReplacer = (host, part, suffix) => {\n  return host + part.replace(_polyfillHost, \"\") + suffix;\n};\nvar convertColonHost = (cssText) => {\n  return convertColonRule(cssText, _cssColonHostRe, colonHostPartReplacer);\n};\nvar colonHostContextPartReplacer = (host, part, suffix) => {\n  if (part.indexOf(_polyfillHost) > -1) {\n    return colonHostPartReplacer(host, part, suffix);\n  } else {\n    return host + part + suffix + \", \" + part + \" \" + host + suffix;\n  }\n};\nvar convertColonSlotted = (cssText, slotScopeId) => {\n  const slotClass = \".\" + slotScopeId + \" > \";\n  const selectors = [];\n  cssText = cssText.replace(_cssColonSlottedRe, (...m) => {\n    if (m[2]) {\n      const compound = m[2].trim();\n      const suffix = m[3];\n      const slottedSelector = slotClass + compound + suffix;\n      let prefixSelector = \"\";\n      for (let i = m[4] - 1; i >= 0; i--) {\n        const char = m[5][i];\n        if (char === \"}\" || char === \",\") {\n          break;\n        }\n        prefixSelector = char + prefixSelector;\n      }\n      const orgSelector = (prefixSelector + slottedSelector).trim();\n      const addedSelector = `${prefixSelector.trimEnd()}${slottedSelector.trim()}`.trim();\n      if (orgSelector !== addedSelector) {\n        const updatedSelector = `${addedSelector}, ${orgSelector}`;\n        selectors.push({\n          orgSelector,\n          updatedSelector\n        });\n      }\n      return slottedSelector;\n    } else {\n      return _polyfillHostNoCombinator + m[3];\n    }\n  });\n  return {\n    selectors,\n    cssText\n  };\n};\nvar convertColonHostContext = (cssText) => {\n  return convertColonRule(cssText, _cssColonHostContextRe, colonHostContextPartReplacer);\n};\nvar convertShadowDOMSelectors = (cssText) => {\n  return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, \" \"), cssText);\n};\nvar makeScopeMatcher = (scopeSelector2) => {\n  const lre = /\\[/g;\n  const rre = /\\]/g;\n  scopeSelector2 = scopeSelector2.replace(lre, \"\\\\[\").replace(rre, \"\\\\]\");\n  return new RegExp(\"^(\" + scopeSelector2 + \")\" + _selectorReSuffix, \"m\");\n};\nvar selectorNeedsScoping = (selector, scopeSelector2) => {\n  const re = makeScopeMatcher(scopeSelector2);\n  return !re.test(selector);\n};\nvar injectScopingSelector = (selector, scopingSelector) => {\n  return selector.replace(_selectorPartsRe, (_, before = \"\", _colonGroup, colon = \"\", after = \"\") => {\n    return before + scopingSelector + colon + after;\n  });\n};\nvar applySimpleSelectorScope = (selector, scopeSelector2, hostSelector) => {\n  _polyfillHostRe.lastIndex = 0;\n  if (_polyfillHostRe.test(selector)) {\n    const replaceBy = `.${hostSelector}`;\n    return selector.replace(_polyfillHostNoCombinatorRe, (_, selector2) => injectScopingSelector(selector2, replaceBy)).replace(_polyfillHostRe, replaceBy + \" \");\n  }\n  return scopeSelector2 + \" \" + selector;\n};\nvar applyStrictSelectorScope = (selector, scopeSelector2, hostSelector) => {\n  const isRe = /\\[is=([^\\]]*)\\]/g;\n  scopeSelector2 = scopeSelector2.replace(isRe, (_, ...parts) => parts[0]);\n  const className = \".\" + scopeSelector2;\n  const _scopeSelectorPart = (p) => {\n    let scopedP = p.trim();\n    if (!scopedP) {\n      return \"\";\n    }\n    if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n      scopedP = applySimpleSelectorScope(p, scopeSelector2, hostSelector);\n    } else {\n      const t = p.replace(_polyfillHostRe, \"\");\n      if (t.length > 0) {\n        scopedP = injectScopingSelector(t, className);\n      }\n    }\n    return scopedP;\n  };\n  const safeContent = safeSelector(selector);\n  selector = safeContent.content;\n  let scopedSelector = \"\";\n  let startIndex = 0;\n  let res;\n  const sep = /( |>|\\+|~(?!=))\\s*/g;\n  const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n  let shouldScope = !hasHost;\n  while ((res = sep.exec(selector)) !== null) {\n    const separator = res[1];\n    const part2 = selector.slice(startIndex, res.index).trim();\n    shouldScope = shouldScope || part2.indexOf(_polyfillHostNoCombinator) > -1;\n    const scopedPart = shouldScope ? _scopeSelectorPart(part2) : part2;\n    scopedSelector += `${scopedPart} ${separator} `;\n    startIndex = sep.lastIndex;\n  }\n  const part = selector.substring(startIndex);\n  shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n  scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n  return restoreSafeSelector(safeContent.placeholders, scopedSelector);\n};\nvar scopeSelector = (selector, scopeSelectorText, hostSelector, slotSelector) => {\n  return selector.split(\",\").map((shallowPart) => {\n    if (slotSelector && shallowPart.indexOf(\".\" + slotSelector) > -1) {\n      return shallowPart.trim();\n    }\n    if (selectorNeedsScoping(shallowPart, scopeSelectorText)) {\n      return applyStrictSelectorScope(shallowPart, scopeSelectorText, hostSelector).trim();\n    } else {\n      return shallowPart.trim();\n    }\n  }).join(\", \");\n};\nvar scopeSelectors = (cssText, scopeSelectorText, hostSelector, slotSelector, commentOriginalSelector) => {\n  return processRules(cssText, (rule) => {\n    let selector = rule.selector;\n    let content = rule.content;\n    if (rule.selector[0] !== \"@\") {\n      selector = scopeSelector(rule.selector, scopeSelectorText, hostSelector, slotSelector);\n    } else if (rule.selector.startsWith(\"@media\") || rule.selector.startsWith(\"@supports\") || rule.selector.startsWith(\"@page\") || rule.selector.startsWith(\"@document\")) {\n      content = scopeSelectors(rule.content, scopeSelectorText, hostSelector, slotSelector, commentOriginalSelector);\n    }\n    const cssRule = {\n      selector: selector.replace(/\\s{2,}/g, \" \").trim(),\n      content\n    };\n    return cssRule;\n  });\n};\nvar scopeCssText = (cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector) => {\n  cssText = insertPolyfillHostInCssText(cssText);\n  cssText = convertColonHost(cssText);\n  cssText = convertColonHostContext(cssText);\n  const slotted = convertColonSlotted(cssText, slotScopeId);\n  cssText = slotted.cssText;\n  cssText = convertShadowDOMSelectors(cssText);\n  if (scopeId) {\n    cssText = scopeSelectors(cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector);\n  }\n  cssText = replaceShadowCssHost(cssText, hostScopeId);\n  cssText = cssText.replace(/>\\s*\\*\\s+([^{, ]+)/gm, \" $1 \");\n  return {\n    cssText: cssText.trim(),\n    // We need to replace the shadow CSS host string in each of these selectors since we created\n    // them prior to the replacement happening in the components CSS text.\n    slottedSelectors: slotted.selectors.map((ref) => ({\n      orgSelector: replaceShadowCssHost(ref.orgSelector, hostScopeId),\n      updatedSelector: replaceShadowCssHost(ref.updatedSelector, hostScopeId)\n    }))\n  };\n};\nvar replaceShadowCssHost = (cssText, hostScopeId) => {\n  return cssText.replace(/-shadowcsshost-no-combinator/g, `.${hostScopeId}`);\n};\nvar scopeCss = (cssText, scopeId, commentOriginalSelector) => {\n  const hostScopeId = scopeId + \"-h\";\n  const slotScopeId = scopeId + \"-s\";\n  const commentsWithHash = extractCommentsWithHash(cssText);\n  cssText = stripComments(cssText);\n  const orgSelectors = [];\n  if (commentOriginalSelector) {\n    const processCommentedSelector = (rule) => {\n      const placeholder = `/*!@___${orgSelectors.length}___*/`;\n      const comment = `/*!@${rule.selector}*/`;\n      orgSelectors.push({ placeholder, comment });\n      rule.selector = placeholder + rule.selector;\n      return rule;\n    };\n    cssText = processRules(cssText, (rule) => {\n      if (rule.selector[0] !== \"@\") {\n        return processCommentedSelector(rule);\n      } else if (rule.selector.startsWith(\"@media\") || rule.selector.startsWith(\"@supports\") || rule.selector.startsWith(\"@page\") || rule.selector.startsWith(\"@document\")) {\n        rule.content = processRules(rule.content, processCommentedSelector);\n        return rule;\n      }\n      return rule;\n    });\n  }\n  const scoped = scopeCssText(cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector);\n  cssText = [scoped.cssText, ...commentsWithHash].join(\"\\n\");\n  if (commentOriginalSelector) {\n    orgSelectors.forEach(({ placeholder, comment }) => {\n      cssText = cssText.replace(placeholder, comment);\n    });\n  }\n  scoped.slottedSelectors.forEach((slottedSelector) => {\n    const regex = new RegExp(escapeRegExpSpecialCharacters(slottedSelector.orgSelector), \"g\");\n    cssText = cssText.replace(regex, slottedSelector.updatedSelector);\n  });\n  return cssText;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvc2hhZG93LWNzcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsaUZBQWlGLE9BQU8sU0FBUztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsRUFBRSxjQUFjLFFBQVEsS0FBSyxVQUFVO0FBQ2pFLG9CQUFvQjtBQUNwQjtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLLEVBQUUsY0FBYyxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUUsYUFBYSxFQUFFLE9BQU87QUFDbEYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUJBQXFCLDhCQUE4QixjQUFjLGlDQUFpQyxpQkFBaUI7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QixFQUFFLHVCQUF1QjtBQUNqRjtBQUNBLG1DQUFtQyxjQUFjLElBQUksWUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVksRUFBRSxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQsNkJBQTZCLGNBQWM7QUFDM0MsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9zaGFkb3ctY3NzLmpzPzQyMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzL3JlZ3VsYXItZXhwcmVzc2lvbi50c1xudmFyIGVzY2FwZVJlZ0V4cFNwZWNpYWxDaGFyYWN0ZXJzID0gKHRleHQpID0+IHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufTtcblxuLy8gc3JjL3V0aWxzL3NoYWRvdy1jc3MudHNcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKlxuICogVGhpcyBmaWxlIGlzIGEgcG9ydCBvZiBzaGFkb3dDU1MgZnJvbSBgd2ViY29tcG9uZW50cy5qc2AgdG8gVHlwZVNjcmlwdC5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy9ibG9iLzRlZmVjZDdlMGUvc3JjL1NoYWRvd0NTUy9TaGFkb3dDU1MuanNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9tYXN0ZXIvcGFja2FnZXMvY29tcGlsZXIvc3JjL3NoYWRvd19jc3MudHNcbiAqL1xudmFyIHNhZmVTZWxlY3RvciA9IChzZWxlY3RvcikgPT4ge1xuICBjb25zdCBwbGFjZWhvbGRlcnMgPSBbXTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC8oXFxbW15cXF1dKlxcXSkvZywgKF8sIGtlZXApID0+IHtcbiAgICBjb25zdCByZXBsYWNlQnkgPSBgX19waC0ke2luZGV4fV9fYDtcbiAgICBwbGFjZWhvbGRlcnMucHVzaChrZWVwKTtcbiAgICBpbmRleCsrO1xuICAgIHJldHVybiByZXBsYWNlQnk7XG4gIH0pO1xuICBjb25zdCBjb250ZW50ID0gc2VsZWN0b3IucmVwbGFjZSgvKDpudGgtWy1cXHddKykoXFwoW14pXStcXCkpL2csIChfLCBwc2V1ZG8sIGV4cCkgPT4ge1xuICAgIGNvbnN0IHJlcGxhY2VCeSA9IGBfX3BoLSR7aW5kZXh9X19gO1xuICAgIHBsYWNlaG9sZGVycy5wdXNoKGV4cCk7XG4gICAgaW5kZXgrKztcbiAgICByZXR1cm4gcHNldWRvICsgcmVwbGFjZUJ5O1xuICB9KTtcbiAgY29uc3Qgc3MgPSB7XG4gICAgY29udGVudCxcbiAgICBwbGFjZWhvbGRlcnNcbiAgfTtcbiAgcmV0dXJuIHNzO1xufTtcbnZhciByZXN0b3JlU2FmZVNlbGVjdG9yID0gKHBsYWNlaG9sZGVycywgY29udGVudCkgPT4ge1xuICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9fX3BoLShcXGQrKV9fL2csIChfLCBpbmRleCkgPT4gcGxhY2Vob2xkZXJzWytpbmRleF0pO1xufTtcbnZhciBfcG9seWZpbGxIb3N0ID0gXCItc2hhZG93Y3NzaG9zdFwiO1xudmFyIF9wb2x5ZmlsbFNsb3R0ZWQgPSBcIi1zaGFkb3djc3NzbG90dGVkXCI7XG52YXIgX3BvbHlmaWxsSG9zdENvbnRleHQgPSBcIi1zaGFkb3djc3Njb250ZXh0XCI7XG52YXIgX3BhcmVuU3VmZml4ID0gXCIpKD86XFxcXCgoKD86XFxcXChbXikoXSpcXFxcKXxbXikoXSopKz8pXFxcXCkpPyhbXix7XSopXCI7XG52YXIgX2Nzc0NvbG9uSG9zdFJlID0gbmV3IFJlZ0V4cChcIihcIiArIF9wb2x5ZmlsbEhvc3QgKyBfcGFyZW5TdWZmaXgsIFwiZ2ltXCIpO1xudmFyIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUgPSBuZXcgUmVnRXhwKFwiKFwiICsgX3BvbHlmaWxsSG9zdENvbnRleHQgKyBfcGFyZW5TdWZmaXgsIFwiZ2ltXCIpO1xudmFyIF9jc3NDb2xvblNsb3R0ZWRSZSA9IG5ldyBSZWdFeHAoXCIoXCIgKyBfcG9seWZpbGxTbG90dGVkICsgX3BhcmVuU3VmZml4LCBcImdpbVwiKTtcbnZhciBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yID0gX3BvbHlmaWxsSG9zdCArIFwiLW5vLWNvbWJpbmF0b3JcIjtcbnZhciBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUgPSAvLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcihbXlxcc10qKS87XG52YXIgX3NoYWRvd0RPTVNlbGVjdG9yc1JlID0gWy86OnNoYWRvdy9nLCAvOjpjb250ZW50L2ddO1xudmFyIF9zZWxlY3RvclJlU3VmZml4ID0gXCIoWz5cXFxcc34rWy4sezpdW1xcXFxzXFxcXFNdKik/JFwiO1xudmFyIF9wb2x5ZmlsbEhvc3RSZSA9IC8tc2hhZG93Y3NzaG9zdC9naW07XG52YXIgY3JlYXRlU3VwcG9ydHNSdWxlUmUgPSAoc2VsZWN0b3IpID0+IG5ldyBSZWdFeHAoYCgoPzwhKF5Ac3VwcG9ydHMoLiopKSl8KD88PXsuKikpKCR7c2VsZWN0b3J9XFxcXGIpYCwgXCJnaW1cIik7XG52YXIgX2NvbG9uU2xvdHRlZFJlID0gY3JlYXRlU3VwcG9ydHNSdWxlUmUoXCI6OnNsb3R0ZWRcIik7XG52YXIgX2NvbG9uSG9zdFJlID0gY3JlYXRlU3VwcG9ydHNSdWxlUmUoXCI6aG9zdFwiKTtcbnZhciBfY29sb25Ib3N0Q29udGV4dFJlID0gY3JlYXRlU3VwcG9ydHNSdWxlUmUoXCI6aG9zdC1jb250ZXh0XCIpO1xudmFyIF9jb21tZW50UmUgPSAvXFwvXFwqXFxzKltcXHNcXFNdKj9cXCpcXC8vZztcbnZhciBzdHJpcENvbW1lbnRzID0gKGlucHV0KSA9PiB7XG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKF9jb21tZW50UmUsIFwiXCIpO1xufTtcbnZhciBfY29tbWVudFdpdGhIYXNoUmUgPSAvXFwvXFwqXFxzKiNcXHMqc291cmNlKE1hcHBpbmcpP1VSTD1bXFxzXFxTXSs/XFwqXFwvL2c7XG52YXIgZXh0cmFjdENvbW1lbnRzV2l0aEhhc2ggPSAoaW5wdXQpID0+IHtcbiAgcmV0dXJuIGlucHV0Lm1hdGNoKF9jb21tZW50V2l0aEhhc2hSZSkgfHwgW107XG59O1xudmFyIF9ydWxlUmUgPSAvKFxccyopKFteO1xce1xcfV0rPykoXFxzKikoKD86eyVCTE9DSyV9P1xccyo7Pyl8KD86XFxzKjspKS9nO1xudmFyIF9jdXJseVJlID0gLyhbe31dKS9nO1xudmFyIF9zZWxlY3RvclBhcnRzUmUgPSAvKF4uKj9bXlxcXFxdKT8/KCg6KykoLiopfCQpLztcbnZhciBPUEVOX0NVUkxZID0gXCJ7XCI7XG52YXIgQ0xPU0VfQ1VSTFkgPSBcIn1cIjtcbnZhciBCTE9DS19QTEFDRUhPTERFUiA9IFwiJUJMT0NLJVwiO1xudmFyIHByb2Nlc3NSdWxlcyA9IChpbnB1dCwgcnVsZUNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGlucHV0V2l0aEVzY2FwZWRCbG9ja3MgPSBlc2NhcGVCbG9ja3MoaW5wdXQpO1xuICBsZXQgbmV4dEJsb2NrSW5kZXggPSAwO1xuICByZXR1cm4gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5lc2NhcGVkU3RyaW5nLnJlcGxhY2UoX3J1bGVSZSwgKC4uLm0pID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IG1bMl07XG4gICAgbGV0IGNvbnRlbnQgPSBcIlwiO1xuICAgIGxldCBzdWZmaXggPSBtWzRdO1xuICAgIGxldCBjb250ZW50UHJlZml4ID0gXCJcIjtcbiAgICBpZiAoc3VmZml4ICYmIHN1ZmZpeC5zdGFydHNXaXRoKFwie1wiICsgQkxPQ0tfUExBQ0VIT0xERVIpKSB7XG4gICAgICBjb250ZW50ID0gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5ibG9ja3NbbmV4dEJsb2NrSW5kZXgrK107XG4gICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKEJMT0NLX1BMQUNFSE9MREVSLmxlbmd0aCArIDEpO1xuICAgICAgY29udGVudFByZWZpeCA9IFwie1wiO1xuICAgIH1cbiAgICBjb25zdCBjc3NSdWxlID0ge1xuICAgICAgc2VsZWN0b3IsXG4gICAgICBjb250ZW50XG4gICAgfTtcbiAgICBjb25zdCBydWxlID0gcnVsZUNhbGxiYWNrKGNzc1J1bGUpO1xuICAgIHJldHVybiBgJHttWzFdfSR7cnVsZS5zZWxlY3Rvcn0ke21bM119JHtjb250ZW50UHJlZml4fSR7cnVsZS5jb250ZW50fSR7c3VmZml4fWA7XG4gIH0pO1xufTtcbnZhciBlc2NhcGVCbG9ja3MgPSAoaW5wdXQpID0+IHtcbiAgY29uc3QgaW5wdXRQYXJ0cyA9IGlucHV0LnNwbGl0KF9jdXJseVJlKTtcbiAgY29uc3QgcmVzdWx0UGFydHMgPSBbXTtcbiAgY29uc3QgZXNjYXBlZEJsb2NrcyA9IFtdO1xuICBsZXQgYnJhY2tldENvdW50ID0gMDtcbiAgbGV0IGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gIGZvciAobGV0IHBhcnRJbmRleCA9IDA7IHBhcnRJbmRleCA8IGlucHV0UGFydHMubGVuZ3RoOyBwYXJ0SW5kZXgrKykge1xuICAgIGNvbnN0IHBhcnQgPSBpbnB1dFBhcnRzW3BhcnRJbmRleF07XG4gICAgaWYgKHBhcnQgPT09IENMT1NFX0NVUkxZKSB7XG4gICAgICBicmFja2V0Q291bnQtLTtcbiAgICB9XG4gICAgaWYgKGJyYWNrZXRDb3VudCA+IDApIHtcbiAgICAgIGN1cnJlbnRCbG9ja1BhcnRzLnB1c2gocGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVzY2FwZWRCbG9ja3MucHVzaChjdXJyZW50QmxvY2tQYXJ0cy5qb2luKFwiXCIpKTtcbiAgICAgICAgcmVzdWx0UGFydHMucHVzaChCTE9DS19QTEFDRUhPTERFUik7XG4gICAgICAgIGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gICAgICB9XG4gICAgICByZXN1bHRQYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICBpZiAocGFydCA9PT0gT1BFTl9DVVJMWSkge1xuICAgICAgYnJhY2tldENvdW50Kys7XG4gICAgfVxuICB9XG4gIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9ja1BhcnRzLmpvaW4oXCJcIikpO1xuICAgIHJlc3VsdFBhcnRzLnB1c2goQkxPQ0tfUExBQ0VIT0xERVIpO1xuICB9XG4gIGNvbnN0IHN0ckVzY2FwZWRCbG9ja3MgPSB7XG4gICAgZXNjYXBlZFN0cmluZzogcmVzdWx0UGFydHMuam9pbihcIlwiKSxcbiAgICBibG9ja3M6IGVzY2FwZWRCbG9ja3NcbiAgfTtcbiAgcmV0dXJuIHN0ckVzY2FwZWRCbG9ja3M7XG59O1xudmFyIGluc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dCA9IChjc3NUZXh0KSA9PiB7XG4gIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoX2NvbG9uSG9zdENvbnRleHRSZSwgYCQxJHtfcG9seWZpbGxIb3N0Q29udGV4dH1gKS5yZXBsYWNlKF9jb2xvbkhvc3RSZSwgYCQxJHtfcG9seWZpbGxIb3N0fWApLnJlcGxhY2UoX2NvbG9uU2xvdHRlZFJlLCBgJDEke19wb2x5ZmlsbFNsb3R0ZWR9YCk7XG4gIHJldHVybiBjc3NUZXh0O1xufTtcbnZhciBjb252ZXJ0Q29sb25SdWxlID0gKGNzc1RleHQsIHJlZ0V4cCwgcGFydFJlcGxhY2VyKSA9PiB7XG4gIHJldHVybiBjc3NUZXh0LnJlcGxhY2UocmVnRXhwLCAoLi4ubSkgPT4ge1xuICAgIGlmIChtWzJdKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IG1bMl0uc3BsaXQoXCIsXCIpO1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwID0gcGFydHNbaV0udHJpbSgpO1xuICAgICAgICBpZiAoIXApIGJyZWFrO1xuICAgICAgICByLnB1c2gocGFydFJlcGxhY2VyKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IsIHAsIG1bM10pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByLmpvaW4oXCIsXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIG1bM107XG4gICAgfVxuICB9KTtcbn07XG52YXIgY29sb25Ib3N0UGFydFJlcGxhY2VyID0gKGhvc3QsIHBhcnQsIHN1ZmZpeCkgPT4ge1xuICByZXR1cm4gaG9zdCArIHBhcnQucmVwbGFjZShfcG9seWZpbGxIb3N0LCBcIlwiKSArIHN1ZmZpeDtcbn07XG52YXIgY29udmVydENvbG9uSG9zdCA9IChjc3NUZXh0KSA9PiB7XG4gIHJldHVybiBjb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RSZSwgY29sb25Ib3N0UGFydFJlcGxhY2VyKTtcbn07XG52YXIgY29sb25Ib3N0Q29udGV4dFBhcnRSZXBsYWNlciA9IChob3N0LCBwYXJ0LCBzdWZmaXgpID0+IHtcbiAgaWYgKHBhcnQuaW5kZXhPZihfcG9seWZpbGxIb3N0KSA+IC0xKSB7XG4gICAgcmV0dXJuIGNvbG9uSG9zdFBhcnRSZXBsYWNlcihob3N0LCBwYXJ0LCBzdWZmaXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBob3N0ICsgcGFydCArIHN1ZmZpeCArIFwiLCBcIiArIHBhcnQgKyBcIiBcIiArIGhvc3QgKyBzdWZmaXg7XG4gIH1cbn07XG52YXIgY29udmVydENvbG9uU2xvdHRlZCA9IChjc3NUZXh0LCBzbG90U2NvcGVJZCkgPT4ge1xuICBjb25zdCBzbG90Q2xhc3MgPSBcIi5cIiArIHNsb3RTY29wZUlkICsgXCIgPiBcIjtcbiAgY29uc3Qgc2VsZWN0b3JzID0gW107XG4gIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbG9uU2xvdHRlZFJlLCAoLi4ubSkgPT4ge1xuICAgIGlmIChtWzJdKSB7XG4gICAgICBjb25zdCBjb21wb3VuZCA9IG1bMl0udHJpbSgpO1xuICAgICAgY29uc3Qgc3VmZml4ID0gbVszXTtcbiAgICAgIGNvbnN0IHNsb3R0ZWRTZWxlY3RvciA9IHNsb3RDbGFzcyArIGNvbXBvdW5kICsgc3VmZml4O1xuICAgICAgbGV0IHByZWZpeFNlbGVjdG9yID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGkgPSBtWzRdIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hhciA9IG1bNV1baV07XG4gICAgICAgIGlmIChjaGFyID09PSBcIn1cIiB8fCBjaGFyID09PSBcIixcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHByZWZpeFNlbGVjdG9yID0gY2hhciArIHByZWZpeFNlbGVjdG9yO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3JnU2VsZWN0b3IgPSAocHJlZml4U2VsZWN0b3IgKyBzbG90dGVkU2VsZWN0b3IpLnRyaW0oKTtcbiAgICAgIGNvbnN0IGFkZGVkU2VsZWN0b3IgPSBgJHtwcmVmaXhTZWxlY3Rvci50cmltRW5kKCl9JHtzbG90dGVkU2VsZWN0b3IudHJpbSgpfWAudHJpbSgpO1xuICAgICAgaWYgKG9yZ1NlbGVjdG9yICE9PSBhZGRlZFNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRTZWxlY3RvciA9IGAke2FkZGVkU2VsZWN0b3J9LCAke29yZ1NlbGVjdG9yfWA7XG4gICAgICAgIHNlbGVjdG9ycy5wdXNoKHtcbiAgICAgICAgICBvcmdTZWxlY3RvcixcbiAgICAgICAgICB1cGRhdGVkU2VsZWN0b3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xvdHRlZFNlbGVjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIG1bM107XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RvcnMsXG4gICAgY3NzVGV4dFxuICB9O1xufTtcbnZhciBjb252ZXJ0Q29sb25Ib3N0Q29udGV4dCA9IChjc3NUZXh0KSA9PiB7XG4gIHJldHVybiBjb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUsIGNvbG9uSG9zdENvbnRleHRQYXJ0UmVwbGFjZXIpO1xufTtcbnZhciBjb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzID0gKGNzc1RleHQpID0+IHtcbiAgcmV0dXJuIF9zaGFkb3dET01TZWxlY3RvcnNSZS5yZWR1Y2UoKHJlc3VsdCwgcGF0dGVybikgPT4gcmVzdWx0LnJlcGxhY2UocGF0dGVybiwgXCIgXCIpLCBjc3NUZXh0KTtcbn07XG52YXIgbWFrZVNjb3BlTWF0Y2hlciA9IChzY29wZVNlbGVjdG9yMikgPT4ge1xuICBjb25zdCBscmUgPSAvXFxbL2c7XG4gIGNvbnN0IHJyZSA9IC9cXF0vZztcbiAgc2NvcGVTZWxlY3RvcjIgPSBzY29wZVNlbGVjdG9yMi5yZXBsYWNlKGxyZSwgXCJcXFxcW1wiKS5yZXBsYWNlKHJyZSwgXCJcXFxcXVwiKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKFwiICsgc2NvcGVTZWxlY3RvcjIgKyBcIilcIiArIF9zZWxlY3RvclJlU3VmZml4LCBcIm1cIik7XG59O1xudmFyIHNlbGVjdG9yTmVlZHNTY29waW5nID0gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yMikgPT4ge1xuICBjb25zdCByZSA9IG1ha2VTY29wZU1hdGNoZXIoc2NvcGVTZWxlY3RvcjIpO1xuICByZXR1cm4gIXJlLnRlc3Qoc2VsZWN0b3IpO1xufTtcbnZhciBpbmplY3RTY29waW5nU2VsZWN0b3IgPSAoc2VsZWN0b3IsIHNjb3BpbmdTZWxlY3RvcikgPT4ge1xuICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShfc2VsZWN0b3JQYXJ0c1JlLCAoXywgYmVmb3JlID0gXCJcIiwgX2NvbG9uR3JvdXAsIGNvbG9uID0gXCJcIiwgYWZ0ZXIgPSBcIlwiKSA9PiB7XG4gICAgcmV0dXJuIGJlZm9yZSArIHNjb3BpbmdTZWxlY3RvciArIGNvbG9uICsgYWZ0ZXI7XG4gIH0pO1xufTtcbnZhciBhcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUgPSAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IyLCBob3N0U2VsZWN0b3IpID0+IHtcbiAgX3BvbHlmaWxsSG9zdFJlLmxhc3RJbmRleCA9IDA7XG4gIGlmIChfcG9seWZpbGxIb3N0UmUudGVzdChzZWxlY3RvcikpIHtcbiAgICBjb25zdCByZXBsYWNlQnkgPSBgLiR7aG9zdFNlbGVjdG9yfWA7XG4gICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlLCAoXywgc2VsZWN0b3IyKSA9PiBpbmplY3RTY29waW5nU2VsZWN0b3Ioc2VsZWN0b3IyLCByZXBsYWNlQnkpKS5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgcmVwbGFjZUJ5ICsgXCIgXCIpO1xuICB9XG4gIHJldHVybiBzY29wZVNlbGVjdG9yMiArIFwiIFwiICsgc2VsZWN0b3I7XG59O1xudmFyIGFwcGx5U3RyaWN0U2VsZWN0b3JTY29wZSA9IChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvcjIsIGhvc3RTZWxlY3RvcikgPT4ge1xuICBjb25zdCBpc1JlID0gL1xcW2lzPShbXlxcXV0qKVxcXS9nO1xuICBzY29wZVNlbGVjdG9yMiA9IHNjb3BlU2VsZWN0b3IyLnJlcGxhY2UoaXNSZSwgKF8sIC4uLnBhcnRzKSA9PiBwYXJ0c1swXSk7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IFwiLlwiICsgc2NvcGVTZWxlY3RvcjI7XG4gIGNvbnN0IF9zY29wZVNlbGVjdG9yUGFydCA9IChwKSA9PiB7XG4gICAgbGV0IHNjb3BlZFAgPSBwLnRyaW0oKTtcbiAgICBpZiAoIXNjb3BlZFApIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBpZiAocC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTEpIHtcbiAgICAgIHNjb3BlZFAgPSBhcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUocCwgc2NvcGVTZWxlY3RvcjIsIGhvc3RTZWxlY3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSBwLnJlcGxhY2UoX3BvbHlmaWxsSG9zdFJlLCBcIlwiKTtcbiAgICAgIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2NvcGVkUCA9IGluamVjdFNjb3BpbmdTZWxlY3Rvcih0LCBjbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkUDtcbiAgfTtcbiAgY29uc3Qgc2FmZUNvbnRlbnQgPSBzYWZlU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICBzZWxlY3RvciA9IHNhZmVDb250ZW50LmNvbnRlbnQ7XG4gIGxldCBzY29wZWRTZWxlY3RvciA9IFwiXCI7XG4gIGxldCBzdGFydEluZGV4ID0gMDtcbiAgbGV0IHJlcztcbiAgY29uc3Qgc2VwID0gLyggfD58XFwrfH4oPyE9KSlcXHMqL2c7XG4gIGNvbnN0IGhhc0hvc3QgPSBzZWxlY3Rvci5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gIGxldCBzaG91bGRTY29wZSA9ICFoYXNIb3N0O1xuICB3aGlsZSAoKHJlcyA9IHNlcC5leGVjKHNlbGVjdG9yKSkgIT09IG51bGwpIHtcbiAgICBjb25zdCBzZXBhcmF0b3IgPSByZXNbMV07XG4gICAgY29uc3QgcGFydDIgPSBzZWxlY3Rvci5zbGljZShzdGFydEluZGV4LCByZXMuaW5kZXgpLnRyaW0oKTtcbiAgICBzaG91bGRTY29wZSA9IHNob3VsZFNjb3BlIHx8IHBhcnQyLmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMTtcbiAgICBjb25zdCBzY29wZWRQYXJ0ID0gc2hvdWxkU2NvcGUgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydDIpIDogcGFydDI7XG4gICAgc2NvcGVkU2VsZWN0b3IgKz0gYCR7c2NvcGVkUGFydH0gJHtzZXBhcmF0b3J9IGA7XG4gICAgc3RhcnRJbmRleCA9IHNlcC5sYXN0SW5kZXg7XG4gIH1cbiAgY29uc3QgcGFydCA9IHNlbGVjdG9yLnN1YnN0cmluZyhzdGFydEluZGV4KTtcbiAgc2hvdWxkU2NvcGUgPSBzaG91bGRTY29wZSB8fCBwYXJ0LmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMTtcbiAgc2NvcGVkU2VsZWN0b3IgKz0gc2hvdWxkU2NvcGUgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydCkgOiBwYXJ0O1xuICByZXR1cm4gcmVzdG9yZVNhZmVTZWxlY3RvcihzYWZlQ29udGVudC5wbGFjZWhvbGRlcnMsIHNjb3BlZFNlbGVjdG9yKTtcbn07XG52YXIgc2NvcGVTZWxlY3RvciA9IChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvclRleHQsIGhvc3RTZWxlY3Rvciwgc2xvdFNlbGVjdG9yKSA9PiB7XG4gIHJldHVybiBzZWxlY3Rvci5zcGxpdChcIixcIikubWFwKChzaGFsbG93UGFydCkgPT4ge1xuICAgIGlmIChzbG90U2VsZWN0b3IgJiYgc2hhbGxvd1BhcnQuaW5kZXhPZihcIi5cIiArIHNsb3RTZWxlY3RvcikgPiAtMSkge1xuICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0LnRyaW0oKTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdG9yTmVlZHNTY29waW5nKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yVGV4dCkpIHtcbiAgICAgIHJldHVybiBhcHBseVN0cmljdFNlbGVjdG9yU2NvcGUoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3JUZXh0LCBob3N0U2VsZWN0b3IpLnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0LnRyaW0oKTtcbiAgICB9XG4gIH0pLmpvaW4oXCIsIFwiKTtcbn07XG52YXIgc2NvcGVTZWxlY3RvcnMgPSAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvclRleHQsIGhvc3RTZWxlY3Rvciwgc2xvdFNlbGVjdG9yLCBjb21tZW50T3JpZ2luYWxTZWxlY3RvcikgPT4ge1xuICByZXR1cm4gcHJvY2Vzc1J1bGVzKGNzc1RleHQsIChydWxlKSA9PiB7XG4gICAgbGV0IHNlbGVjdG9yID0gcnVsZS5zZWxlY3RvcjtcbiAgICBsZXQgY29udGVudCA9IHJ1bGUuY29udGVudDtcbiAgICBpZiAocnVsZS5zZWxlY3RvclswXSAhPT0gXCJAXCIpIHtcbiAgICAgIHNlbGVjdG9yID0gc2NvcGVTZWxlY3RvcihydWxlLnNlbGVjdG9yLCBzY29wZVNlbGVjdG9yVGV4dCwgaG9zdFNlbGVjdG9yLCBzbG90U2VsZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAocnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKFwiQG1lZGlhXCIpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aChcIkBzdXBwb3J0c1wiKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoXCJAcGFnZVwiKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoXCJAZG9jdW1lbnRcIikpIHtcbiAgICAgIGNvbnRlbnQgPSBzY29wZVNlbGVjdG9ycyhydWxlLmNvbnRlbnQsIHNjb3BlU2VsZWN0b3JUZXh0LCBob3N0U2VsZWN0b3IsIHNsb3RTZWxlY3RvciwgY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpO1xuICAgIH1cbiAgICBjb25zdCBjc3NSdWxlID0ge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLnJlcGxhY2UoL1xcc3syLH0vZywgXCIgXCIpLnRyaW0oKSxcbiAgICAgIGNvbnRlbnRcbiAgICB9O1xuICAgIHJldHVybiBjc3NSdWxlO1xuICB9KTtcbn07XG52YXIgc2NvcGVDc3NUZXh0ID0gKGNzc1RleHQsIHNjb3BlSWQsIGhvc3RTY29wZUlkLCBzbG90U2NvcGVJZCwgY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpID0+IHtcbiAgY3NzVGV4dCA9IGluc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dChjc3NUZXh0KTtcbiAgY3NzVGV4dCA9IGNvbnZlcnRDb2xvbkhvc3QoY3NzVGV4dCk7XG4gIGNzc1RleHQgPSBjb252ZXJ0Q29sb25Ib3N0Q29udGV4dChjc3NUZXh0KTtcbiAgY29uc3Qgc2xvdHRlZCA9IGNvbnZlcnRDb2xvblNsb3R0ZWQoY3NzVGV4dCwgc2xvdFNjb3BlSWQpO1xuICBjc3NUZXh0ID0gc2xvdHRlZC5jc3NUZXh0O1xuICBjc3NUZXh0ID0gY29udmVydFNoYWRvd0RPTVNlbGVjdG9ycyhjc3NUZXh0KTtcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBjc3NUZXh0ID0gc2NvcGVTZWxlY3RvcnMoY3NzVGV4dCwgc2NvcGVJZCwgaG9zdFNjb3BlSWQsIHNsb3RTY29wZUlkLCBjb21tZW50T3JpZ2luYWxTZWxlY3Rvcik7XG4gIH1cbiAgY3NzVGV4dCA9IHJlcGxhY2VTaGFkb3dDc3NIb3N0KGNzc1RleHQsIGhvc3RTY29wZUlkKTtcbiAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZSgvPlxccypcXCpcXHMrKFteeywgXSspL2dtLCBcIiAkMSBcIik7XG4gIHJldHVybiB7XG4gICAgY3NzVGV4dDogY3NzVGV4dC50cmltKCksXG4gICAgLy8gV2UgbmVlZCB0byByZXBsYWNlIHRoZSBzaGFkb3cgQ1NTIGhvc3Qgc3RyaW5nIGluIGVhY2ggb2YgdGhlc2Ugc2VsZWN0b3JzIHNpbmNlIHdlIGNyZWF0ZWRcbiAgICAvLyB0aGVtIHByaW9yIHRvIHRoZSByZXBsYWNlbWVudCBoYXBwZW5pbmcgaW4gdGhlIGNvbXBvbmVudHMgQ1NTIHRleHQuXG4gICAgc2xvdHRlZFNlbGVjdG9yczogc2xvdHRlZC5zZWxlY3RvcnMubWFwKChyZWYpID0+ICh7XG4gICAgICBvcmdTZWxlY3RvcjogcmVwbGFjZVNoYWRvd0Nzc0hvc3QocmVmLm9yZ1NlbGVjdG9yLCBob3N0U2NvcGVJZCksXG4gICAgICB1cGRhdGVkU2VsZWN0b3I6IHJlcGxhY2VTaGFkb3dDc3NIb3N0KHJlZi51cGRhdGVkU2VsZWN0b3IsIGhvc3RTY29wZUlkKVxuICAgIH0pKVxuICB9O1xufTtcbnZhciByZXBsYWNlU2hhZG93Q3NzSG9zdCA9IChjc3NUZXh0LCBob3N0U2NvcGVJZCkgPT4ge1xuICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKC8tc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yL2csIGAuJHtob3N0U2NvcGVJZH1gKTtcbn07XG52YXIgc2NvcGVDc3MgPSAoY3NzVGV4dCwgc2NvcGVJZCwgY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpID0+IHtcbiAgY29uc3QgaG9zdFNjb3BlSWQgPSBzY29wZUlkICsgXCItaFwiO1xuICBjb25zdCBzbG90U2NvcGVJZCA9IHNjb3BlSWQgKyBcIi1zXCI7XG4gIGNvbnN0IGNvbW1lbnRzV2l0aEhhc2ggPSBleHRyYWN0Q29tbWVudHNXaXRoSGFzaChjc3NUZXh0KTtcbiAgY3NzVGV4dCA9IHN0cmlwQ29tbWVudHMoY3NzVGV4dCk7XG4gIGNvbnN0IG9yZ1NlbGVjdG9ycyA9IFtdO1xuICBpZiAoY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpIHtcbiAgICBjb25zdCBwcm9jZXNzQ29tbWVudGVkU2VsZWN0b3IgPSAocnVsZSkgPT4ge1xuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBgLyohQF9fXyR7b3JnU2VsZWN0b3JzLmxlbmd0aH1fX18qL2A7XG4gICAgICBjb25zdCBjb21tZW50ID0gYC8qIUAke3J1bGUuc2VsZWN0b3J9Ki9gO1xuICAgICAgb3JnU2VsZWN0b3JzLnB1c2goeyBwbGFjZWhvbGRlciwgY29tbWVudCB9KTtcbiAgICAgIHJ1bGUuc2VsZWN0b3IgPSBwbGFjZWhvbGRlciArIHJ1bGUuc2VsZWN0b3I7XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9O1xuICAgIGNzc1RleHQgPSBwcm9jZXNzUnVsZXMoY3NzVGV4dCwgKHJ1bGUpID0+IHtcbiAgICAgIGlmIChydWxlLnNlbGVjdG9yWzBdICE9PSBcIkBcIikge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc0NvbW1lbnRlZFNlbGVjdG9yKHJ1bGUpO1xuICAgICAgfSBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoXCJAbWVkaWFcIikgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKFwiQHN1cHBvcnRzXCIpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aChcIkBwYWdlXCIpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aChcIkBkb2N1bWVudFwiKSkge1xuICAgICAgICBydWxlLmNvbnRlbnQgPSBwcm9jZXNzUnVsZXMocnVsZS5jb250ZW50LCBwcm9jZXNzQ29tbWVudGVkU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHNjb3BlZCA9IHNjb3BlQ3NzVGV4dChjc3NUZXh0LCBzY29wZUlkLCBob3N0U2NvcGVJZCwgc2xvdFNjb3BlSWQsIGNvbW1lbnRPcmlnaW5hbFNlbGVjdG9yKTtcbiAgY3NzVGV4dCA9IFtzY29wZWQuY3NzVGV4dCwgLi4uY29tbWVudHNXaXRoSGFzaF0uam9pbihcIlxcblwiKTtcbiAgaWYgKGNvbW1lbnRPcmlnaW5hbFNlbGVjdG9yKSB7XG4gICAgb3JnU2VsZWN0b3JzLmZvckVhY2goKHsgcGxhY2Vob2xkZXIsIGNvbW1lbnQgfSkgPT4ge1xuICAgICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShwbGFjZWhvbGRlciwgY29tbWVudCk7XG4gICAgfSk7XG4gIH1cbiAgc2NvcGVkLnNsb3R0ZWRTZWxlY3RvcnMuZm9yRWFjaCgoc2xvdHRlZFNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cFNwZWNpYWxDaGFyYWN0ZXJzKHNsb3R0ZWRTZWxlY3Rvci5vcmdTZWxlY3RvciksIFwiZ1wiKTtcbiAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKHJlZ2V4LCBzbG90dGVkU2VsZWN0b3IudXBkYXRlZFNlbGVjdG9yKTtcbiAgfSk7XG4gIHJldHVybiBjc3NUZXh0O1xufTtcbmV4cG9ydCB7XG4gIHNjb3BlQ3NzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stencil/core/internal/client/shadow-css.js\n");

/***/ })

};
;