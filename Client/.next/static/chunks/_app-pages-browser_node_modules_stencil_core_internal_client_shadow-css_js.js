"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_stencil_core_internal_client_shadow-css_js"],{

/***/ "(app-pages-browser)/./node_modules/@stencil/core/internal/client/shadow-css.js":
/*!******************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/client/shadow-css.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scopeCss: function() { return /* binding */ scopeCss; }\n/* harmony export */ });\n// src/utils/regular-expression.ts\nvar escapeRegExpSpecialCharacters = (text) => {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n};\n\n// src/utils/shadow-css.ts\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n *\n * This file is a port of shadowCSS from `webcomponents.js` to TypeScript.\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts\n */\nvar safeSelector = (selector) => {\n  const placeholders = [];\n  let index = 0;\n  selector = selector.replace(/(\\[[^\\]]*\\])/g, (_, keep) => {\n    const replaceBy = `__ph-${index}__`;\n    placeholders.push(keep);\n    index++;\n    return replaceBy;\n  });\n  const content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n    const replaceBy = `__ph-${index}__`;\n    placeholders.push(exp);\n    index++;\n    return pseudo + replaceBy;\n  });\n  const ss = {\n    content,\n    placeholders\n  };\n  return ss;\n};\nvar restoreSafeSelector = (placeholders, content) => {\n  return content.replace(/__ph-(\\d+)__/g, (_, index) => placeholders[+index]);\n};\nvar _polyfillHost = \"-shadowcsshost\";\nvar _polyfillSlotted = \"-shadowcssslotted\";\nvar _polyfillHostContext = \"-shadowcsscontext\";\nvar _parenSuffix = \")(?:\\\\(((?:\\\\([^)(]*\\\\)|[^)(]*)+?)\\\\))?([^,{]*)\";\nvar _cssColonHostRe = new RegExp(\"(\" + _polyfillHost + _parenSuffix, \"gim\");\nvar _cssColonHostContextRe = new RegExp(\"(\" + _polyfillHostContext + _parenSuffix, \"gim\");\nvar _cssColonSlottedRe = new RegExp(\"(\" + _polyfillSlotted + _parenSuffix, \"gim\");\nvar _polyfillHostNoCombinator = _polyfillHost + \"-no-combinator\";\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [/::shadow/g, /::content/g];\nvar _selectorReSuffix = \"([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$\";\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar createSupportsRuleRe = (selector) => new RegExp(`((?<!(^@supports(.*)))|(?<={.*))(${selector}\\\\b)`, \"gim\");\nvar _colonSlottedRe = createSupportsRuleRe(\"::slotted\");\nvar _colonHostRe = createSupportsRuleRe(\":host\");\nvar _colonHostContextRe = createSupportsRuleRe(\":host-context\");\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\nvar stripComments = (input) => {\n  return input.replace(_commentRe, \"\");\n};\nvar _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\nvar extractCommentsWithHash = (input) => {\n  return input.match(_commentWithHashRe) || [];\n};\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _curlyRe = /([{}])/g;\nvar _selectorPartsRe = /(^.*?[^\\\\])??((:+)(.*)|$)/;\nvar OPEN_CURLY = \"{\";\nvar CLOSE_CURLY = \"}\";\nvar BLOCK_PLACEHOLDER = \"%BLOCK%\";\nvar processRules = (input, ruleCallback) => {\n  const inputWithEscapedBlocks = escapeBlocks(input);\n  let nextBlockIndex = 0;\n  return inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {\n    const selector = m[2];\n    let content = \"\";\n    let suffix = m[4];\n    let contentPrefix = \"\";\n    if (suffix && suffix.startsWith(\"{\" + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = \"{\";\n    }\n    const cssRule = {\n      selector,\n      content\n    };\n    const rule = ruleCallback(cssRule);\n    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n  });\n};\nvar escapeBlocks = (input) => {\n  const inputParts = input.split(_curlyRe);\n  const resultParts = [];\n  const escapedBlocks = [];\n  let bracketCount = 0;\n  let currentBlockParts = [];\n  for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {\n    const part = inputParts[partIndex];\n    if (part === CLOSE_CURLY) {\n      bracketCount--;\n    }\n    if (bracketCount > 0) {\n      currentBlockParts.push(part);\n    } else {\n      if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(\"\"));\n        resultParts.push(BLOCK_PLACEHOLDER);\n        currentBlockParts = [];\n      }\n      resultParts.push(part);\n    }\n    if (part === OPEN_CURLY) {\n      bracketCount++;\n    }\n  }\n  if (currentBlockParts.length > 0) {\n    escapedBlocks.push(currentBlockParts.join(\"\"));\n    resultParts.push(BLOCK_PLACEHOLDER);\n  }\n  const strEscapedBlocks = {\n    escapedString: resultParts.join(\"\"),\n    blocks: escapedBlocks\n  };\n  return strEscapedBlocks;\n};\nvar insertPolyfillHostInCssText = (cssText) => {\n  cssText = cssText.replace(_colonHostContextRe, `$1${_polyfillHostContext}`).replace(_colonHostRe, `$1${_polyfillHost}`).replace(_colonSlottedRe, `$1${_polyfillSlotted}`);\n  return cssText;\n};\nvar convertColonRule = (cssText, regExp, partReplacer) => {\n  return cssText.replace(regExp, (...m) => {\n    if (m[2]) {\n      const parts = m[2].split(\",\");\n      const r = [];\n      for (let i = 0; i < parts.length; i++) {\n        const p = parts[i].trim();\n        if (!p) break;\n        r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n      }\n      return r.join(\",\");\n    } else {\n      return _polyfillHostNoCombinator + m[3];\n    }\n  });\n};\nvar colonHostPartReplacer = (host, part, suffix) => {\n  return host + part.replace(_polyfillHost, \"\") + suffix;\n};\nvar convertColonHost = (cssText) => {\n  return convertColonRule(cssText, _cssColonHostRe, colonHostPartReplacer);\n};\nvar colonHostContextPartReplacer = (host, part, suffix) => {\n  if (part.indexOf(_polyfillHost) > -1) {\n    return colonHostPartReplacer(host, part, suffix);\n  } else {\n    return host + part + suffix + \", \" + part + \" \" + host + suffix;\n  }\n};\nvar convertColonSlotted = (cssText, slotScopeId) => {\n  const slotClass = \".\" + slotScopeId + \" > \";\n  const selectors = [];\n  cssText = cssText.replace(_cssColonSlottedRe, (...m) => {\n    if (m[2]) {\n      const compound = m[2].trim();\n      const suffix = m[3];\n      const slottedSelector = slotClass + compound + suffix;\n      let prefixSelector = \"\";\n      for (let i = m[4] - 1; i >= 0; i--) {\n        const char = m[5][i];\n        if (char === \"}\" || char === \",\") {\n          break;\n        }\n        prefixSelector = char + prefixSelector;\n      }\n      const orgSelector = (prefixSelector + slottedSelector).trim();\n      const addedSelector = `${prefixSelector.trimEnd()}${slottedSelector.trim()}`.trim();\n      if (orgSelector !== addedSelector) {\n        const updatedSelector = `${addedSelector}, ${orgSelector}`;\n        selectors.push({\n          orgSelector,\n          updatedSelector\n        });\n      }\n      return slottedSelector;\n    } else {\n      return _polyfillHostNoCombinator + m[3];\n    }\n  });\n  return {\n    selectors,\n    cssText\n  };\n};\nvar convertColonHostContext = (cssText) => {\n  return convertColonRule(cssText, _cssColonHostContextRe, colonHostContextPartReplacer);\n};\nvar convertShadowDOMSelectors = (cssText) => {\n  return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, \" \"), cssText);\n};\nvar makeScopeMatcher = (scopeSelector2) => {\n  const lre = /\\[/g;\n  const rre = /\\]/g;\n  scopeSelector2 = scopeSelector2.replace(lre, \"\\\\[\").replace(rre, \"\\\\]\");\n  return new RegExp(\"^(\" + scopeSelector2 + \")\" + _selectorReSuffix, \"m\");\n};\nvar selectorNeedsScoping = (selector, scopeSelector2) => {\n  const re = makeScopeMatcher(scopeSelector2);\n  return !re.test(selector);\n};\nvar injectScopingSelector = (selector, scopingSelector) => {\n  return selector.replace(_selectorPartsRe, (_, before = \"\", _colonGroup, colon = \"\", after = \"\") => {\n    return before + scopingSelector + colon + after;\n  });\n};\nvar applySimpleSelectorScope = (selector, scopeSelector2, hostSelector) => {\n  _polyfillHostRe.lastIndex = 0;\n  if (_polyfillHostRe.test(selector)) {\n    const replaceBy = `.${hostSelector}`;\n    return selector.replace(_polyfillHostNoCombinatorRe, (_, selector2) => injectScopingSelector(selector2, replaceBy)).replace(_polyfillHostRe, replaceBy + \" \");\n  }\n  return scopeSelector2 + \" \" + selector;\n};\nvar applyStrictSelectorScope = (selector, scopeSelector2, hostSelector) => {\n  const isRe = /\\[is=([^\\]]*)\\]/g;\n  scopeSelector2 = scopeSelector2.replace(isRe, (_, ...parts) => parts[0]);\n  const className = \".\" + scopeSelector2;\n  const _scopeSelectorPart = (p) => {\n    let scopedP = p.trim();\n    if (!scopedP) {\n      return \"\";\n    }\n    if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n      scopedP = applySimpleSelectorScope(p, scopeSelector2, hostSelector);\n    } else {\n      const t = p.replace(_polyfillHostRe, \"\");\n      if (t.length > 0) {\n        scopedP = injectScopingSelector(t, className);\n      }\n    }\n    return scopedP;\n  };\n  const safeContent = safeSelector(selector);\n  selector = safeContent.content;\n  let scopedSelector = \"\";\n  let startIndex = 0;\n  let res;\n  const sep = /( |>|\\+|~(?!=))\\s*/g;\n  const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n  let shouldScope = !hasHost;\n  while ((res = sep.exec(selector)) !== null) {\n    const separator = res[1];\n    const part2 = selector.slice(startIndex, res.index).trim();\n    shouldScope = shouldScope || part2.indexOf(_polyfillHostNoCombinator) > -1;\n    const scopedPart = shouldScope ? _scopeSelectorPart(part2) : part2;\n    scopedSelector += `${scopedPart} ${separator} `;\n    startIndex = sep.lastIndex;\n  }\n  const part = selector.substring(startIndex);\n  shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n  scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n  return restoreSafeSelector(safeContent.placeholders, scopedSelector);\n};\nvar scopeSelector = (selector, scopeSelectorText, hostSelector, slotSelector) => {\n  return selector.split(\",\").map((shallowPart) => {\n    if (slotSelector && shallowPart.indexOf(\".\" + slotSelector) > -1) {\n      return shallowPart.trim();\n    }\n    if (selectorNeedsScoping(shallowPart, scopeSelectorText)) {\n      return applyStrictSelectorScope(shallowPart, scopeSelectorText, hostSelector).trim();\n    } else {\n      return shallowPart.trim();\n    }\n  }).join(\", \");\n};\nvar scopeSelectors = (cssText, scopeSelectorText, hostSelector, slotSelector, commentOriginalSelector) => {\n  return processRules(cssText, (rule) => {\n    let selector = rule.selector;\n    let content = rule.content;\n    if (rule.selector[0] !== \"@\") {\n      selector = scopeSelector(rule.selector, scopeSelectorText, hostSelector, slotSelector);\n    } else if (rule.selector.startsWith(\"@media\") || rule.selector.startsWith(\"@supports\") || rule.selector.startsWith(\"@page\") || rule.selector.startsWith(\"@document\")) {\n      content = scopeSelectors(rule.content, scopeSelectorText, hostSelector, slotSelector, commentOriginalSelector);\n    }\n    const cssRule = {\n      selector: selector.replace(/\\s{2,}/g, \" \").trim(),\n      content\n    };\n    return cssRule;\n  });\n};\nvar scopeCssText = (cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector) => {\n  cssText = insertPolyfillHostInCssText(cssText);\n  cssText = convertColonHost(cssText);\n  cssText = convertColonHostContext(cssText);\n  const slotted = convertColonSlotted(cssText, slotScopeId);\n  cssText = slotted.cssText;\n  cssText = convertShadowDOMSelectors(cssText);\n  if (scopeId) {\n    cssText = scopeSelectors(cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector);\n  }\n  cssText = replaceShadowCssHost(cssText, hostScopeId);\n  cssText = cssText.replace(/>\\s*\\*\\s+([^{, ]+)/gm, \" $1 \");\n  return {\n    cssText: cssText.trim(),\n    // We need to replace the shadow CSS host string in each of these selectors since we created\n    // them prior to the replacement happening in the components CSS text.\n    slottedSelectors: slotted.selectors.map((ref) => ({\n      orgSelector: replaceShadowCssHost(ref.orgSelector, hostScopeId),\n      updatedSelector: replaceShadowCssHost(ref.updatedSelector, hostScopeId)\n    }))\n  };\n};\nvar replaceShadowCssHost = (cssText, hostScopeId) => {\n  return cssText.replace(/-shadowcsshost-no-combinator/g, `.${hostScopeId}`);\n};\nvar scopeCss = (cssText, scopeId, commentOriginalSelector) => {\n  const hostScopeId = scopeId + \"-h\";\n  const slotScopeId = scopeId + \"-s\";\n  const commentsWithHash = extractCommentsWithHash(cssText);\n  cssText = stripComments(cssText);\n  const orgSelectors = [];\n  if (commentOriginalSelector) {\n    const processCommentedSelector = (rule) => {\n      const placeholder = `/*!@___${orgSelectors.length}___*/`;\n      const comment = `/*!@${rule.selector}*/`;\n      orgSelectors.push({ placeholder, comment });\n      rule.selector = placeholder + rule.selector;\n      return rule;\n    };\n    cssText = processRules(cssText, (rule) => {\n      if (rule.selector[0] !== \"@\") {\n        return processCommentedSelector(rule);\n      } else if (rule.selector.startsWith(\"@media\") || rule.selector.startsWith(\"@supports\") || rule.selector.startsWith(\"@page\") || rule.selector.startsWith(\"@document\")) {\n        rule.content = processRules(rule.content, processCommentedSelector);\n        return rule;\n      }\n      return rule;\n    });\n  }\n  const scoped = scopeCssText(cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector);\n  cssText = [scoped.cssText, ...commentsWithHash].join(\"\\n\");\n  if (commentOriginalSelector) {\n    orgSelectors.forEach(({ placeholder, comment }) => {\n      cssText = cssText.replace(placeholder, comment);\n    });\n  }\n  scoped.slottedSelectors.forEach((slottedSelector) => {\n    const regex = new RegExp(escapeRegExpSpecialCharacters(slottedSelector.orgSelector), \"g\");\n    cssText = cssText.replace(regex, slottedSelector.updatedSelector);\n  });\n  return cssText;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9zaGFkb3ctY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxpRkFBaUYsT0FBTyxTQUFTO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxFQUFFLGNBQWMsUUFBUSxLQUFLLFVBQVU7QUFDakUsb0JBQW9CO0FBQ3BCO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUssRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUUsT0FBTztBQUNsRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQkFBcUIsOEJBQThCLGNBQWMsaUNBQWlDLGlCQUFpQjtBQUN6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCLEVBQUUsdUJBQXVCO0FBQ2pGO0FBQ0EsbUNBQW1DLGNBQWMsSUFBSSxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxFQUFFLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxHQUFHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RCw2QkFBNkIsY0FBYztBQUMzQywwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9zaGFkb3ctY3NzLmpzPzk0ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzL3JlZ3VsYXItZXhwcmVzc2lvbi50c1xudmFyIGVzY2FwZVJlZ0V4cFNwZWNpYWxDaGFyYWN0ZXJzID0gKHRleHQpID0+IHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufTtcblxuLy8gc3JjL3V0aWxzL3NoYWRvdy1jc3MudHNcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKlxuICogVGhpcyBmaWxlIGlzIGEgcG9ydCBvZiBzaGFkb3dDU1MgZnJvbSBgd2ViY29tcG9uZW50cy5qc2AgdG8gVHlwZVNjcmlwdC5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy9ibG9iLzRlZmVjZDdlMGUvc3JjL1NoYWRvd0NTUy9TaGFkb3dDU1MuanNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9tYXN0ZXIvcGFja2FnZXMvY29tcGlsZXIvc3JjL3NoYWRvd19jc3MudHNcbiAqL1xudmFyIHNhZmVTZWxlY3RvciA9IChzZWxlY3RvcikgPT4ge1xuICBjb25zdCBwbGFjZWhvbGRlcnMgPSBbXTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC8oXFxbW15cXF1dKlxcXSkvZywgKF8sIGtlZXApID0+IHtcbiAgICBjb25zdCByZXBsYWNlQnkgPSBgX19waC0ke2luZGV4fV9fYDtcbiAgICBwbGFjZWhvbGRlcnMucHVzaChrZWVwKTtcbiAgICBpbmRleCsrO1xuICAgIHJldHVybiByZXBsYWNlQnk7XG4gIH0pO1xuICBjb25zdCBjb250ZW50ID0gc2VsZWN0b3IucmVwbGFjZSgvKDpudGgtWy1cXHddKykoXFwoW14pXStcXCkpL2csIChfLCBwc2V1ZG8sIGV4cCkgPT4ge1xuICAgIGNvbnN0IHJlcGxhY2VCeSA9IGBfX3BoLSR7aW5kZXh9X19gO1xuICAgIHBsYWNlaG9sZGVycy5wdXNoKGV4cCk7XG4gICAgaW5kZXgrKztcbiAgICByZXR1cm4gcHNldWRvICsgcmVwbGFjZUJ5O1xuICB9KTtcbiAgY29uc3Qgc3MgPSB7XG4gICAgY29udGVudCxcbiAgICBwbGFjZWhvbGRlcnNcbiAgfTtcbiAgcmV0dXJuIHNzO1xufTtcbnZhciByZXN0b3JlU2FmZVNlbGVjdG9yID0gKHBsYWNlaG9sZGVycywgY29udGVudCkgPT4ge1xuICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9fX3BoLShcXGQrKV9fL2csIChfLCBpbmRleCkgPT4gcGxhY2Vob2xkZXJzWytpbmRleF0pO1xufTtcbnZhciBfcG9seWZpbGxIb3N0ID0gXCItc2hhZG93Y3NzaG9zdFwiO1xudmFyIF9wb2x5ZmlsbFNsb3R0ZWQgPSBcIi1zaGFkb3djc3NzbG90dGVkXCI7XG52YXIgX3BvbHlmaWxsSG9zdENvbnRleHQgPSBcIi1zaGFkb3djc3Njb250ZXh0XCI7XG52YXIgX3BhcmVuU3VmZml4ID0gXCIpKD86XFxcXCgoKD86XFxcXChbXikoXSpcXFxcKXxbXikoXSopKz8pXFxcXCkpPyhbXix7XSopXCI7XG52YXIgX2Nzc0NvbG9uSG9zdFJlID0gbmV3IFJlZ0V4cChcIihcIiArIF9wb2x5ZmlsbEhvc3QgKyBfcGFyZW5TdWZmaXgsIFwiZ2ltXCIpO1xudmFyIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUgPSBuZXcgUmVnRXhwKFwiKFwiICsgX3BvbHlmaWxsSG9zdENvbnRleHQgKyBfcGFyZW5TdWZmaXgsIFwiZ2ltXCIpO1xudmFyIF9jc3NDb2xvblNsb3R0ZWRSZSA9IG5ldyBSZWdFeHAoXCIoXCIgKyBfcG9seWZpbGxTbG90dGVkICsgX3BhcmVuU3VmZml4LCBcImdpbVwiKTtcbnZhciBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yID0gX3BvbHlmaWxsSG9zdCArIFwiLW5vLWNvbWJpbmF0b3JcIjtcbnZhciBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUgPSAvLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcihbXlxcc10qKS87XG52YXIgX3NoYWRvd0RPTVNlbGVjdG9yc1JlID0gWy86OnNoYWRvdy9nLCAvOjpjb250ZW50L2ddO1xudmFyIF9zZWxlY3RvclJlU3VmZml4ID0gXCIoWz5cXFxcc34rWy4sezpdW1xcXFxzXFxcXFNdKik/JFwiO1xudmFyIF9wb2x5ZmlsbEhvc3RSZSA9IC8tc2hhZG93Y3NzaG9zdC9naW07XG52YXIgY3JlYXRlU3VwcG9ydHNSdWxlUmUgPSAoc2VsZWN0b3IpID0+IG5ldyBSZWdFeHAoYCgoPzwhKF5Ac3VwcG9ydHMoLiopKSl8KD88PXsuKikpKCR7c2VsZWN0b3J9XFxcXGIpYCwgXCJnaW1cIik7XG52YXIgX2NvbG9uU2xvdHRlZFJlID0gY3JlYXRlU3VwcG9ydHNSdWxlUmUoXCI6OnNsb3R0ZWRcIik7XG52YXIgX2NvbG9uSG9zdFJlID0gY3JlYXRlU3VwcG9ydHNSdWxlUmUoXCI6aG9zdFwiKTtcbnZhciBfY29sb25Ib3N0Q29udGV4dFJlID0gY3JlYXRlU3VwcG9ydHNSdWxlUmUoXCI6aG9zdC1jb250ZXh0XCIpO1xudmFyIF9jb21tZW50UmUgPSAvXFwvXFwqXFxzKltcXHNcXFNdKj9cXCpcXC8vZztcbnZhciBzdHJpcENvbW1lbnRzID0gKGlucHV0KSA9PiB7XG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKF9jb21tZW50UmUsIFwiXCIpO1xufTtcbnZhciBfY29tbWVudFdpdGhIYXNoUmUgPSAvXFwvXFwqXFxzKiNcXHMqc291cmNlKE1hcHBpbmcpP1VSTD1bXFxzXFxTXSs/XFwqXFwvL2c7XG52YXIgZXh0cmFjdENvbW1lbnRzV2l0aEhhc2ggPSAoaW5wdXQpID0+IHtcbiAgcmV0dXJuIGlucHV0Lm1hdGNoKF9jb21tZW50V2l0aEhhc2hSZSkgfHwgW107XG59O1xudmFyIF9ydWxlUmUgPSAvKFxccyopKFteO1xce1xcfV0rPykoXFxzKikoKD86eyVCTE9DSyV9P1xccyo7Pyl8KD86XFxzKjspKS9nO1xudmFyIF9jdXJseVJlID0gLyhbe31dKS9nO1xudmFyIF9zZWxlY3RvclBhcnRzUmUgPSAvKF4uKj9bXlxcXFxdKT8/KCg6KykoLiopfCQpLztcbnZhciBPUEVOX0NVUkxZID0gXCJ7XCI7XG52YXIgQ0xPU0VfQ1VSTFkgPSBcIn1cIjtcbnZhciBCTE9DS19QTEFDRUhPTERFUiA9IFwiJUJMT0NLJVwiO1xudmFyIHByb2Nlc3NSdWxlcyA9IChpbnB1dCwgcnVsZUNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGlucHV0V2l0aEVzY2FwZWRCbG9ja3MgPSBlc2NhcGVCbG9ja3MoaW5wdXQpO1xuICBsZXQgbmV4dEJsb2NrSW5kZXggPSAwO1xuICByZXR1cm4gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5lc2NhcGVkU3RyaW5nLnJlcGxhY2UoX3J1bGVSZSwgKC4uLm0pID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IG1bMl07XG4gICAgbGV0IGNvbnRlbnQgPSBcIlwiO1xuICAgIGxldCBzdWZmaXggPSBtWzRdO1xuICAgIGxldCBjb250ZW50UHJlZml4ID0gXCJcIjtcbiAgICBpZiAoc3VmZml4ICYmIHN1ZmZpeC5zdGFydHNXaXRoKFwie1wiICsgQkxPQ0tfUExBQ0VIT0xERVIpKSB7XG4gICAgICBjb250ZW50ID0gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5ibG9ja3NbbmV4dEJsb2NrSW5kZXgrK107XG4gICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKEJMT0NLX1BMQUNFSE9MREVSLmxlbmd0aCArIDEpO1xuICAgICAgY29udGVudFByZWZpeCA9IFwie1wiO1xuICAgIH1cbiAgICBjb25zdCBjc3NSdWxlID0ge1xuICAgICAgc2VsZWN0b3IsXG4gICAgICBjb250ZW50XG4gICAgfTtcbiAgICBjb25zdCBydWxlID0gcnVsZUNhbGxiYWNrKGNzc1J1bGUpO1xuICAgIHJldHVybiBgJHttWzFdfSR7cnVsZS5zZWxlY3Rvcn0ke21bM119JHtjb250ZW50UHJlZml4fSR7cnVsZS5jb250ZW50fSR7c3VmZml4fWA7XG4gIH0pO1xufTtcbnZhciBlc2NhcGVCbG9ja3MgPSAoaW5wdXQpID0+IHtcbiAgY29uc3QgaW5wdXRQYXJ0cyA9IGlucHV0LnNwbGl0KF9jdXJseVJlKTtcbiAgY29uc3QgcmVzdWx0UGFydHMgPSBbXTtcbiAgY29uc3QgZXNjYXBlZEJsb2NrcyA9IFtdO1xuICBsZXQgYnJhY2tldENvdW50ID0gMDtcbiAgbGV0IGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gIGZvciAobGV0IHBhcnRJbmRleCA9IDA7IHBhcnRJbmRleCA8IGlucHV0UGFydHMubGVuZ3RoOyBwYXJ0SW5kZXgrKykge1xuICAgIGNvbnN0IHBhcnQgPSBpbnB1dFBhcnRzW3BhcnRJbmRleF07XG4gICAgaWYgKHBhcnQgPT09IENMT1NFX0NVUkxZKSB7XG4gICAgICBicmFja2V0Q291bnQtLTtcbiAgICB9XG4gICAgaWYgKGJyYWNrZXRDb3VudCA+IDApIHtcbiAgICAgIGN1cnJlbnRCbG9ja1BhcnRzLnB1c2gocGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVzY2FwZWRCbG9ja3MucHVzaChjdXJyZW50QmxvY2tQYXJ0cy5qb2luKFwiXCIpKTtcbiAgICAgICAgcmVzdWx0UGFydHMucHVzaChCTE9DS19QTEFDRUhPTERFUik7XG4gICAgICAgIGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gICAgICB9XG4gICAgICByZXN1bHRQYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICBpZiAocGFydCA9PT0gT1BFTl9DVVJMWSkge1xuICAgICAgYnJhY2tldENvdW50Kys7XG4gICAgfVxuICB9XG4gIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9ja1BhcnRzLmpvaW4oXCJcIikpO1xuICAgIHJlc3VsdFBhcnRzLnB1c2goQkxPQ0tfUExBQ0VIT0xERVIpO1xuICB9XG4gIGNvbnN0IHN0ckVzY2FwZWRCbG9ja3MgPSB7XG4gICAgZXNjYXBlZFN0cmluZzogcmVzdWx0UGFydHMuam9pbihcIlwiKSxcbiAgICBibG9ja3M6IGVzY2FwZWRCbG9ja3NcbiAgfTtcbiAgcmV0dXJuIHN0ckVzY2FwZWRCbG9ja3M7XG59O1xudmFyIGluc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dCA9IChjc3NUZXh0KSA9PiB7XG4gIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoX2NvbG9uSG9zdENvbnRleHRSZSwgYCQxJHtfcG9seWZpbGxIb3N0Q29udGV4dH1gKS5yZXBsYWNlKF9jb2xvbkhvc3RSZSwgYCQxJHtfcG9seWZpbGxIb3N0fWApLnJlcGxhY2UoX2NvbG9uU2xvdHRlZFJlLCBgJDEke19wb2x5ZmlsbFNsb3R0ZWR9YCk7XG4gIHJldHVybiBjc3NUZXh0O1xufTtcbnZhciBjb252ZXJ0Q29sb25SdWxlID0gKGNzc1RleHQsIHJlZ0V4cCwgcGFydFJlcGxhY2VyKSA9PiB7XG4gIHJldHVybiBjc3NUZXh0LnJlcGxhY2UocmVnRXhwLCAoLi4ubSkgPT4ge1xuICAgIGlmIChtWzJdKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IG1bMl0uc3BsaXQoXCIsXCIpO1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwID0gcGFydHNbaV0udHJpbSgpO1xuICAgICAgICBpZiAoIXApIGJyZWFrO1xuICAgICAgICByLnB1c2gocGFydFJlcGxhY2VyKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IsIHAsIG1bM10pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByLmpvaW4oXCIsXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIG1bM107XG4gICAgfVxuICB9KTtcbn07XG52YXIgY29sb25Ib3N0UGFydFJlcGxhY2VyID0gKGhvc3QsIHBhcnQsIHN1ZmZpeCkgPT4ge1xuICByZXR1cm4gaG9zdCArIHBhcnQucmVwbGFjZShfcG9seWZpbGxIb3N0LCBcIlwiKSArIHN1ZmZpeDtcbn07XG52YXIgY29udmVydENvbG9uSG9zdCA9IChjc3NUZXh0KSA9PiB7XG4gIHJldHVybiBjb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RSZSwgY29sb25Ib3N0UGFydFJlcGxhY2VyKTtcbn07XG52YXIgY29sb25Ib3N0Q29udGV4dFBhcnRSZXBsYWNlciA9IChob3N0LCBwYXJ0LCBzdWZmaXgpID0+IHtcbiAgaWYgKHBhcnQuaW5kZXhPZihfcG9seWZpbGxIb3N0KSA+IC0xKSB7XG4gICAgcmV0dXJuIGNvbG9uSG9zdFBhcnRSZXBsYWNlcihob3N0LCBwYXJ0LCBzdWZmaXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBob3N0ICsgcGFydCArIHN1ZmZpeCArIFwiLCBcIiArIHBhcnQgKyBcIiBcIiArIGhvc3QgKyBzdWZmaXg7XG4gIH1cbn07XG52YXIgY29udmVydENvbG9uU2xvdHRlZCA9IChjc3NUZXh0LCBzbG90U2NvcGVJZCkgPT4ge1xuICBjb25zdCBzbG90Q2xhc3MgPSBcIi5cIiArIHNsb3RTY29wZUlkICsgXCIgPiBcIjtcbiAgY29uc3Qgc2VsZWN0b3JzID0gW107XG4gIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbG9uU2xvdHRlZFJlLCAoLi4ubSkgPT4ge1xuICAgIGlmIChtWzJdKSB7XG4gICAgICBjb25zdCBjb21wb3VuZCA9IG1bMl0udHJpbSgpO1xuICAgICAgY29uc3Qgc3VmZml4ID0gbVszXTtcbiAgICAgIGNvbnN0IHNsb3R0ZWRTZWxlY3RvciA9IHNsb3RDbGFzcyArIGNvbXBvdW5kICsgc3VmZml4O1xuICAgICAgbGV0IHByZWZpeFNlbGVjdG9yID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGkgPSBtWzRdIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hhciA9IG1bNV1baV07XG4gICAgICAgIGlmIChjaGFyID09PSBcIn1cIiB8fCBjaGFyID09PSBcIixcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHByZWZpeFNlbGVjdG9yID0gY2hhciArIHByZWZpeFNlbGVjdG9yO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3JnU2VsZWN0b3IgPSAocHJlZml4U2VsZWN0b3IgKyBzbG90dGVkU2VsZWN0b3IpLnRyaW0oKTtcbiAgICAgIGNvbnN0IGFkZGVkU2VsZWN0b3IgPSBgJHtwcmVmaXhTZWxlY3Rvci50cmltRW5kKCl9JHtzbG90dGVkU2VsZWN0b3IudHJpbSgpfWAudHJpbSgpO1xuICAgICAgaWYgKG9yZ1NlbGVjdG9yICE9PSBhZGRlZFNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRTZWxlY3RvciA9IGAke2FkZGVkU2VsZWN0b3J9LCAke29yZ1NlbGVjdG9yfWA7XG4gICAgICAgIHNlbGVjdG9ycy5wdXNoKHtcbiAgICAgICAgICBvcmdTZWxlY3RvcixcbiAgICAgICAgICB1cGRhdGVkU2VsZWN0b3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xvdHRlZFNlbGVjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIG1bM107XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RvcnMsXG4gICAgY3NzVGV4dFxuICB9O1xufTtcbnZhciBjb252ZXJ0Q29sb25Ib3N0Q29udGV4dCA9IChjc3NUZXh0KSA9PiB7XG4gIHJldHVybiBjb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUsIGNvbG9uSG9zdENvbnRleHRQYXJ0UmVwbGFjZXIpO1xufTtcbnZhciBjb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzID0gKGNzc1RleHQpID0+IHtcbiAgcmV0dXJuIF9zaGFkb3dET01TZWxlY3RvcnNSZS5yZWR1Y2UoKHJlc3VsdCwgcGF0dGVybikgPT4gcmVzdWx0LnJlcGxhY2UocGF0dGVybiwgXCIgXCIpLCBjc3NUZXh0KTtcbn07XG52YXIgbWFrZVNjb3BlTWF0Y2hlciA9IChzY29wZVNlbGVjdG9yMikgPT4ge1xuICBjb25zdCBscmUgPSAvXFxbL2c7XG4gIGNvbnN0IHJyZSA9IC9cXF0vZztcbiAgc2NvcGVTZWxlY3RvcjIgPSBzY29wZVNlbGVjdG9yMi5yZXBsYWNlKGxyZSwgXCJcXFxcW1wiKS5yZXBsYWNlKHJyZSwgXCJcXFxcXVwiKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKFwiICsgc2NvcGVTZWxlY3RvcjIgKyBcIilcIiArIF9zZWxlY3RvclJlU3VmZml4LCBcIm1cIik7XG59O1xudmFyIHNlbGVjdG9yTmVlZHNTY29waW5nID0gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yMikgPT4ge1xuICBjb25zdCByZSA9IG1ha2VTY29wZU1hdGNoZXIoc2NvcGVTZWxlY3RvcjIpO1xuICByZXR1cm4gIXJlLnRlc3Qoc2VsZWN0b3IpO1xufTtcbnZhciBpbmplY3RTY29waW5nU2VsZWN0b3IgPSAoc2VsZWN0b3IsIHNjb3BpbmdTZWxlY3RvcikgPT4ge1xuICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShfc2VsZWN0b3JQYXJ0c1JlLCAoXywgYmVmb3JlID0gXCJcIiwgX2NvbG9uR3JvdXAsIGNvbG9uID0gXCJcIiwgYWZ0ZXIgPSBcIlwiKSA9PiB7XG4gICAgcmV0dXJuIGJlZm9yZSArIHNjb3BpbmdTZWxlY3RvciArIGNvbG9uICsgYWZ0ZXI7XG4gIH0pO1xufTtcbnZhciBhcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUgPSAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IyLCBob3N0U2VsZWN0b3IpID0+IHtcbiAgX3BvbHlmaWxsSG9zdFJlLmxhc3RJbmRleCA9IDA7XG4gIGlmIChfcG9seWZpbGxIb3N0UmUudGVzdChzZWxlY3RvcikpIHtcbiAgICBjb25zdCByZXBsYWNlQnkgPSBgLiR7aG9zdFNlbGVjdG9yfWA7XG4gICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlLCAoXywgc2VsZWN0b3IyKSA9PiBpbmplY3RTY29waW5nU2VsZWN0b3Ioc2VsZWN0b3IyLCByZXBsYWNlQnkpKS5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgcmVwbGFjZUJ5ICsgXCIgXCIpO1xuICB9XG4gIHJldHVybiBzY29wZVNlbGVjdG9yMiArIFwiIFwiICsgc2VsZWN0b3I7XG59O1xudmFyIGFwcGx5U3RyaWN0U2VsZWN0b3JTY29wZSA9IChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvcjIsIGhvc3RTZWxlY3RvcikgPT4ge1xuICBjb25zdCBpc1JlID0gL1xcW2lzPShbXlxcXV0qKVxcXS9nO1xuICBzY29wZVNlbGVjdG9yMiA9IHNjb3BlU2VsZWN0b3IyLnJlcGxhY2UoaXNSZSwgKF8sIC4uLnBhcnRzKSA9PiBwYXJ0c1swXSk7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IFwiLlwiICsgc2NvcGVTZWxlY3RvcjI7XG4gIGNvbnN0IF9zY29wZVNlbGVjdG9yUGFydCA9IChwKSA9PiB7XG4gICAgbGV0IHNjb3BlZFAgPSBwLnRyaW0oKTtcbiAgICBpZiAoIXNjb3BlZFApIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBpZiAocC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTEpIHtcbiAgICAgIHNjb3BlZFAgPSBhcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUocCwgc2NvcGVTZWxlY3RvcjIsIGhvc3RTZWxlY3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSBwLnJlcGxhY2UoX3BvbHlmaWxsSG9zdFJlLCBcIlwiKTtcbiAgICAgIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2NvcGVkUCA9IGluamVjdFNjb3BpbmdTZWxlY3Rvcih0LCBjbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkUDtcbiAgfTtcbiAgY29uc3Qgc2FmZUNvbnRlbnQgPSBzYWZlU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICBzZWxlY3RvciA9IHNhZmVDb250ZW50LmNvbnRlbnQ7XG4gIGxldCBzY29wZWRTZWxlY3RvciA9IFwiXCI7XG4gIGxldCBzdGFydEluZGV4ID0gMDtcbiAgbGV0IHJlcztcbiAgY29uc3Qgc2VwID0gLyggfD58XFwrfH4oPyE9KSlcXHMqL2c7XG4gIGNvbnN0IGhhc0hvc3QgPSBzZWxlY3Rvci5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gIGxldCBzaG91bGRTY29wZSA9ICFoYXNIb3N0O1xuICB3aGlsZSAoKHJlcyA9IHNlcC5leGVjKHNlbGVjdG9yKSkgIT09IG51bGwpIHtcbiAgICBjb25zdCBzZXBhcmF0b3IgPSByZXNbMV07XG4gICAgY29uc3QgcGFydDIgPSBzZWxlY3Rvci5zbGljZShzdGFydEluZGV4LCByZXMuaW5kZXgpLnRyaW0oKTtcbiAgICBzaG91bGRTY29wZSA9IHNob3VsZFNjb3BlIHx8IHBhcnQyLmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMTtcbiAgICBjb25zdCBzY29wZWRQYXJ0ID0gc2hvdWxkU2NvcGUgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydDIpIDogcGFydDI7XG4gICAgc2NvcGVkU2VsZWN0b3IgKz0gYCR7c2NvcGVkUGFydH0gJHtzZXBhcmF0b3J9IGA7XG4gICAgc3RhcnRJbmRleCA9IHNlcC5sYXN0SW5kZXg7XG4gIH1cbiAgY29uc3QgcGFydCA9IHNlbGVjdG9yLnN1YnN0cmluZyhzdGFydEluZGV4KTtcbiAgc2hvdWxkU2NvcGUgPSBzaG91bGRTY29wZSB8fCBwYXJ0LmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMTtcbiAgc2NvcGVkU2VsZWN0b3IgKz0gc2hvdWxkU2NvcGUgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydCkgOiBwYXJ0O1xuICByZXR1cm4gcmVzdG9yZVNhZmVTZWxlY3RvcihzYWZlQ29udGVudC5wbGFjZWhvbGRlcnMsIHNjb3BlZFNlbGVjdG9yKTtcbn07XG52YXIgc2NvcGVTZWxlY3RvciA9IChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvclRleHQsIGhvc3RTZWxlY3Rvciwgc2xvdFNlbGVjdG9yKSA9PiB7XG4gIHJldHVybiBzZWxlY3Rvci5zcGxpdChcIixcIikubWFwKChzaGFsbG93UGFydCkgPT4ge1xuICAgIGlmIChzbG90U2VsZWN0b3IgJiYgc2hhbGxvd1BhcnQuaW5kZXhPZihcIi5cIiArIHNsb3RTZWxlY3RvcikgPiAtMSkge1xuICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0LnRyaW0oKTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdG9yTmVlZHNTY29waW5nKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yVGV4dCkpIHtcbiAgICAgIHJldHVybiBhcHBseVN0cmljdFNlbGVjdG9yU2NvcGUoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3JUZXh0LCBob3N0U2VsZWN0b3IpLnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0LnRyaW0oKTtcbiAgICB9XG4gIH0pLmpvaW4oXCIsIFwiKTtcbn07XG52YXIgc2NvcGVTZWxlY3RvcnMgPSAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvclRleHQsIGhvc3RTZWxlY3Rvciwgc2xvdFNlbGVjdG9yLCBjb21tZW50T3JpZ2luYWxTZWxlY3RvcikgPT4ge1xuICByZXR1cm4gcHJvY2Vzc1J1bGVzKGNzc1RleHQsIChydWxlKSA9PiB7XG4gICAgbGV0IHNlbGVjdG9yID0gcnVsZS5zZWxlY3RvcjtcbiAgICBsZXQgY29udGVudCA9IHJ1bGUuY29udGVudDtcbiAgICBpZiAocnVsZS5zZWxlY3RvclswXSAhPT0gXCJAXCIpIHtcbiAgICAgIHNlbGVjdG9yID0gc2NvcGVTZWxlY3RvcihydWxlLnNlbGVjdG9yLCBzY29wZVNlbGVjdG9yVGV4dCwgaG9zdFNlbGVjdG9yLCBzbG90U2VsZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAocnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKFwiQG1lZGlhXCIpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aChcIkBzdXBwb3J0c1wiKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoXCJAcGFnZVwiKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoXCJAZG9jdW1lbnRcIikpIHtcbiAgICAgIGNvbnRlbnQgPSBzY29wZVNlbGVjdG9ycyhydWxlLmNvbnRlbnQsIHNjb3BlU2VsZWN0b3JUZXh0LCBob3N0U2VsZWN0b3IsIHNsb3RTZWxlY3RvciwgY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpO1xuICAgIH1cbiAgICBjb25zdCBjc3NSdWxlID0ge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLnJlcGxhY2UoL1xcc3syLH0vZywgXCIgXCIpLnRyaW0oKSxcbiAgICAgIGNvbnRlbnRcbiAgICB9O1xuICAgIHJldHVybiBjc3NSdWxlO1xuICB9KTtcbn07XG52YXIgc2NvcGVDc3NUZXh0ID0gKGNzc1RleHQsIHNjb3BlSWQsIGhvc3RTY29wZUlkLCBzbG90U2NvcGVJZCwgY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpID0+IHtcbiAgY3NzVGV4dCA9IGluc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dChjc3NUZXh0KTtcbiAgY3NzVGV4dCA9IGNvbnZlcnRDb2xvbkhvc3QoY3NzVGV4dCk7XG4gIGNzc1RleHQgPSBjb252ZXJ0Q29sb25Ib3N0Q29udGV4dChjc3NUZXh0KTtcbiAgY29uc3Qgc2xvdHRlZCA9IGNvbnZlcnRDb2xvblNsb3R0ZWQoY3NzVGV4dCwgc2xvdFNjb3BlSWQpO1xuICBjc3NUZXh0ID0gc2xvdHRlZC5jc3NUZXh0O1xuICBjc3NUZXh0ID0gY29udmVydFNoYWRvd0RPTVNlbGVjdG9ycyhjc3NUZXh0KTtcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBjc3NUZXh0ID0gc2NvcGVTZWxlY3RvcnMoY3NzVGV4dCwgc2NvcGVJZCwgaG9zdFNjb3BlSWQsIHNsb3RTY29wZUlkLCBjb21tZW50T3JpZ2luYWxTZWxlY3Rvcik7XG4gIH1cbiAgY3NzVGV4dCA9IHJlcGxhY2VTaGFkb3dDc3NIb3N0KGNzc1RleHQsIGhvc3RTY29wZUlkKTtcbiAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZSgvPlxccypcXCpcXHMrKFteeywgXSspL2dtLCBcIiAkMSBcIik7XG4gIHJldHVybiB7XG4gICAgY3NzVGV4dDogY3NzVGV4dC50cmltKCksXG4gICAgLy8gV2UgbmVlZCB0byByZXBsYWNlIHRoZSBzaGFkb3cgQ1NTIGhvc3Qgc3RyaW5nIGluIGVhY2ggb2YgdGhlc2Ugc2VsZWN0b3JzIHNpbmNlIHdlIGNyZWF0ZWRcbiAgICAvLyB0aGVtIHByaW9yIHRvIHRoZSByZXBsYWNlbWVudCBoYXBwZW5pbmcgaW4gdGhlIGNvbXBvbmVudHMgQ1NTIHRleHQuXG4gICAgc2xvdHRlZFNlbGVjdG9yczogc2xvdHRlZC5zZWxlY3RvcnMubWFwKChyZWYpID0+ICh7XG4gICAgICBvcmdTZWxlY3RvcjogcmVwbGFjZVNoYWRvd0Nzc0hvc3QocmVmLm9yZ1NlbGVjdG9yLCBob3N0U2NvcGVJZCksXG4gICAgICB1cGRhdGVkU2VsZWN0b3I6IHJlcGxhY2VTaGFkb3dDc3NIb3N0KHJlZi51cGRhdGVkU2VsZWN0b3IsIGhvc3RTY29wZUlkKVxuICAgIH0pKVxuICB9O1xufTtcbnZhciByZXBsYWNlU2hhZG93Q3NzSG9zdCA9IChjc3NUZXh0LCBob3N0U2NvcGVJZCkgPT4ge1xuICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKC8tc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yL2csIGAuJHtob3N0U2NvcGVJZH1gKTtcbn07XG52YXIgc2NvcGVDc3MgPSAoY3NzVGV4dCwgc2NvcGVJZCwgY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpID0+IHtcbiAgY29uc3QgaG9zdFNjb3BlSWQgPSBzY29wZUlkICsgXCItaFwiO1xuICBjb25zdCBzbG90U2NvcGVJZCA9IHNjb3BlSWQgKyBcIi1zXCI7XG4gIGNvbnN0IGNvbW1lbnRzV2l0aEhhc2ggPSBleHRyYWN0Q29tbWVudHNXaXRoSGFzaChjc3NUZXh0KTtcbiAgY3NzVGV4dCA9IHN0cmlwQ29tbWVudHMoY3NzVGV4dCk7XG4gIGNvbnN0IG9yZ1NlbGVjdG9ycyA9IFtdO1xuICBpZiAoY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpIHtcbiAgICBjb25zdCBwcm9jZXNzQ29tbWVudGVkU2VsZWN0b3IgPSAocnVsZSkgPT4ge1xuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBgLyohQF9fXyR7b3JnU2VsZWN0b3JzLmxlbmd0aH1fX18qL2A7XG4gICAgICBjb25zdCBjb21tZW50ID0gYC8qIUAke3J1bGUuc2VsZWN0b3J9Ki9gO1xuICAgICAgb3JnU2VsZWN0b3JzLnB1c2goeyBwbGFjZWhvbGRlciwgY29tbWVudCB9KTtcbiAgICAgIHJ1bGUuc2VsZWN0b3IgPSBwbGFjZWhvbGRlciArIHJ1bGUuc2VsZWN0b3I7XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9O1xuICAgIGNzc1RleHQgPSBwcm9jZXNzUnVsZXMoY3NzVGV4dCwgKHJ1bGUpID0+IHtcbiAgICAgIGlmIChydWxlLnNlbGVjdG9yWzBdICE9PSBcIkBcIikge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc0NvbW1lbnRlZFNlbGVjdG9yKHJ1bGUpO1xuICAgICAgfSBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoXCJAbWVkaWFcIikgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKFwiQHN1cHBvcnRzXCIpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aChcIkBwYWdlXCIpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aChcIkBkb2N1bWVudFwiKSkge1xuICAgICAgICBydWxlLmNvbnRlbnQgPSBwcm9jZXNzUnVsZXMocnVsZS5jb250ZW50LCBwcm9jZXNzQ29tbWVudGVkU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHNjb3BlZCA9IHNjb3BlQ3NzVGV4dChjc3NUZXh0LCBzY29wZUlkLCBob3N0U2NvcGVJZCwgc2xvdFNjb3BlSWQsIGNvbW1lbnRPcmlnaW5hbFNlbGVjdG9yKTtcbiAgY3NzVGV4dCA9IFtzY29wZWQuY3NzVGV4dCwgLi4uY29tbWVudHNXaXRoSGFzaF0uam9pbihcIlxcblwiKTtcbiAgaWYgKGNvbW1lbnRPcmlnaW5hbFNlbGVjdG9yKSB7XG4gICAgb3JnU2VsZWN0b3JzLmZvckVhY2goKHsgcGxhY2Vob2xkZXIsIGNvbW1lbnQgfSkgPT4ge1xuICAgICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShwbGFjZWhvbGRlciwgY29tbWVudCk7XG4gICAgfSk7XG4gIH1cbiAgc2NvcGVkLnNsb3R0ZWRTZWxlY3RvcnMuZm9yRWFjaCgoc2xvdHRlZFNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cFNwZWNpYWxDaGFyYWN0ZXJzKHNsb3R0ZWRTZWxlY3Rvci5vcmdTZWxlY3RvciksIFwiZ1wiKTtcbiAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKHJlZ2V4LCBzbG90dGVkU2VsZWN0b3IudXBkYXRlZFNlbGVjdG9yKTtcbiAgfSk7XG4gIHJldHVybiBjc3NUZXh0O1xufTtcbmV4cG9ydCB7XG4gIHNjb3BlQ3NzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@stencil/core/internal/client/shadow-css.js\n"));

/***/ })

}]);